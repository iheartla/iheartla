#!/usr/bin/env python

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.

from __future__ import annotations

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.parsing import leftrec, nomemo, isname # noqa
from tatsu.infos import ParserConfig
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class grammarconfigBuffer(Buffer):
    def __init__(self, text, /, config: ParserConfig = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=re.compile('(?!.*)'),
            nameguard=None,
            comments_re=None,
            eol_comments_re=None,
            ignorecase=False,
            namechars='',
            parseinfo=False,
        )
        config = config.replace(**settings)
        super().__init__(text, config=config)


class grammarconfigParser(Parser):
    def __init__(self, /, config: ParserConfig = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=re.compile('(?!.*)'),
            nameguard=None,
            comments_re=None,
            eol_comments_re=None,
            ignorecase=False,
            namechars='',
            parseinfo=False,
            keywords=KEYWORDS,
            start='start',
        )
        config = config.replace(**settings)
        super().__init__(config=config)

    @tatsumasu('Start')
    def _start_(self):  # noqa

        def block0():

            def block1():
                self._separator_with_space_()
            self._closure(block1)

            def block2():
                self._hspace_()
            self._closure(block2)
            self._valid_block_()
            self.add_last_node_to_name('vblock')

            def block4():
                self._separator_with_space_()
            self._closure(block4)

            self._define(
                [],
                ['vblock']
            )
        self._positive_closure(block0)

        def block5():
            self._blank_()
        self._closure(block5)
        self._check_eof()

        self._define(
            [],
            ['vblock']
        )

    @tatsumasu()
    def _IS_(self):  # noqa
        self._pattern('is')

    @tatsumasu()
    def _TRIANGLE_(self):  # noqa
        self._pattern('triangle')

    @tatsumasu()
    def _MESH_(self):  # noqa
        self._pattern('mesh')

    @tatsumasu()
    def _POINT_(self):  # noqa
        self._pattern('point')

    @tatsumasu()
    def _CLOUD_(self):  # noqa
        self._pattern('cloud')

    @tatsumasu()
    def _LU_(self):  # noqa
        self._pattern('LU')

    @tatsumasu()
    def _ODE_(self):  # noqa
        self._pattern('ODE')

    @tatsumasu()
    def _EXPLICIT_(self):  # noqa
        self._pattern('explicit')

    @tatsumasu()
    def _IMPLICIT_(self):  # noqa
        self._pattern('implicit')

    @tatsumasu()
    def _EULER_(self):  # noqa
        self._pattern('euler')

    @tatsumasu()
    def _RK_(self):  # noqa
        self._pattern('RK')

    @tatsumasu()
    def _CONF_KEYWORDS_(self):  # noqa
        with self._choice():
            with self._option():
                self._IS_()
            with self._option():
                self._TRIANGLE_()
            with self._option():
                self._MESH_()
            with self._option():
                self._FROM_()
            with self._option():
                self._SOLVE_()
            with self._option():
                self._WITH_()
            with self._option():
                self._ODE_()
            with self._option():
                self._EXPLICIT_()
            with self._option():
                self._IMPLICIT_()
            with self._option():
                self._EULER_()
            with self._option():
                self._RK_()
            with self._option():
                self._DELTA_()
            with self._option():
                self._NABLA_()
            with self._option():
                self._pattern('‚àá‚ãÖ')
            with self._option():
                self._POUND_()
            self._error(
                'expecting one of: '
                '# <DELTA> <EULER> <EXPLICIT> <FROM>'
                '<IMPLICIT> <IS> <MESH> <NABLA> <ODE>'
                '<POUND> <RK> <SOLVE> <TRIANGLE> <WITH>'
                'ODE RK SOLVE Solve [Œî] euler explicit'
                'from implicit is mesh solve triangle'
                'with ‚àá ‚àá‚ãÖ'
            )

    @tatsumasu()
    def _identifier_(self):  # noqa
        with self._choice():
            with self._option():
                self._identifier_with_subscript_()
            with self._option():
                self._identifier_alone_()
            self._error(
                'expecting one of: '
                '<CONF_KEYWORDS> <DELTA> <EULER>'
                '<EXPLICIT> <FROM> <IMPLICIT> <IS>'
                '<KEYWORDS> <MESH> <NABLA> <ODE> <POUND>'
                '<RK> <SOLVE> <TRIANGLE> <WITH>'
                '<identifier_alone>'
                '<identifier_with_subscript> ODE RK euler'
                'explicit implicit is mesh triangle ‚àá‚ãÖ'
            )

    @tatsumasu()
    def _expression_(self):  # noqa
        self._identifier_()

    @tatsumasu()
    def _TRACE_(self):  # noqa
        self._pattern('trace')

    @tatsumasu()
    def _TR_(self):  # noqa
        self._pattern('tr')

    @tatsumasu()
    def _VEC_(self):  # noqa
        self._pattern('vec')

    @tatsumasu()
    def _INVERSEVEC_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('inversevec')
            with self._option():
                self._pattern('vec‚Åª¬π')
            self._error(
                'expecting one of: '
                'inversevec vec‚Åª¬π'
            )

    @tatsumasu()
    def _DIAG_(self):  # noqa
        self._pattern('diag')

    @tatsumasu()
    def _INV_(self):  # noqa
        self._pattern('inv')

    @tatsumasu()
    def _DET_(self):  # noqa
        self._pattern('det')

    @tatsumasu()
    def _RANK_(self):  # noqa
        self._pattern('rank')

    @tatsumasu()
    def _NULL_(self):  # noqa
        self._pattern('null')

    @tatsumasu()
    def _ORTH_(self):  # noqa
        self._pattern('orth')

    @tatsumasu()
    def _QR_(self):  # noqa
        self._pattern('qr')

    @tatsumasu()
    def _DERIVATIVE_(self):  # noqa
        self._pattern('ùïï')

    @tatsumasu()
    def _PARTIAL_(self):  # noqa
        self._pattern('‚àÇ')

    @tatsumasu()
    def _WHERE_(self):  # noqa
        self._pattern('where')

    @tatsumasu()
    def _GIVEN_(self):  # noqa
        self._pattern('given')

    @tatsumasu()
    def _SUM_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('sum')
            with self._option():
                self._pattern('‚àë')
            self._error(
                'expecting one of: '
                'sum ‚àë'
            )

    @tatsumasu()
    def _MIN_(self):  # noqa
        self._pattern('min')

    @tatsumasu()
    def _MAX_(self):  # noqa
        self._pattern('max')

    @tatsumasu()
    def _ARGMIN_(self):  # noqa
        self._pattern('argmin')

    @tatsumasu()
    def _ARGMAX_(self):  # noqa
        self._pattern('argmax')

    @tatsumasu()
    def _INT_(self):  # noqa
        self._pattern('int')

    @tatsumasu()
    def _SPARSE_(self):  # noqa
        self._pattern('sparse')

    @tatsumasu()
    def _IF_(self):  # noqa
        self._pattern('if')

    @tatsumasu()
    def _OTHERWISE_(self):  # noqa
        self._pattern('otherwise')

    @tatsumasu()
    def _IN_(self):  # noqa
        self._pattern('‚àà')

    @tatsumasu()
    def _SIN_(self):  # noqa
        self._pattern('sin')

    @tatsumasu()
    def _ASIN_(self):  # noqa
        self._pattern('asin')

    @tatsumasu()
    def _ARCSIN_(self):  # noqa
        self._pattern('arcsin')

    @tatsumasu()
    def _COS_(self):  # noqa
        self._pattern('cos')

    @tatsumasu()
    def _ACOS_(self):  # noqa
        self._pattern('acos')

    @tatsumasu()
    def _ARCCOS_(self):  # noqa
        self._pattern('arccos')

    @tatsumasu()
    def _TAN_(self):  # noqa
        self._pattern('tan')

    @tatsumasu()
    def _ATAN_(self):  # noqa
        self._pattern('atan')

    @tatsumasu()
    def _ARCTAN_(self):  # noqa
        self._pattern('arctan')

    @tatsumasu()
    def _SINH_(self):  # noqa
        self._pattern('sinh')

    @tatsumasu()
    def _ASINH_(self):  # noqa
        self._pattern('asinh')

    @tatsumasu()
    def _ARSINH_(self):  # noqa
        self._pattern('arsinh')

    @tatsumasu()
    def _COSH_(self):  # noqa
        self._pattern('cosh')

    @tatsumasu()
    def _ACOSH_(self):  # noqa
        self._pattern('acosh')

    @tatsumasu()
    def _ARCOSH_(self):  # noqa
        self._pattern('arcosh')

    @tatsumasu()
    def _TANH_(self):  # noqa
        self._pattern('tanh')

    @tatsumasu()
    def _ATANH_(self):  # noqa
        self._pattern('atanh')

    @tatsumasu()
    def _ARTANH_(self):  # noqa
        self._pattern('artanh')

    @tatsumasu()
    def _COT_(self):  # noqa
        self._pattern('cot')

    @tatsumasu()
    def _SEC_(self):  # noqa
        self._pattern('sec')

    @tatsumasu()
    def _CSC_(self):  # noqa
        self._pattern('csc')

    @tatsumasu()
    def _ATAN2_(self):  # noqa
        self._pattern('atan2')

    @tatsumasu()
    def _EXP_(self):  # noqa
        self._pattern('exp')

    @tatsumasu()
    def _LOG_(self):  # noqa
        self._pattern('log')

    @tatsumasu()
    def _LN_(self):  # noqa
        self._pattern('ln')

    @tatsumasu()
    def _SQRT_(self):  # noqa
        self._pattern('sqrt')

    @tatsumasu()
    def _SUBJECT_TO_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('s.t.')
            with self._option():
                self._pattern('subject to')
            self._error(
                'expecting one of: '
                's.t. subject to'
            )

    @tatsumasu()
    def _FROM_(self):  # noqa
        self._pattern('from')

    @tatsumasu()
    def _PI_(self):  # noqa
        self._pattern('œÄ')

    @tatsumasu()
    def _WITH_(self):  # noqa
        self._pattern('with')

    @tatsumasu()
    def _INITIAL_(self):  # noqa
        self._pattern('initial')

    @tatsumasu()
    def _AND_(self):  # noqa
        self._pattern('and')

    @tatsumasu()
    def _OR_(self):  # noqa
        self._pattern('or')

    @tatsumasu()
    def _DELTA_(self):  # noqa
        self._pattern('[Œî]')

    @tatsumasu()
    def _NABLA_(self):  # noqa
        self._pattern('‚àá')

    @tatsumasu()
    def _PRIME_(self):  # noqa
        self._pattern("'")

    @tatsumasu()
    def _UDOT_(self):  # noqa
        self._pattern('[\\u0307]')

    @tatsumasu()
    def _UDDOT_(self):  # noqa
        self._pattern('[\\u0308]')

    @tatsumasu()
    def _SOLVE_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('solve')
            with self._option():
                self._pattern('Solve')
            with self._option():
                self._pattern('SOLVE')
            self._error(
                'expecting one of: '
                'SOLVE Solve solve'
            )

    @tatsumasu()
    def _SUBSET_(self):  # noqa
        self._pattern('‚äÇ')

    @tatsumasu()
    def _AS_(self):  # noqa
        self._pattern('as')

    @tatsumasu()
    def _POUND_(self):  # noqa
        self._pattern('#')

    @tatsumasu()
    def _FOR_(self):  # noqa
        self._pattern('for')

    @tatsumasu()
    def _SCALAR_(self):  # noqa
        self._pattern('scalar')

    @tatsumasu()
    def _VECTOR_(self):  # noqa
        self._pattern('vector')

    @tatsumasu()
    def _MATRIX_(self):  # noqa
        self._pattern('matrix')

    @tatsumasu()
    def _VERTEXSET_(self):  # noqa
        self._pattern('[Vv]ertex[Ss]et')

    @tatsumasu()
    def _EDGESET_(self):  # noqa
        self._pattern('[Ee]dge[Ss]et')

    @tatsumasu()
    def _FACESET_(self):  # noqa
        self._pattern('[Ff]ace[Ss]et')

    @tatsumasu()
    def _TETSET_(self):  # noqa
        self._pattern('[Cc]ell[Ss]et')

    @tatsumasu()
    def _SIMPLICIALSET_(self):  # noqa
        self._pattern('[Cc]ellular[Ss]et')

    @tatsumasu()
    def _EDGEMESH_(self):  # noqa
        self._pattern('[Ee]dge[Mm]esh')

    @tatsumasu()
    def _FACEMESH_(self):  # noqa
        self._pattern('[Ff]ace[Mm]esh')

    @tatsumasu()
    def _CELLMESH_(self):  # noqa
        self._pattern('[Cc]ell[Mm]esh')

    @tatsumasu()
    def _INDEX_(self):  # noqa
        self._pattern('index')

    @tatsumasu()
    def _VERTICES_(self):  # noqa
        self._pattern('vertices')

    @tatsumasu()
    def _EDGES_(self):  # noqa
        self._pattern('edges')

    @tatsumasu()
    def _FACES_(self):  # noqa
        self._pattern('faces')

    @tatsumasu()
    def _TETS_(self):  # noqa
        self._pattern('cells')

    @tatsumasu()
    def _TUPLE_(self):  # noqa
        self._pattern('tuple')

    @tatsumasu()
    def _SEQUENCE_(self):  # noqa
        self._pattern('sequence')

    @tatsumasu()
    def _SVD_(self):  # noqa
        self._pattern('svd')

    @tatsumasu()
    def _BUILTIN_KEYWORDS_(self):  # noqa
        with self._choice():
            with self._option():
                self._WHERE_()
            with self._option():
                self._GIVEN_()
            with self._option():
                self._pattern('sum')
            with self._option():
                self._MIN_()
            with self._option():
                self._MAX_()
            with self._option():
                self._ARGMIN_()
            with self._option():
                self._ARGMAX_()
            with self._option():
                self._INT_()
            with self._option():
                self._IF_()
            with self._option():
                self._OTHERWISE_()
            with self._option():
                self._IN_()
            with self._option():
                self._EXP_()
            with self._option():
                self._LOG_()
            with self._option():
                self._LN_()
            with self._option():
                self._SQRT_()
            with self._option():
                self._SUBJECT_TO_()
            with self._option():
                self._FROM_()
            with self._option():
                self._PI_()
            with self._option():
                self._pattern('‚Ñù')
            with self._option():
                self._pattern('‚Ñ§')
            with self._option():
                self._SCALAR_()
            with self._option():
                self._VECTOR_()
            with self._option():
                self._MATRIX_()
            with self._option():
                self._WITH_()
            with self._option():
                self._INITIAL_()
            with self._option():
                self._AND_()
            with self._option():
                self._OR_()
            with self._option():
                self._DELTA_()
            with self._option():
                self._NABLA_()
            with self._option():
                self._DERIVATIVE_()
            with self._option():
                self._SOLVE_()
            with self._option():
                self._PRIME_()
            with self._option():
                self._SUBSET_()
            with self._option():
                self._AS_()
            with self._option():
                self._POUND_()
            with self._option():
                self._FOR_()
            with self._option():
                self._VERTEXSET_()
            with self._option():
                self._EDGESET_()
            with self._option():
                self._FACESET_()
            with self._option():
                self._TETSET_()
            with self._option():
                self._SIMPLICIALSET_()
            with self._option():
                self._EDGEMESH_()
            with self._option():
                self._FACEMESH_()
            with self._option():
                self._CELLMESH_()
            with self._option():
                self._SPARSE_()
            with self._option():
                self._INDEX_()
            with self._option():
                self._VERTICES_()
            with self._option():
                self._EDGES_()
            with self._option():
                self._FACES_()
            with self._option():
                self._TETS_()
            with self._option():
                self._TUPLE_()
            with self._option():
                self._SEQUENCE_()
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<CELLMESH> <DELTA> <DERIVATIVE>'
                '<EDGEMESH> <EDGES> <EDGESET> <EXP>'
                '<FACEMESH> <FACES> <FACESET> <FOR>'
                '<FROM> <GIVEN> <IF> <IN> <INDEX>'
                '<INITIAL> <INT> <LN> <LOG> <MATRIX>'
                '<MAX> <MIN> <NABLA> <OR> <OTHERWISE>'
                '<PI> <POUND> <PRIME> <SCALAR> <SEQUENCE>'
                '<SIMPLICIALSET> <SOLVE> <SPARSE> <SQRT>'
                '<SUBJECT_TO> <SUBSET> <TETS> <TETSET>'
                '<TUPLE> <VECTOR> <VERTEXSET> <VERTICES>'
                '<WHERE> <WITH> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu()
    def _NOT_PREFIX_KEYWORD_(self):  # noqa
        with self._choice():
            with self._option():
                self._POUND_()
            with self._option():
                self._DELTA_()
            with self._option():
                self._NABLA_()
            with self._option():
                self._IN_()
            with self._option():
                self._DERIVATIVE_()
            self._error(
                'expecting one of: '
                '# <DELTA> <DERIVATIVE> <IN> <NABLA>'
                '<POUND> [Œî] ‚àá ‚àà ùïï'
            )

    @tatsumasu()
    def _PREFIX_KEYWORD_(self):  # noqa
        with self._ifnot():
            self._NOT_PREFIX_KEYWORD_()
        with self._group():
            self._KEYWORDS_()

    @tatsumasu()
    def _hspace_(self):  # noqa
        self._pattern('[ \\t]')

    @tatsumasu()
    def _line_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('\n')
            with self._option():
                self._token('\r')
            with self._option():
                self._token('\x0c')
            self._error(
                'expecting one of: '
                "'\\n' '\\r' '\\x0c'"
            )

    @tatsumasu()
    def _lines_(self):  # noqa

        def block0():
            self._line_()
        self._positive_closure(block0)

    @tatsumasu('IdentifierSubscript')
    def _identifier_with_subscript_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    self._token('_')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._integer_()
                            with self._option():
                                self._token('*')
                            with self._option():
                                self._identifier_alone_()
                            self._error(
                                'expecting one of: '
                                "'*' <identifier_alone> <integer>"
                            )
                    self.add_last_node_to_name('right')

                    def block4():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            with self._option():
                                with self._group():

                                    def block7():
                                        self._token(',')
                                    self._closure(block7)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._integer_()
                                            with self._option():
                                                self._identifier_alone_()
                                            self._error(
                                                'expecting one of: '
                                                '<identifier_alone> <integer>'
                                            )
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <identifier_alone> <integer>"
                            )
                    self._closure(block4)

                    self._define(
                        ['left'],
                        ['right']
                    )
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    self._token('_(')
                    self.name_last_node('p')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._integer_()
                            with self._option():
                                self._token('*')
                            with self._option():
                                self._identifier_alone_()
                            self._error(
                                'expecting one of: '
                                "'*' <identifier_alone> <integer>"
                            )
                    self.add_last_node_to_name('right')

                    def block14():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            with self._option():
                                with self._group():

                                    def block17():
                                        self._token(',')
                                    self._closure(block17)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._integer_()
                                            with self._option():
                                                self._identifier_alone_()
                                            self._error(
                                                'expecting one of: '
                                                '<identifier_alone> <integer>'
                                            )
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <identifier_alone> <integer>"
                            )
                    self._closure(block14)
                    self._token(')')

                    self._define(
                        ['left', 'p'],
                        ['right']
                    )
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._sub_integer_()
                            with self._option():
                                self._unicode_subscript_()
                            self._error(
                                'expecting one of: '
                                '<sub_integer> <unicode_subscript>'
                            )
                    self.add_last_node_to_name('right')

                    def block23():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            with self._option():
                                with self._group():

                                    def block26():
                                        self._token(',')
                                    self._closure(block26)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._sub_integer_()
                                            with self._option():
                                                self._unicode_subscript_()
                                            self._error(
                                                'expecting one of: '
                                                '<sub_integer> <unicode_subscript>'
                                            )
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <sub_integer> <unicode_subscript>"
                            )
                    self._closure(block23)

                    self._define(
                        ['left'],
                        ['right']
                    )
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    self._token('_(')
                    self.name_last_node('p')

                    def block31():
                        self._hspace_()
                    self._closure(block31)
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('*')
                            with self._option():
                                self._expression_()
                            self._error(
                                'expecting one of: '
                                "'*' <expression>"
                            )
                    self.add_last_node_to_name('exp')

                    def block34():
                        with self._choice():
                            with self._option():
                                with self._group():

                                    def block36():
                                        self._hspace_()
                                    self._closure(block36)
                                    self._token(',')

                                    def block37():
                                        self._hspace_()
                                    self._closure(block37)
                                    self._token('*')
                                    self.add_last_node_to_name('exp')

                                    self._define(
                                        [],
                                        ['exp']
                                    )
                            with self._option():
                                with self._group():

                                    def block39():
                                        self._hspace_()
                                    self._closure(block39)
                                    self._token(',')

                                    def block40():
                                        self._hspace_()
                                    self._closure(block40)
                                    self._expression_()
                                    self.add_last_node_to_name('exp')

                                    self._define(
                                        [],
                                        ['exp']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <hspace>"
                            )
                    self._closure(block34)

                    def block42():
                        self._hspace_()
                    self._closure(block42)
                    self._token(')')

                    self._define(
                        ['left', 'p'],
                        ['exp']
                    )
            self._error(
                'expecting one of: '
                '<CONF_KEYWORDS> <DELTA> <EULER>'
                '<EXPLICIT> <FROM> <IMPLICIT> <IS>'
                '<KEYWORDS> <MESH> <NABLA> <ODE> <POUND>'
                '<RK> <SOLVE> <TRIANGLE> <WITH>'
                '<identifier_alone> ODE RK euler explicit'
                'implicit is mesh triangle ‚àá‚ãÖ'
            )

    @tatsumasu('IdentifierSubscript')
    def _identifier_with_unicode_subscript_(self):  # noqa
        self._identifier_alone_()
        self.name_last_node('left')
        with self._group():
            with self._choice():
                with self._option():
                    self._sub_integer_()
                with self._option():
                    self._unicode_subscript_()
                self._error(
                    'expecting one of: '
                    '<sub_integer> <unicode_subscript>'
                )
        self.add_last_node_to_name('right')

        def block3():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token(',')
                        self._token('*')
                        self.add_last_node_to_name('right')

                        self._define(
                            [],
                            ['right']
                        )
                with self._option():
                    with self._group():

                        def block6():
                            self._token(',')
                        self._closure(block6)
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._sub_integer_()
                                with self._option():
                                    self._unicode_subscript_()
                                self._error(
                                    'expecting one of: '
                                    '<sub_integer> <unicode_subscript>'
                                )
                        self.add_last_node_to_name('right')

                        self._define(
                            [],
                            ['right']
                        )
                self._error(
                    'expecting one of: '
                    "',' <sub_integer> <unicode_subscript>"
                )
        self._closure(block3)

        self._define(
            ['left'],
            ['right']
        )

    @tatsumasu('IdentifierAlone')
    def _unicode_subscript_(self):  # noqa
        self._pattern('[\\u2090-\\u209C\\u1D62\\u2C7C]')
        self.name_last_node('value')

    @tatsumasu('IdentifierAlone')
    def _unicode_superscript_(self):  # noqa
        self._pattern('[\\u1D43\\u1D47\\u1D9C\\u1D48\\u1D49\\u1DA0\\u1D4D\\u02B0\\u2071\\u02B2\\u1D4F\\u02E1\\u1D50\\u207F\\u1D52\\u1D56\\u02B3\\u02E2\\u1D57\\u1D58\\u1D5B\\u02B7\\u02E3\\u02B8\\u1DBB\\u1DA6\\u1DAB\\u1DB0\\u1DB8\\u1D2C\\u1D2E\\u1D30\\u1D31\\u1D33\\u1D34\\u1D35\\u1D36\\u1D37\\u1D38\\u1D39\\u1D3A\\u1D3C\\u1D3E\\u1D3F\\u1D40\\u1D41\\u2C7D\\u1D42]')
        self.name_last_node('value')

    @tatsumasu('SizeOp')
    def _size_op_(self):  # noqa
        self._POUND_()
        self._identifier_()
        self.name_last_node('i')

        self._define(
            ['i'],
            []
        )

    @tatsumasu()
    def _keyword_str_(self):  # noqa
        self._pattern('[A-Za-z][A-Za-z0-9]*')

    @tatsumasu('IdentifierAlone')
    def _multi_str_(self):  # noqa
        with self._choice():
            with self._option():
                with self._ifnot():
                    self._KEYWORDS_()
                with self._group():
                    with self._choice():
                        with self._option():
                            with self._group():
                                self._pattern('[A-Za-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:[‚Åª¬πA-Z0-9a-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*')
                            self.name_last_node('value')
                        with self._option():
                            self._token('`')
                            self._pattern('[^`]*')
                            self.name_last_node('id')
                            self._token('`')

                            self._define(
                                ['id'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'`' [A-Za-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:"
                            '[‚Åª¬πA-Z0-9a-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*'
                        )

                self._define(
                    ['id', 'value'],
                    []
                )
            with self._option():
                with self._group():
                    self._PREFIX_KEYWORD_()
                    with self._group():
                        self._pattern('[A-Za-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:[‚Åª¬πA-Z0-9a-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*')
                self.name_last_node('value')
            self._error(
                'expecting one of: '
                '# <CONF_KEYWORDS> <DELTA> <DERIVATIVE>'
                '<EULER> <EXPLICIT> <FROM> <IMPLICIT>'
                '<IN> <IS> <KEYWORDS> <MESH> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <ODE> <POUND>'
                '<PREFIX_KEYWORD> <RK> <SOLVE> <TRIANGLE>'
                '<WITH> ODE RK [Œî] euler explicit'
                'implicit is mesh triangle ‚àá ‚àá‚ãÖ ‚àà ùïï'
            )

    @tatsumasu()
    def _description_(self):  # noqa
        self._pattern('[^;\\n\\r\\f]*')

    @tatsumasu()
    def _desc_identifier_(self):  # noqa
        with self._ifnot():
            self._KEYWORDS_()
        self._token('`')
        self._pattern('[A-Za-z][[A-Za-z0-9]*')
        self._token('`')

    @tatsumasu()
    def _separator_(self):  # noqa
        with self._choice():
            with self._option():
                self._line_()
            with self._option():
                self._token(';')
            self._error(
                'expecting one of: '
                "';' '\\n' '\\r' '\\x0c' <line>"
            )

    @tatsumasu()
    def _separator_with_space_(self):  # noqa

        def block0():
            self._hspace_()
        self._closure(block0)
        self._separator_()

        def block1():
            self._hspace_()
        self._closure(block1)

    @tatsumasu()
    def _blank_(self):  # noqa

        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._hspace_()
                    with self._option():
                        self._separator_()
                    self._error(
                        'expecting one of: '
                        '<hspace> <separator>'
                    )
        self._closure(block0)

    @tatsumasu()
    def _params_separator_(self):  # noqa
        self._pattern('[,;x\\u00D7]')

    @tatsumasu('Pi')
    def _pi_(self):  # noqa
        self._pattern('œÄ')

    @tatsumasu('Infinity')
    def _infinity_(self):  # noqa
        self._pattern('‚àû')

    @tatsumasu('E')
    def _e_(self):  # noqa
        self._pattern('e')

    @tatsumasu('ArithExpression')
    @leftrec
    def _arithmetic_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_addition_()
                self.name_last_node('value')
            with self._option():
                self._arithmetic_subtraction_()
                self.name_last_node('value')
            with self._option():
                with self._optional():
                    self._token('-')
                self.name_last_node('sign')
                self._arithmetic_term_()
                self.name_last_node('value')

                self._define(
                    ['sign', 'value'],
                    []
                )
            self._error(
                'expecting one of: '
                "'-' <arithmetic_addition>"
                '<arithmetic_division>'
                '<arithmetic_expression>'
                '<arithmetic_factor>'
                '<arithmetic_multiplication>'
                '<arithmetic_subtraction>'
                '<arithmetic_term>'
            )

    @tatsumasu('ArithAdd')
    @nomemo
    def _arithmetic_addition_(self):  # noqa
        self._arithmetic_expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('+')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._arithmetic_term_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('ArithSubtract')
    @nomemo
    def _arithmetic_subtraction_(self):  # noqa
        self._arithmetic_expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('-')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._arithmetic_term_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    @leftrec
    def _arithmetic_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_multiplication_()
            with self._option():
                self._arithmetic_division_()
            with self._option():
                self._arithmetic_factor_()
            self._error(
                'expecting one of: '
                '# <POUND> <arithmetic_division>'
                '<arithmetic_factor>'
                '<arithmetic_multiplication>'
                '<arithmetic_subexpression>'
                '<arithmetic_term> <identifier>'
                '<identifier_alone>'
                '<identifier_with_subscript> <number>'
                '<size_op>'
            )

    @tatsumasu('ArithMultiply')
    @nomemo
    def _arithmetic_multiplication_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_term_()
                self.name_last_node('left')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._token('‚ãÖ')
                self.name_last_node('op')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._arithmetic_factor_()
                self.name_last_node('right')

                self._define(
                    ['left', 'op', 'right'],
                    []
                )
            with self._option():
                self._arithmetic_term_()
                self.name_last_node('left')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._arithmetic_factor_()
                self.name_last_node('right')

                self._define(
                    ['left', 'right'],
                    []
                )
            self._error(
                'expecting one of: '
                '# <POUND> <arithmetic_division>'
                '<arithmetic_factor>'
                '<arithmetic_multiplication>'
                '<arithmetic_subexpression>'
                '<arithmetic_term> <identifier>'
                '<identifier_alone>'
                '<identifier_with_subscript> <number>'
                '<size_op>'
            )

    @tatsumasu('ArithDivide')
    @nomemo
    def _arithmetic_division_(self):  # noqa
        self._arithmetic_term_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/')
                with self._option():
                    self._token('√∑')
                self._error(
                    'expecting one of: '
                    "'/' '√∑'"
                )
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._arithmetic_factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('ArithFactor')
    def _arithmetic_factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_subexpression_()
                self.name_last_node('sub')
            with self._option():
                self._size_op_()
                self.name_last_node('size')
            with self._option():
                self._identifier_()
                self.name_last_node('id0')
            with self._option():
                self._number_()
                self.name_last_node('num')
            self._error(
                'expecting one of: '
                "# '(' '.' <CONF_KEYWORDS> <DELTA>"
                '<EULER> <EXPLICIT> <FROM> <IMPLICIT>'
                '<IS> <KEYWORDS> <MESH> <NABLA> <ODE>'
                '<POUND> <RK> <SOLVE> <TRIANGLE> <WITH>'
                '<arithmetic_subexpression> <digit>'
                '<double> <floating_point> <fraction>'
                '<identifier> <identifier_alone>'
                '<identifier_with_subscript> <integer>'
                '<mantissa> <number> <size_op> ODE RK'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] \\d euler'
                'explicit implicit is mesh triangle ‚àá‚ãÖ'
            )

    @tatsumasu('ArithSubexpression')
    def _arithmetic_subexpression_(self):  # noqa
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._arithmetic_expression_()
        self.name_last_node('value')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['value'],
            []
        )

    @tatsumasu('MatrixType')
    def _matrix_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._MATRIX_()

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._token('(')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._dimension_()
                self.name_last_node('id1')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._token(',')

                def block5():
                    self._hspace_()
                self._closure(block5)
                self._dimension_()
                self.name_last_node('id2')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._token(')')

                def block8():

                    def block9():
                        self._hspace_()
                    self._positive_closure(block9)
                    self._matrix_attribute_()
                    self.add_last_node_to_name('attr')

                    self._define(
                        [],
                        ['attr']
                    )
                self._closure(block8)

                self._define(
                    ['id1', 'id2'],
                    ['attr']
                )
            with self._option():
                self._pattern('[‚Ñù‚Ñ§]')
                self.name_last_node('type')

                def block12():
                    self._hspace_()
                self._closure(block12)
                self._token('^')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._token('(')

                def block14():
                    self._hspace_()
                self._closure(block14)
                self._dimension_()
                self.name_last_node('id1')

                def block16():
                    self._hspace_()
                self._closure(block16)
                self._token('√ó')

                def block17():
                    self._hspace_()
                self._closure(block17)
                self._dimension_()
                self.name_last_node('id2')

                def block19():
                    self._hspace_()
                self._closure(block19)
                self._token(')')

                def block20():

                    def block21():
                        self._hspace_()
                    self._positive_closure(block21)
                    self._matrix_attribute_()
                    self.add_last_node_to_name('attr')

                    self._define(
                        [],
                        ['attr']
                    )
                self._closure(block20)

                self._define(
                    ['id1', 'id2', 'type'],
                    ['attr']
                )
            self._error(
                'expecting one of: '
                '<MATRIX> [‚Ñù‚Ñ§] matrix'
            )

    @tatsumasu()
    def _matrix_attribute_(self):  # noqa
        self._SPARSE_()

    @tatsumasu('VectorType')
    def _vector_type_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._VECTOR_()

                    def block1():
                        self._hspace_()
                    self._closure(block1)
                    self._token('(')

                    def block2():
                        self._hspace_()
                    self._closure(block2)
                    self._dimension_()
                    self.name_last_node('id1')

                    def block4():
                        self._hspace_()
                    self._closure(block4)
                    self._token(')')

                    self._define(
                        ['id1'],
                        []
                    )
                with self._option():
                    self._pattern('[‚Ñù‚Ñ§]')
                    self.name_last_node('type')

                    def block6():
                        self._hspace_()
                    self._closure(block6)
                    self._token('^')

                    def block7():
                        self._hspace_()
                    self._closure(block7)
                    self._token('(')

                    def block8():
                        self._hspace_()
                    self._closure(block8)
                    self._dimension_()
                    self.name_last_node('id1')

                    def block10():
                        self._hspace_()
                    self._closure(block10)
                    self._token(')')

                    self._define(
                        ['id1', 'type'],
                        []
                    )
                with self._option():
                    self._pattern('[‚Ñù‚Ñ§]')
                    self.name_last_node('type')

                    def block12():
                        self._hspace_()
                    self._closure(block12)
                    self._token('^')

                    def block13():
                        self._hspace_()
                    self._closure(block13)
                    self._dimension_()
                    self.name_last_node('id1')

                    self._define(
                        ['id1', 'type'],
                        []
                    )
                with self._option():
                    self._pattern('[‚Ñù‚Ñ§]')
                    self.name_last_node('type')
                    self._sup_integer_()
                    self.name_last_node('id1')

                    self._define(
                        ['id1', 'type'],
                        []
                    )
                self._error(
                    'expecting one of: '
                    '<VECTOR> [‚Ñù‚Ñ§]'
                )

        def block17():

            def block18():
                self._hspace_()
            self._positive_closure(block18)
            self._matrix_attribute_()
            self.add_last_node_to_name('attr')

            self._define(
                [],
                ['attr']
            )
        self._closure(block17)

        self._define(
            ['id1', 'type'],
            ['attr']
        )

    @tatsumasu('ScalarType')
    def _scalar_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._SCALAR_()
            with self._option():
                self._pattern('‚Ñù')
            with self._option():
                self._pattern('‚Ñ§')
                self.name_last_node('z')
            self._error(
                'expecting one of: '
                '<SCALAR> scalar ‚Ñù ‚Ñ§'
            )

    @tatsumasu('SetType')
    def _set_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('{')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._pattern('[‚Ñù‚Ñ§]')
                self.add_last_node_to_name('type')

                def block3():
                    self._hspace_()
                self._closure(block3)

                def block4():
                    self._token('√ó')

                    def block5():
                        self._hspace_()
                    self._closure(block5)
                    self._pattern('[‚Ñù‚Ñ§]')
                    self.add_last_node_to_name('type')

                    def block7():
                        self._hspace_()
                    self._closure(block7)

                    self._define(
                        [],
                        ['type']
                    )
                self._closure(block4)
                self._token('}')

                self._define(
                    [],
                    ['type']
                )
            with self._option():
                self._token('{')

                def block8():
                    self._hspace_()
                self._closure(block8)
                self._pattern('[‚Ñù‚Ñ§]')
                self.name_last_node('type1')

                def block10():
                    self._hspace_()
                self._closure(block10)
                self._token('^')

                def block11():
                    self._hspace_()
                self._closure(block11)
                with self._group():
                    self._integer_()
                self.name_last_node('cnt')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._token('}')

                self._define(
                    ['cnt', 'type1'],
                    []
                )
            with self._option():
                self._token('{')

                def block14():
                    self._hspace_()
                self._closure(block14)
                self._pattern('[‚Ñù‚Ñ§]')
                self.name_last_node('type2')
                with self._optional():
                    self._sup_integer_()
                self.name_last_node('cnt')

                def block17():
                    self._hspace_()
                self._closure(block17)
                self._token('}')

                self._define(
                    ['cnt', 'type2'],
                    []
                )
            with self._option():
                self._token('{')

                def block18():
                    self._hspace_()
                self._closure(block18)
                self._params_type_()
                self.add_last_node_to_name('sub_types')

                def block20():
                    self._hspace_()
                self._closure(block20)

                def block21():
                    self._token('√ó')

                    def block22():
                        self._hspace_()
                    self._closure(block22)
                    self._params_type_()
                    self.add_last_node_to_name('sub_types')

                    def block24():
                        self._hspace_()
                    self._closure(block24)

                    self._define(
                        [],
                        ['sub_types']
                    )
                self._closure(block21)
                self._token('}')

                self._define(
                    [],
                    ['sub_types']
                )
            with self._option():
                self._token('{')

                def block25():
                    self._hspace_()
                self._closure(block25)
                self._params_type_()
                self.add_last_node_to_name('homogeneous_types')

                def block27():
                    self._hspace_()
                self._closure(block27)

                def block28():
                    self._token('‚à®')

                    def block29():
                        self._hspace_()
                    self._closure(block29)
                    self._params_type_()
                    self.add_last_node_to_name('homogeneous_types')

                    def block31():
                        self._hspace_()
                    self._closure(block31)

                    self._define(
                        [],
                        ['homogeneous_types']
                    )
                self._positive_closure(block28)
                self._token('}')

                self._define(
                    [],
                    ['homogeneous_types']
                )
            self._error(
                'expecting one of: '
                "'{'"
            )

    @tatsumasu('TupleType')
    @leftrec
    def _tuple_type_(self):  # noqa
        self._params_type_()
        self.add_last_node_to_name('sub_types')

        def block1():
            self._hspace_()
        self._closure(block1)

        def block2():
            self._token('√ó')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._params_type_()
            self.add_last_node_to_name('sub_types')

            def block5():
                self._hspace_()
            self._closure(block5)

            self._define(
                [],
                ['sub_types']
            )
        self._positive_closure(block2)

        self._define(
            [],
            ['sub_types']
        )

    @tatsumasu()
    def _dimension_(self):  # noqa
        self._arithmetic_expression_()

    @tatsumasu('NamedType')
    def _named_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._VERTEXSET_()
                self.name_last_node('v')
            with self._option():
                self._EDGESET_()
                self.name_last_node('e')
            with self._option():
                self._FACESET_()
                self.name_last_node('f')
            with self._option():
                self._TETSET_()
                self.name_last_node('t')
            with self._option():
                self._SIMPLICIALSET_()
                self.name_last_node('s')
            with self._option():
                self._mesh_type_()
                self.name_last_node('m')
            self._error(
                'expecting one of: '
                '<CELLMESH> <EDGEMESH> <EDGESET>'
                '<FACEMESH> <FACESET> <SIMPLICIALSET>'
                '<TETSET> <VERTEXSET> <mesh_type>'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et'
            )

    @tatsumasu()
    def _mesh_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._EDGEMESH_()
                self.name_last_node('e')
            with self._option():
                self._FACEMESH_()
                self.name_last_node('f')
            with self._option():
                self._CELLMESH_()
                self.name_last_node('c')
            self._error(
                'expecting one of: '
                '<CELLMESH> <EDGEMESH> <FACEMESH>'
                '[Cc]ell[Mm]esh [Ee]dge[Mm]esh'
                '[Ff]ace[Mm]esh'
            )

    @tatsumasu()
    def _la_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._function_type_()
            with self._option():
                self._mapping_type_()
            with self._option():
                self._matrix_type_()
            with self._option():
                self._vector_type_()
            with self._option():
                self._set_type_()
            with self._option():
                self._tuple_type_()
            with self._option():
                self._scalar_type_()
            with self._option():
                self._named_type_()
            self._error(
                'expecting one of: '
                "'{' '‚àÖ' <CELLMESH> <EDGEMESH> <EDGESET>"
                '<FACEMESH> <FACESET> <MATRIX> <SCALAR>'
                '<SIMPLICIALSET> <TETSET> <VECTOR>'
                '<VERTEXSET> <function_type> <identifier>'
                '<identifier_alone>'
                '<identifier_with_subscript>'
                '<mapping_type> <matrix_type> <mesh_type>'
                '<named_type> <params_type> <scalar_type>'
                '<set_type> <tuple_type> <vector_type>'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [‚Ñù‚Ñ§]'
                'matrix scalar vector ‚Ñù ‚Ñ§'
            )

    @tatsumasu()
    @nomemo
    def _params_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._matrix_type_()
            with self._option():
                self._vector_type_()
            with self._option():
                self._scalar_type_()
            with self._option():
                self._set_type_()
            with self._option():
                self._tuple_type_()
            self._error(
                'expecting one of: '
                "'{' <MATRIX> <SCALAR> <VECTOR>"
                '<matrix_type> <params_type>'
                '<scalar_type> <set_type> <tuple_type>'
                '<vector_type> [‚Ñù‚Ñ§] matrix scalar vector'
                '‚Ñù ‚Ñ§'
            )

    @tatsumasu('FunctionType')
    def _function_type_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._params_type_()
                        self.add_last_node_to_name('params')

                        def block2():

                            def block3():
                                self._hspace_()
                            self._closure(block3)
                            self._params_separator_()
                            self.add_last_node_to_name('separators')

                            def block5():
                                self._hspace_()
                            self._closure(block5)
                            self._params_type_()
                            self.add_last_node_to_name('params')

                            self._define(
                                [],
                                ['params', 'separators']
                            )
                        self._closure(block2)

                        self._define(
                            [],
                            ['params', 'separators']
                        )
                with self._option():
                    self._token('‚àÖ')
                    self.name_last_node('empty')
                with self._option():
                    self._token('{')

                    def block8():
                        self._hspace_()
                    self._closure(block8)
                    self._token('}')
                self._error(
                    'expecting one of: '
                    "'{' '‚àÖ' <params_type>"
                )

        def block9():
            self._hspace_()
        self._closure(block9)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('‚Üí')
                with self._option():
                    self._token('->')
                self._error(
                    'expecting one of: '
                    "'->' '‚Üí'"
                )

        def block11():
            self._hspace_()
        self._closure(block11)
        self._params_type_()
        self.add_last_node_to_name('ret')

        def block13():

            def block14():
                self._hspace_()
            self._closure(block14)
            self._params_separator_()
            self.add_last_node_to_name('ret_separators')

            def block16():
                self._hspace_()
            self._closure(block16)
            self._params_type_()
            self.add_last_node_to_name('ret')

            self._define(
                [],
                ['ret', 'ret_separators']
            )
        self._closure(block13)

        self._define(
            ['empty'],
            ['params', 'ret', 'ret_separators', 'separators']
        )

    @tatsumasu('MappingType')
    def _mapping_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._identifier_()
                self.name_last_node('src')

                def block2():
                    self._hspace_()
                self._closure(block2)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('‚Üí')
                        with self._option():
                            self._token('->')
                        self._error(
                            'expecting one of: '
                            "'->' '‚Üí'"
                        )

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._params_type_()
                self.name_last_node('dst')

                self._define(
                    ['dst', 'src'],
                    []
                )
            with self._option():
                self._identifier_()
                self.name_last_node('s')
            self._error(
                'expecting one of: '
                '<CONF_KEYWORDS> <DELTA> <EULER>'
                '<EXPLICIT> <FROM> <IMPLICIT> <IS>'
                '<KEYWORDS> <MESH> <NABLA> <ODE> <POUND>'
                '<RK> <SOLVE> <TRIANGLE> <WITH>'
                '<identifier> <identifier_alone>'
                '<identifier_with_subscript> ODE RK euler'
                'explicit implicit is mesh triangle ‚àá‚ãÖ'
            )

    @tatsumasu('Integer')
    def _integer_(self):  # noqa

        def block1():
            self._digit_()
        self._positive_closure(block1)
        self.name_last_node('value')

    @tatsumasu('SupInteger')
    def _sup_integer_(self):  # noqa

        def block1():
            self._pattern('[\\u2070\\u00B9\\u00B2\\u00B3\\u2074-\\u2079]')
        self._positive_closure(block1)
        self.name_last_node('value')

    @tatsumasu('SubInteger')
    def _sub_integer_(self):  # noqa

        def block1():
            self._pattern('[\\u2080-\\u2089]')
        self._positive_closure(block1)
        self.name_last_node('value')

    @tatsumasu()
    def _digit_(self):  # noqa
        self._pattern('\\d')

    @tatsumasu('Exponent')
    def _exponent_(self):  # noqa
        self._pattern('[E][+-]?')
        self.name_last_node('exp')

        def block2():
            self._digit_()
        self._positive_closure(block2)
        self.name_last_node('pow')

        self._define(
            ['exp', 'pow'],
            []
        )

    @tatsumasu('Mantissa')
    def _mantissa_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():

                    def block2():
                        self._digit_()
                    self._closure(block2)
                    self.name_last_node('d')
                    self._token('.')

                    def block4():
                        self._digit_()
                    self._positive_closure(block4)
                    self.name_last_node('f')

                    self._define(
                        ['d', 'f'],
                        []
                    )
            with self._option():
                with self._group():

                    def block6():
                        self._digit_()
                    self._positive_closure(block6)
                    self.name_last_node('d')
                    self._token('.')

                    self._define(
                        ['d'],
                        []
                    )
            self._error(
                'expecting one of: '
                "'.' <digit> \\d"
            )

    @tatsumasu('Float')
    def _floating_point_(self):  # noqa
        self._mantissa_()
        self.name_last_node('m')
        with self._optional():
            self._exponent_()
        self.name_last_node('e')

        self._define(
            ['e', 'm'],
            []
        )

    @tatsumasu('Double')
    def _double_(self):  # noqa
        with self._choice():
            with self._option():
                self._integer_()
                self.name_last_node('i')
                self._exponent_()
                self.name_last_node('exp')

                self._define(
                    ['exp', 'i'],
                    []
                )
            with self._option():
                self._floating_point_()
                self.name_last_node('f')
            self._error(
                'expecting one of: '
                "'.' <digit> <floating_point> <integer>"
                '<mantissa> \\d'
            )

    @tatsumasu('Fraction')
    def _fraction_(self):  # noqa
        self._pattern('[\\u00BC-\\u00BE\\u2150-\\u215E]')
        self.name_last_node('value')

    @tatsumasu()
    def _number_(self):  # noqa
        with self._choice():
            with self._option():
                self._double_()
            with self._option():
                self._fraction_()
            with self._option():
                self._integer_()
            self._error(
                'expecting one of: '
                "'.' <digit> <double> <floating_point>"
                '<fraction> <integer> <mantissa>'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] \\d'
            )

    @tatsumasu()
    def _KEYWORDS_(self):  # noqa
        self._CONF_KEYWORDS_()

    @tatsumasu('IdentifierAlone')
    def _identifier_alone_(self):  # noqa
        with self._ifnot():
            self._KEYWORDS_()
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._pattern('[A-Za-z\\p{Ll}\\p{Lu}\\p{Lo}](?![\\u0308\\u0307])\\p{M}*([A-Z0-9a-z\\p{Ll}\\p{Lu}\\p{Lo}](?![\\u0308\\u0307])\\p{M}*)*')
                            with self._option():
                                self._pattern('[A-Za-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?=[\\u0308\\u0307])([A-Z0-9a-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?=[\\u0308\\u0307]))*')
                            self._error(
                                'expecting one of: '
                                '[A-Za-'
                                'z\\p{Ll}\\p{Lu}\\p{Lo}](?![\\u0308\\u0307])\\p'
                                '{M}*([A-Z0-9a-'
                                'z\\p{Ll}\\p{Lu}\\p{Lo}](?![\\u0308\\u0307])\\p'
                                '{M}*)* [A-Za-'
                                'z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?=[\\u0308\\u03'
                                '07])([A-Z0-9a-'
                                'z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?=[\\u0308\\u03'
                                '07]))*'
                            )
                    self.name_last_node('value')
                with self._option():
                    self._token('`')
                    self._pattern('[^`]*')
                    self.name_last_node('id')
                    self._token('`')

                    self._define(
                        ['id'],
                        []
                    )
                self._error(
                    'expecting one of: '
                    "'`' [A-Za-"
                    'z\\p{Ll}\\p{Lu}\\p{Lo}](?![\\u0308\\u0307])\\p'
                    '{M}*([A-Z0-9a-'
                    'z\\p{Ll}\\p{Lu}\\p{Lo}](?![\\u0308\\u0307])\\p'
                    '{M}*)* [A-Za-'
                    'z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?=[\\u0308\\u03'
                    '07])([A-Z0-9a-'
                    'z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?=[\\u0308\\u03'
                    '07]))*'
                )

        self._define(
            ['id', 'value'],
            []
        )

    @tatsumasu()
    def _valid_block_(self):  # noqa
        with self._choice():
            with self._option():
                self._definition_()
            with self._option():
                self._import_def_()
            with self._option():
                self._where_condition_()
            with self._option():
                self._solver_()
            self._error(
                'expecting one of: '
                '<Divergence> <Gradient> <Laplacian>'
                '<SOLVE> <definition> <identifier>'
                '<identifier_alone>'
                '<identifier_with_subscript> <import_def>'
                '<operators> <solver> <where_condition>'
                'SOLVE Solve solve'
            )

    @tatsumasu('Geometry')
    def _definition_(self):  # noqa
        self._identifier_()
        self.name_last_node('id')

        def block1():
            self._hspace_()
        self._positive_closure(block1)
        self._IS_()

        def block2():
            self._hspace_()
        self._positive_closure(block2)
        self._geometry_type_()
        self.name_last_node('g')

        self._define(
            ['g', 'id'],
            []
        )

    @tatsumasu()
    def _geometry_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._triangle_mesh_()
            with self._option():
                self._point_cloud_()
            self._error(
                'expecting one of: '
                '<POINT> <TRIANGLE> <point_cloud>'
                '<triangle_mesh> point triangle'
            )

    @tatsumasu('Triangle')
    def _triangle_mesh_(self):  # noqa
        self._TRIANGLE_()

        def block0():
            self._hspace_()
        self._positive_closure(block0)
        self._MESH_()

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('(')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._identifier_()
        self.name_last_node('v')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._token(',')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._identifier_()
        self.name_last_node('e')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(',')

        def block8():
            self._hspace_()
        self._closure(block8)
        self._identifier_()
        self.name_last_node('f')

        def block10():
            self._hspace_()
        self._closure(block10)
        self._token(')')

        self._define(
            ['e', 'f', 'v'],
            []
        )

    @tatsumasu('Point')
    def _point_cloud_(self):  # noqa
        self._POINT_()

        def block0():
            self._hspace_()
        self._positive_closure(block0)
        self._CLOUD_()

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('(')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._identifier_()
        self.name_last_node('v')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._token(')')

        self._define(
            ['v'],
            []
        )

    @tatsumasu('Operators')
    def _operators_(self):  # noqa
        with self._choice():
            with self._option():
                self._Divergence_()
                self.name_last_node('d')
            with self._option():
                self._Gradient_()
                self.name_last_node('g')
            with self._option():
                self._Laplacian_()
                self.name_last_node('l')
            self._error(
                'expecting one of: '
                '<DELTA> <Divergence> <Gradient>'
                '<Laplacian> <NABLA> [Œî] ‚àá ‚àá‚ãÖ'
            )

    @tatsumasu()
    def _Divergence_(self):  # noqa
        self._pattern('‚àá‚ãÖ')

    @tatsumasu()
    def _Gradient_(self):  # noqa
        self._NABLA_()

    @tatsumasu()
    def _Laplacian_(self):  # noqa
        self._DELTA_()

    @tatsumasu('WhereCondition')
    def _where_condition_(self):  # noqa
        self._identifier_()
        self.add_last_node_to_name('id')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._identifier_()
            self.add_last_node_to_name('id')

            self._define(
                [],
                ['id']
            )
        self._closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                with self._option():
                    self._IN_()
                self._error(
                    'expecting one of: '
                    "':' <IN>"
                )

        def block7():
            self._hspace_()
        self._closure(block7)
        self._la_type_()
        self.name_last_node('type')

        def block9():

            def block10():
                self._hspace_()
            self._closure(block10)
            self._token('index')
            self.name_last_node('index')

            self._define(
                ['index'],
                []
            )
        self._closure(block9)

        def block12():

            def block13():
                self._hspace_()
            self._closure(block13)
            self._token(':')

            def block14():
                self._hspace_()
            self._closure(block14)
            self._description_()
            self.name_last_node('desc')

            self._define(
                ['desc'],
                []
            )
        self._closure(block12)

        self._define(
            ['desc', 'index', 'type'],
            ['id']
        )

    @tatsumasu('ImportDef')
    def _import_def_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._identifier_()
                with self._option():
                    self._operators_()
                self._error(
                    'expecting one of: '
                    '<identifier> <operators>'
                )
        self.name_last_node('lhs')

        def block2():
            self._hspace_()
        self._closure(block2)
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                with self._option():
                    self._IN_()
                self._error(
                    'expecting one of: '
                    "':' <IN>"
                )

        def block4():
            self._hspace_()
        self._closure(block4)
        self._import_()
        self.name_last_node('rhs')

        self._define(
            ['lhs', 'rhs'],
            []
        )

    @tatsumasu('Import')
    def _import_(self):  # noqa
        self._import_var_()
        self.add_last_node_to_name('names')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._import_var_()
            self.add_last_node_to_name('names')

            self._define(
                [],
                ['names']
            )
        self._closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        self._FROM_()

        def block6():
            self._hspace_()
        self._positive_closure(block6)
        self._module_()
        self.name_last_node('package')

        def block8():
            self._hspace_()
        self._closure(block8)

        def block9():
            self._token('(')

            def block10():

                def block11():
                    self._hspace_()
                self._closure(block11)
                self._module_param_()
                self.add_last_node_to_name('params')

                def block13():

                    def block14():
                        self._hspace_()
                    self._closure(block14)
                    self._params_separator_()
                    self.add_last_node_to_name('separators')

                    def block16():
                        self._hspace_()
                    self._closure(block16)
                    self._module_param_()
                    self.add_last_node_to_name('params')

                    self._define(
                        [],
                        ['params', 'separators']
                    )
                self._closure(block13)

                self._define(
                    [],
                    ['params', 'separators']
                )
            self._closure(block10)

            def block18():
                self._hspace_()
            self._closure(block18)
            self._token(')')

            self._define(
                [],
                ['params', 'separators']
            )
        self._closure(block9)

        def block19():
            self._hspace_()
        self._closure(block19)

        self._define(
            ['package'],
            ['names', 'params', 'separators']
        )

    @tatsumasu('ImportVar')
    def _import_var_(self):  # noqa
        self._identifier_()
        self.name_last_node('name')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._AS_()

            def block3():
                self._hspace_()
            self._closure(block3)
            self._identifier_()
            self.name_last_node('r')

            self._define(
                ['r'],
                []
            )
        self._closure(block1)

        self._define(
            ['name', 'r'],
            []
        )

    @tatsumasu()
    def _map_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._params_type_()
            with self._option():
                self._size_op_()
            with self._option():
                self._identifier_()
            self._error(
                'expecting one of: '
                "# '{' <CONF_KEYWORDS> <DELTA> <EULER>"
                '<EXPLICIT> <FROM> <IMPLICIT> <IS>'
                '<KEYWORDS> <MATRIX> <MESH> <NABLA> <ODE>'
                '<POUND> <RK> <SCALAR> <SOLVE> <TRIANGLE>'
                '<VECTOR> <WITH> <identifier>'
                '<identifier_alone>'
                '<identifier_with_subscript>'
                '<matrix_type> <params_type>'
                '<scalar_type> <set_type> <size_op>'
                '<tuple_type> <vector_type> ODE RK [‚Ñù‚Ñ§]'
                'euler explicit implicit is matrix mesh'
                'scalar triangle vector ‚Ñù ‚Ñ§ ‚àá‚ãÖ'
            )

    @tatsumasu()
    def _module_param_(self):  # noqa
        with self._choice():
            with self._option():
                self._size_op_()
            with self._option():
                self._identifier_()
            self._error(
                'expecting one of: '
                '# <CONF_KEYWORDS> <DELTA> <EULER>'
                '<EXPLICIT> <FROM> <IMPLICIT> <IS>'
                '<KEYWORDS> <MESH> <NABLA> <ODE> <POUND>'
                '<RK> <SOLVE> <TRIANGLE> <WITH>'
                '<identifier> <identifier_alone>'
                '<identifier_with_subscript> <size_op>'
                'ODE RK euler explicit implicit is mesh'
                'triangle ‚àá‚ãÖ'
            )

    @tatsumasu('Module')
    def _module_(self):  # noqa
        with self._ifnot():
            self._KEYWORDS_()
        self._pattern('[A-Za-z0-9_]*')

    @tatsumasu()
    def _solver_(self):  # noqa
        self._SOLVE_()

        def block0():
            self._hspace_()
        self._closure(block0)
        self._target_()

        def block1():
            self._hspace_()
        self._closure(block1)
        self._WITH_()

        def block2():
            self._hspace_()
        self._closure(block2)
        self._method_()

    @tatsumasu()
    def _target_(self):  # noqa
        with self._choice():
            with self._option():
                self._ODE_()
            with self._option():
                self._module_()
            self._error(
                'expecting one of: '
                '# <CONF_KEYWORDS> <DELTA> <EULER>'
                '<EXPLICIT> <FROM> <IMPLICIT> <IS>'
                '<KEYWORDS> <MESH> <NABLA> <ODE> <POUND>'
                '<RK> <SOLVE> <TRIANGLE> <WITH> <module>'
                'ODE RK SOLVE Solve [Œî] euler explicit'
                'from implicit is mesh solve triangle'
                'with ‚àá ‚àá‚ãÖ'
            )

    @tatsumasu()
    def _method_(self):  # noqa
        with self._choice():
            with self._option():
                self._LU_()
            with self._option():
                self._EXPLICIT_()

                def block1():
                    self._hspace_()
                self._positive_closure(block1)
                self._EULER_()
            with self._option():
                self._IMPLICIT_()

                def block2():
                    self._hspace_()
                self._positive_closure(block2)
                self._EULER_()
            with self._option():
                self._RK_()
            self._error(
                'expecting one of: '
                '<EXPLICIT> <IMPLICIT> <LU> <RK> LU RK'
                'explicit implicit'
            )


class grammarconfigSemantics:
    def start(self, ast):  # noqa
        return ast

    def IS(self, ast):  # noqa
        return ast

    def TRIANGLE(self, ast):  # noqa
        return ast

    def MESH(self, ast):  # noqa
        return ast

    def POINT(self, ast):  # noqa
        return ast

    def CLOUD(self, ast):  # noqa
        return ast

    def LU(self, ast):  # noqa
        return ast

    def ODE(self, ast):  # noqa
        return ast

    def EXPLICIT(self, ast):  # noqa
        return ast

    def IMPLICIT(self, ast):  # noqa
        return ast

    def EULER(self, ast):  # noqa
        return ast

    def RK(self, ast):  # noqa
        return ast

    def CONF_KEYWORDS(self, ast):  # noqa
        return ast

    def identifier(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def TRACE(self, ast):  # noqa
        return ast

    def TR(self, ast):  # noqa
        return ast

    def VEC(self, ast):  # noqa
        return ast

    def INVERSEVEC(self, ast):  # noqa
        return ast

    def DIAG(self, ast):  # noqa
        return ast

    def INV(self, ast):  # noqa
        return ast

    def DET(self, ast):  # noqa
        return ast

    def RANK(self, ast):  # noqa
        return ast

    def NULL(self, ast):  # noqa
        return ast

    def ORTH(self, ast):  # noqa
        return ast

    def QR(self, ast):  # noqa
        return ast

    def DERIVATIVE(self, ast):  # noqa
        return ast

    def PARTIAL(self, ast):  # noqa
        return ast

    def WHERE(self, ast):  # noqa
        return ast

    def GIVEN(self, ast):  # noqa
        return ast

    def SUM(self, ast):  # noqa
        return ast

    def MIN(self, ast):  # noqa
        return ast

    def MAX(self, ast):  # noqa
        return ast

    def ARGMIN(self, ast):  # noqa
        return ast

    def ARGMAX(self, ast):  # noqa
        return ast

    def INT(self, ast):  # noqa
        return ast

    def SPARSE(self, ast):  # noqa
        return ast

    def IF(self, ast):  # noqa
        return ast

    def OTHERWISE(self, ast):  # noqa
        return ast

    def IN(self, ast):  # noqa
        return ast

    def SIN(self, ast):  # noqa
        return ast

    def ASIN(self, ast):  # noqa
        return ast

    def ARCSIN(self, ast):  # noqa
        return ast

    def COS(self, ast):  # noqa
        return ast

    def ACOS(self, ast):  # noqa
        return ast

    def ARCCOS(self, ast):  # noqa
        return ast

    def TAN(self, ast):  # noqa
        return ast

    def ATAN(self, ast):  # noqa
        return ast

    def ARCTAN(self, ast):  # noqa
        return ast

    def SINH(self, ast):  # noqa
        return ast

    def ASINH(self, ast):  # noqa
        return ast

    def ARSINH(self, ast):  # noqa
        return ast

    def COSH(self, ast):  # noqa
        return ast

    def ACOSH(self, ast):  # noqa
        return ast

    def ARCOSH(self, ast):  # noqa
        return ast

    def TANH(self, ast):  # noqa
        return ast

    def ATANH(self, ast):  # noqa
        return ast

    def ARTANH(self, ast):  # noqa
        return ast

    def COT(self, ast):  # noqa
        return ast

    def SEC(self, ast):  # noqa
        return ast

    def CSC(self, ast):  # noqa
        return ast

    def ATAN2(self, ast):  # noqa
        return ast

    def EXP(self, ast):  # noqa
        return ast

    def LOG(self, ast):  # noqa
        return ast

    def LN(self, ast):  # noqa
        return ast

    def SQRT(self, ast):  # noqa
        return ast

    def SUBJECT_TO(self, ast):  # noqa
        return ast

    def FROM(self, ast):  # noqa
        return ast

    def PI(self, ast):  # noqa
        return ast

    def WITH(self, ast):  # noqa
        return ast

    def INITIAL(self, ast):  # noqa
        return ast

    def AND(self, ast):  # noqa
        return ast

    def OR(self, ast):  # noqa
        return ast

    def DELTA(self, ast):  # noqa
        return ast

    def NABLA(self, ast):  # noqa
        return ast

    def PRIME(self, ast):  # noqa
        return ast

    def UDOT(self, ast):  # noqa
        return ast

    def UDDOT(self, ast):  # noqa
        return ast

    def SOLVE(self, ast):  # noqa
        return ast

    def SUBSET(self, ast):  # noqa
        return ast

    def AS(self, ast):  # noqa
        return ast

    def POUND(self, ast):  # noqa
        return ast

    def FOR(self, ast):  # noqa
        return ast

    def SCALAR(self, ast):  # noqa
        return ast

    def VECTOR(self, ast):  # noqa
        return ast

    def MATRIX(self, ast):  # noqa
        return ast

    def VERTEXSET(self, ast):  # noqa
        return ast

    def EDGESET(self, ast):  # noqa
        return ast

    def FACESET(self, ast):  # noqa
        return ast

    def TETSET(self, ast):  # noqa
        return ast

    def SIMPLICIALSET(self, ast):  # noqa
        return ast

    def EDGEMESH(self, ast):  # noqa
        return ast

    def FACEMESH(self, ast):  # noqa
        return ast

    def CELLMESH(self, ast):  # noqa
        return ast

    def INDEX(self, ast):  # noqa
        return ast

    def VERTICES(self, ast):  # noqa
        return ast

    def EDGES(self, ast):  # noqa
        return ast

    def FACES(self, ast):  # noqa
        return ast

    def TETS(self, ast):  # noqa
        return ast

    def TUPLE(self, ast):  # noqa
        return ast

    def SEQUENCE(self, ast):  # noqa
        return ast

    def SVD(self, ast):  # noqa
        return ast

    def BUILTIN_KEYWORDS(self, ast):  # noqa
        return ast

    def NOT_PREFIX_KEYWORD(self, ast):  # noqa
        return ast

    def PREFIX_KEYWORD(self, ast):  # noqa
        return ast

    def hspace(self, ast):  # noqa
        return ast

    def line(self, ast):  # noqa
        return ast

    def lines(self, ast):  # noqa
        return ast

    def identifier_with_subscript(self, ast):  # noqa
        return ast

    def identifier_with_unicode_subscript(self, ast):  # noqa
        return ast

    def unicode_subscript(self, ast):  # noqa
        return ast

    def unicode_superscript(self, ast):  # noqa
        return ast

    def size_op(self, ast):  # noqa
        return ast

    def keyword_str(self, ast):  # noqa
        return ast

    def multi_str(self, ast):  # noqa
        return ast

    def description(self, ast):  # noqa
        return ast

    def desc_identifier(self, ast):  # noqa
        return ast

    def separator(self, ast):  # noqa
        return ast

    def separator_with_space(self, ast):  # noqa
        return ast

    def blank(self, ast):  # noqa
        return ast

    def params_separator(self, ast):  # noqa
        return ast

    def pi(self, ast):  # noqa
        return ast

    def infinity(self, ast):  # noqa
        return ast

    def e(self, ast):  # noqa
        return ast

    def arithmetic_expression(self, ast):  # noqa
        return ast

    def arithmetic_addition(self, ast):  # noqa
        return ast

    def arithmetic_subtraction(self, ast):  # noqa
        return ast

    def arithmetic_term(self, ast):  # noqa
        return ast

    def arithmetic_multiplication(self, ast):  # noqa
        return ast

    def arithmetic_division(self, ast):  # noqa
        return ast

    def arithmetic_factor(self, ast):  # noqa
        return ast

    def arithmetic_subexpression(self, ast):  # noqa
        return ast

    def matrix_type(self, ast):  # noqa
        return ast

    def matrix_attribute(self, ast):  # noqa
        return ast

    def vector_type(self, ast):  # noqa
        return ast

    def scalar_type(self, ast):  # noqa
        return ast

    def set_type(self, ast):  # noqa
        return ast

    def tuple_type(self, ast):  # noqa
        return ast

    def dimension(self, ast):  # noqa
        return ast

    def named_type(self, ast):  # noqa
        return ast

    def mesh_type(self, ast):  # noqa
        return ast

    def la_type(self, ast):  # noqa
        return ast

    def params_type(self, ast):  # noqa
        return ast

    def function_type(self, ast):  # noqa
        return ast

    def mapping_type(self, ast):  # noqa
        return ast

    def integer(self, ast):  # noqa
        return ast

    def sup_integer(self, ast):  # noqa
        return ast

    def sub_integer(self, ast):  # noqa
        return ast

    def digit(self, ast):  # noqa
        return ast

    def exponent(self, ast):  # noqa
        return ast

    def mantissa(self, ast):  # noqa
        return ast

    def floating_point(self, ast):  # noqa
        return ast

    def double(self, ast):  # noqa
        return ast

    def fraction(self, ast):  # noqa
        return ast

    def number(self, ast):  # noqa
        return ast

    def KEYWORDS(self, ast):  # noqa
        return ast

    def identifier_alone(self, ast):  # noqa
        return ast

    def valid_block(self, ast):  # noqa
        return ast

    def definition(self, ast):  # noqa
        return ast

    def geometry_type(self, ast):  # noqa
        return ast

    def triangle_mesh(self, ast):  # noqa
        return ast

    def point_cloud(self, ast):  # noqa
        return ast

    def operators(self, ast):  # noqa
        return ast

    def Divergence(self, ast):  # noqa
        return ast

    def Gradient(self, ast):  # noqa
        return ast

    def Laplacian(self, ast):  # noqa
        return ast

    def where_condition(self, ast):  # noqa
        return ast

    def import_def(self, ast):  # noqa
        return ast

    def import_(self, ast):  # noqa
        return ast

    def import_var(self, ast):  # noqa
        return ast

    def map_type(self, ast):  # noqa
        return ast

    def module_param(self, ast):  # noqa
        return ast

    def module(self, ast):  # noqa
        return ast

    def solver(self, ast):  # noqa
        return ast

    def target(self, ast):  # noqa
        return ast

    def method(self, ast):  # noqa
        return ast


def main(filename, **kwargs):
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = grammarconfigParser()
    return parser.parse(
        text,
        filename=filename,
        **kwargs
    )


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, grammarconfigParser, name='grammarconfig')
    data = asjson(ast)
    print(json.dumps(data, indent=2))
#!/usr/bin/env python

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.



from typing import Any
from dataclasses import dataclass

from tatsu.objectmodel import Node
from tatsu.semantics import ModelBuilderSemantics


@dataclass(eq=False)
class ModelBase(Node):
    pass


class grammarconfigModelBuilderSemantics(ModelBuilderSemantics):
    def __init__(self, context=None, types=None):
        types = [
            t for t in globals().values()
            if type(t) is type and issubclass(t, ModelBase)
        ] + (types or [])
        super().__init__(context=context, types=types)


@dataclass(eq=False)
class Start(ModelBase):
    vblock: Any = None


@dataclass(eq=False)
class IdentifierSubscript(ModelBase):
    exp: Any = None
    left: Any = None
    p: Any = None
    right: Any = None


@dataclass(eq=False)
class IdentifierAlone(ModelBase):
    value: Any = None


@dataclass(eq=False)
class SizeOp(ModelBase):
    i: Any = None


@dataclass(eq=False)
class Pi(ModelBase):
    pass


@dataclass(eq=False)
class Infinity(ModelBase):
    pass


@dataclass(eq=False)
class E(ModelBase):
    pass


@dataclass(eq=False)
class ArithExpression(ModelBase):
    sign: Any = None
    value: Any = None


@dataclass(eq=False)
class ArithAdd(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithSubtract(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithMultiply(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithDivide(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithFactor(ModelBase):
    id0: Any = None
    num: Any = None
    size: Any = None
    sub: Any = None


@dataclass(eq=False)
class ArithSubexpression(ModelBase):
    value: Any = None


@dataclass(eq=False)
class MatrixType(ModelBase):
    attr: Any = None
    id1: Any = None
    id2: Any = None
    type: Any = None


@dataclass(eq=False)
class VectorType(ModelBase):
    attr: Any = None
    id1: Any = None
    type: Any = None


@dataclass(eq=False)
class ScalarType(ModelBase):
    z: Any = None


@dataclass(eq=False)
class SetType(ModelBase):
    cnt: Any = None
    homogeneous_types: Any = None
    sub_types: Any = None
    type: Any = None
    type1: Any = None
    type2: Any = None


@dataclass(eq=False)
class TupleType(ModelBase):
    sub_types: Any = None


@dataclass(eq=False)
class NamedType(ModelBase):
    e: Any = None
    f: Any = None
    m: Any = None
    s: Any = None
    t: Any = None
    v: Any = None


@dataclass(eq=False)
class FunctionType(ModelBase):
    empty: Any = None
    params: Any = None
    ret: Any = None
    ret_separators: Any = None
    separators: Any = None


@dataclass(eq=False)
class MappingType(ModelBase):
    dst: Any = None
    s: Any = None
    src: Any = None


@dataclass(eq=False)
class Integer(ModelBase):
    value: Any = None


@dataclass(eq=False)
class SupInteger(ModelBase):
    value: Any = None


@dataclass(eq=False)
class SubInteger(ModelBase):
    value: Any = None


@dataclass(eq=False)
class Exponent(ModelBase):
    exp: Any = None
    pow: Any = None


@dataclass(eq=False)
class Mantissa(ModelBase):
    d: Any = None
    f: Any = None


@dataclass(eq=False)
class Float(ModelBase):
    e: Any = None
    m: Any = None


@dataclass(eq=False)
class Double(ModelBase):
    exp: Any = None
    f: Any = None
    i: Any = None


@dataclass(eq=False)
class Fraction(ModelBase):
    value: Any = None


@dataclass(eq=False)
class Geometry(ModelBase):
    g: Any = None
    id: Any = None


@dataclass(eq=False)
class Triangle(ModelBase):
    e: Any = None
    f: Any = None
    v: Any = None


@dataclass(eq=False)
class Point(ModelBase):
    v: Any = None


@dataclass(eq=False)
class Operators(ModelBase):
    d: Any = None
    g: Any = None
    l: Any = None


@dataclass(eq=False)
class WhereCondition(ModelBase):
    desc: Any = None
    id: Any = None
    index: Any = None
    type: Any = None


@dataclass(eq=False)
class ImportDef(ModelBase):
    lhs: Any = None
    rhs: Any = None


@dataclass(eq=False)
class Import(ModelBase):
    names: Any = None
    package: Any = None
    params: Any = None
    separators: Any = None


@dataclass(eq=False)
class ImportVar(ModelBase):
    name: Any = None
    r: Any = None


@dataclass(eq=False)
class Module(ModelBase):
    pass
