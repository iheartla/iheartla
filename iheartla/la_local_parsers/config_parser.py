#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class grammarconfigBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=re.compile('(?!.*)'),
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(grammarconfigBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class grammarconfigParser(Parser):
    def __init__(
        self,
        whitespace=re.compile('(?!.*)'),
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=grammarconfigBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(grammarconfigParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu('Start')
    def _start_(self):  # noqa

        def block0():

            def block1():
                self._separator_with_space_()
            self._closure(block1)

            def block2():
                self._hspace_()
            self._closure(block2)
            self._valid_block_()
            self.add_last_node_to_name('vblock')

            def block4():
                self._separator_with_space_()
            self._closure(block4)
        self._positive_closure(block0)

        def block5():
            self._blank_()
        self._closure(block5)
        self._check_eof()
        self.ast._define(
            [],
            ['vblock']
        )

    @tatsumasu()
    def _IS_(self):  # noqa
        self._pattern('is')

    @tatsumasu()
    def _TRIANGLE_(self):  # noqa
        self._pattern('triangle')

    @tatsumasu()
    def _MESH_(self):  # noqa
        self._pattern('mesh')

    @tatsumasu()
    def _POINT_(self):  # noqa
        self._pattern('point')

    @tatsumasu()
    def _CLOUD_(self):  # noqa
        self._pattern('cloud')

    @tatsumasu()
    def _LU_(self):  # noqa
        self._pattern('LU')

    @tatsumasu()
    def _ODE_(self):  # noqa
        self._pattern('ODE')

    @tatsumasu()
    def _EXPLICIT_(self):  # noqa
        self._pattern('explicit')

    @tatsumasu()
    def _IMPLICIT_(self):  # noqa
        self._pattern('implicit')

    @tatsumasu()
    def _EULER_(self):  # noqa
        self._pattern('euler')

    @tatsumasu()
    def _RK_(self):  # noqa
        self._pattern('RK')

    @tatsumasu()
    def _CONF_KEYWORDS_(self):  # noqa
        with self._choice():
            with self._option():
                self._IS_()
            with self._option():
                self._TRIANGLE_()
            with self._option():
                self._MESH_()
            with self._option():
                self._FROM_()
            with self._option():
                self._SOLVE_()
            with self._option():
                self._WITH_()
            with self._option():
                self._ODE_()
            with self._option():
                self._EXPLICIT_()
            with self._option():
                self._IMPLICIT_()
            with self._option():
                self._EULER_()
            with self._option():
                self._RK_()
            with self._option():
                self._DELTA_()
            with self._option():
                self._NABLA_()
            with self._option():
                self._pattern('âˆ‡â‹…')
            with self._option():
                self._POUND_()
            self._error('no available options')

    @tatsumasu()
    def _TRACE_(self):  # noqa
        self._pattern('trace')

    @tatsumasu()
    def _TR_(self):  # noqa
        self._pattern('tr')

    @tatsumasu()
    def _VEC_(self):  # noqa
        self._pattern('vec')

    @tatsumasu()
    def _DIAG_(self):  # noqa
        self._pattern('diag')

    @tatsumasu()
    def _INV_(self):  # noqa
        self._pattern('inv')

    @tatsumasu()
    def _DET_(self):  # noqa
        self._pattern('det')

    @tatsumasu()
    def _RANK_(self):  # noqa
        self._pattern('rank')

    @tatsumasu()
    def _NULL_(self):  # noqa
        self._pattern('null')

    @tatsumasu()
    def _ORTH_(self):  # noqa
        self._pattern('orth')

    @tatsumasu()
    def _QR_(self):  # noqa
        self._pattern('qr')

    @tatsumasu()
    def _DERIVATIVE_(self):  # noqa
        self._pattern('ð••')

    @tatsumasu()
    def _PARTIAL_(self):  # noqa
        self._pattern('âˆ‚')

    @tatsumasu()
    def _WHERE_(self):  # noqa
        self._pattern('where')

    @tatsumasu()
    def _GIVEN_(self):  # noqa
        self._pattern('given')

    @tatsumasu()
    def _SUM_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('sum')
            with self._option():
                self._pattern('âˆ‘')
            self._error('no available options')

    @tatsumasu()
    def _MIN_(self):  # noqa
        self._pattern('min')

    @tatsumasu()
    def _MAX_(self):  # noqa
        self._pattern('max')

    @tatsumasu()
    def _ARGMIN_(self):  # noqa
        self._pattern('argmin')

    @tatsumasu()
    def _ARGMAX_(self):  # noqa
        self._pattern('argmax')

    @tatsumasu()
    def _INT_(self):  # noqa
        self._pattern('int')

    @tatsumasu()
    def _SPARSE_(self):  # noqa
        self._pattern('sparse')

    @tatsumasu()
    def _IF_(self):  # noqa
        self._pattern('if')

    @tatsumasu()
    def _OTHERWISE_(self):  # noqa
        self._pattern('otherwise')

    @tatsumasu()
    def _IN_(self):  # noqa
        self._pattern('âˆˆ')

    @tatsumasu()
    def _SIN_(self):  # noqa
        self._pattern('sin')

    @tatsumasu()
    def _ASIN_(self):  # noqa
        self._pattern('asin')

    @tatsumasu()
    def _ARCSIN_(self):  # noqa
        self._pattern('arcsin')

    @tatsumasu()
    def _COS_(self):  # noqa
        self._pattern('cos')

    @tatsumasu()
    def _ACOS_(self):  # noqa
        self._pattern('acos')

    @tatsumasu()
    def _ARCCOS_(self):  # noqa
        self._pattern('arccos')

    @tatsumasu()
    def _TAN_(self):  # noqa
        self._pattern('tan')

    @tatsumasu()
    def _ATAN_(self):  # noqa
        self._pattern('atan')

    @tatsumasu()
    def _ARCTAN_(self):  # noqa
        self._pattern('arctan')

    @tatsumasu()
    def _SINH_(self):  # noqa
        self._pattern('sinh')

    @tatsumasu()
    def _ASINH_(self):  # noqa
        self._pattern('asinh')

    @tatsumasu()
    def _ARSINH_(self):  # noqa
        self._pattern('arsinh')

    @tatsumasu()
    def _COSH_(self):  # noqa
        self._pattern('cosh')

    @tatsumasu()
    def _ACOSH_(self):  # noqa
        self._pattern('acosh')

    @tatsumasu()
    def _ARCOSH_(self):  # noqa
        self._pattern('arcosh')

    @tatsumasu()
    def _TANH_(self):  # noqa
        self._pattern('tanh')

    @tatsumasu()
    def _ATANH_(self):  # noqa
        self._pattern('atanh')

    @tatsumasu()
    def _ARTANH_(self):  # noqa
        self._pattern('artanh')

    @tatsumasu()
    def _COT_(self):  # noqa
        self._pattern('cot')

    @tatsumasu()
    def _SEC_(self):  # noqa
        self._pattern('sec')

    @tatsumasu()
    def _CSC_(self):  # noqa
        self._pattern('csc')

    @tatsumasu()
    def _ATAN2_(self):  # noqa
        self._pattern('atan2')

    @tatsumasu()
    def _EXP_(self):  # noqa
        self._pattern('exp')

    @tatsumasu()
    def _LOG_(self):  # noqa
        self._pattern('log')

    @tatsumasu()
    def _LN_(self):  # noqa
        self._pattern('ln')

    @tatsumasu()
    def _SQRT_(self):  # noqa
        self._pattern('sqrt')

    @tatsumasu()
    def _SUBJECT_TO_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('s.t.')
            with self._option():
                self._pattern('subject to')
            self._error('no available options')

    @tatsumasu()
    def _FROM_(self):  # noqa
        self._pattern('from')

    @tatsumasu()
    def _PI_(self):  # noqa
        self._pattern('Ï€')

    @tatsumasu()
    def _WITH_(self):  # noqa
        self._pattern('with')

    @tatsumasu()
    def _INITIAL_(self):  # noqa
        self._pattern('initial')

    @tatsumasu()
    def _AND_(self):  # noqa
        self._pattern('and')

    @tatsumasu()
    def _OR_(self):  # noqa
        self._pattern('or')

    @tatsumasu()
    def _DELTA_(self):  # noqa
        self._pattern('[Î”Î´ð›¿]')

    @tatsumasu()
    def _NABLA_(self):  # noqa
        self._pattern('âˆ‡')

    @tatsumasu()
    def _PRIME_(self):  # noqa
        self._pattern("'")

    @tatsumasu()
    def _UDOT_(self):  # noqa
        self._pattern('[\\u0307]')

    @tatsumasu()
    def _UDDOT_(self):  # noqa
        self._pattern('[\\u0308]')

    @tatsumasu()
    def _SOLVE_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('solve')
            with self._option():
                self._pattern('Solve')
            with self._option():
                self._pattern('SOLVE')
            self._error('no available options')

    @tatsumasu()
    def _SUBSET_(self):  # noqa
        self._pattern('âŠ‚')

    @tatsumasu()
    def _AS_(self):  # noqa
        self._pattern('as')

    @tatsumasu()
    def _POUND_(self):  # noqa
        self._pattern('#')

    @tatsumasu()
    def _hspace_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(' ')
            with self._option():
                self._token('\t')
            self._error('no available options')

    @tatsumasu()
    def _line_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('\n')
            with self._option():
                self._token('\r')
            with self._option():
                self._token('\x0c')
            self._error('no available options')

    @tatsumasu()
    def _lines_(self):  # noqa

        def block0():
            self._line_()
        self._positive_closure(block0)

    @tatsumasu()
    def _identifier_(self):  # noqa
        with self._choice():
            with self._option():
                self._identifier_with_subscript_()
            with self._option():
                self._identifier_alone_()
            self._error('no available options')

    @tatsumasu('IdentifierSubscript')
    def _identifier_with_subscript_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    self._token('_')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._integer_()
                            with self._option():
                                self._token('*')
                            with self._option():
                                self._identifier_alone_()
                            self._error('no available options')
                    self.add_last_node_to_name('right')

                    def block3():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')
                            with self._option():
                                with self._group():

                                    def block5():
                                        self._token(',')
                                    self._closure(block5)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._integer_()
                                            with self._option():
                                                self._identifier_alone_()
                                            self._error('no available options')
                                    self.add_last_node_to_name('right')
                            self._error('no available options')
                    self._closure(block3)
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    self._sub_integer_()
                    self.add_last_node_to_name('right')

                    def block11():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')
                            with self._option():
                                with self._group():

                                    def block13():
                                        self._token(',')
                                    self._closure(block13)
                                    with self._group():
                                        self._sub_integer_()
                                    self.add_last_node_to_name('right')
                            self._error('no available options')
                    self._closure(block11)
            self._error('no available options')
        self.ast._define(
            ['left'],
            ['right']
        )

    @tatsumasu('SizeOp')
    def _size_op_(self):  # noqa
        self._POUND_()
        self._identifier_()
        self.name_last_node('i')
        self.ast._define(
            ['i'],
            []
        )

    @tatsumasu()
    def _keyword_str_(self):  # noqa
        self._pattern('[A-Za-z][A-Za-z0-9]*')

    @tatsumasu('IdentifierAlone')
    def _multi_str_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern('[A-Za-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*([A-Z0-9a-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*')
                    self.name_last_node('value')
                with self._option():
                    self._token('`')
                    self._pattern('[^`]*')
                    self.name_last_node('id')
                    self._token('`')
                self._error('no available options')
        self.ast._define(
            ['id', 'value'],
            []
        )

    @tatsumasu()
    def _description_(self):  # noqa
        self._pattern('[^`;\\n\\r\\f]*')

    @tatsumasu()
    def _desc_identifier_(self):  # noqa
        with self._ifnot():
            self._KEYWORDS_()
        self._token('`')
        self._pattern('[A-Za-z][[A-Za-z0-9]*')
        self._token('`')

    @tatsumasu()
    def _separator_(self):  # noqa
        with self._choice():
            with self._option():
                self._line_()
            with self._option():
                self._token(';')
            self._error('no available options')

    @tatsumasu()
    def _separator_with_space_(self):  # noqa

        def block0():
            self._hspace_()
        self._closure(block0)
        self._separator_()

        def block1():
            self._hspace_()
        self._closure(block1)

    @tatsumasu()
    def _blank_(self):  # noqa

        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._hspace_()
                    with self._option():
                        self._separator_()
                    self._error('no available options')
        self._closure(block0)

    @tatsumasu()
    def _params_separator_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(',')
            with self._option():
                self._token(';')
            with self._option():
                self._token('x')
            with self._option():
                self._token('Ã—')
            self._error('no available options')

    @tatsumasu('Pi')
    def _pi_(self):  # noqa
        self._pattern('Ï€')

    @tatsumasu('E')
    def _e_(self):  # noqa
        self._pattern('e')

    @tatsumasu('ArithExpression')
    @leftrec
    def _arithmetic_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_addition_()
                self.name_last_node('value')
            with self._option():
                self._arithmetic_subtraction_()
                self.name_last_node('value')
            with self._option():
                with self._optional():
                    self._token('-')
                self.name_last_node('sign')
                self._arithmetic_term_()
                self.name_last_node('value')
            self._error('no available options')
        self.ast._define(
            ['sign', 'value'],
            []
        )

    @tatsumasu('ArithAdd')
    @nomemo
    def _arithmetic_addition_(self):  # noqa
        self._arithmetic_expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('+')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._arithmetic_term_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('ArithSubtract')
    @nomemo
    def _arithmetic_subtraction_(self):  # noqa
        self._arithmetic_expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('-')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._arithmetic_term_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    @leftrec
    def _arithmetic_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_multiplication_()
            with self._option():
                self._arithmetic_division_()
            with self._option():
                self._arithmetic_factor_()
            self._error('no available options')

    @tatsumasu('ArithMultiply')
    @nomemo
    def _arithmetic_multiplication_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_term_()
                self.name_last_node('left')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._token('â‹…')
                self.name_last_node('op')

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._arithmetic_factor_()
                self.name_last_node('right')
            with self._option():
                self._arithmetic_term_()
                self.name_last_node('left')

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._arithmetic_factor_()
                self.name_last_node('right')
            self._error('no available options')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('ArithDivide')
    @nomemo
    def _arithmetic_division_(self):  # noqa
        self._arithmetic_term_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/')
                with self._option():
                    self._token('Ã·')
                self._error('no available options')
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._arithmetic_factor_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('ArithFactor')
    def _arithmetic_factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_subexpression_()
                self.name_last_node('sub')
            with self._option():
                self._size_op_()
                self.name_last_node('size')
            with self._option():
                self._identifier_()
                self.name_last_node('id0')
            with self._option():
                self._number_()
                self.name_last_node('num')
            self._error('no available options')
        self.ast._define(
            ['id0', 'num', 'size', 'sub'],
            []
        )

    @tatsumasu('ArithSubexpression')
    def _arithmetic_subexpression_(self):  # noqa
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._arithmetic_expression_()
        self.name_last_node('value')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('MatrixType')
    def _matrix_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('matrix')

                def block0():
                    self._hspace_()
                self._closure(block0)
                self._token('(')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._dimension_()
                self.name_last_node('id1')

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._token(',')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._dimension_()
                self.name_last_node('id2')

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._token(')')

                def block7():

                    def block8():
                        self._hspace_()
                    self._positive_closure(block8)
                    self._matrix_attribute_()
                    self.add_last_node_to_name('attr')
                self._closure(block7)
            with self._option():
                self._pattern('[â„â„¤]')
                self.name_last_node('type')

                def block11():
                    self._hspace_()
                self._closure(block11)
                self._token('^')

                def block12():
                    self._hspace_()
                self._closure(block12)
                self._token('(')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._dimension_()
                self.name_last_node('id1')

                def block15():
                    self._hspace_()
                self._closure(block15)
                self._token('Ã—')

                def block16():
                    self._hspace_()
                self._closure(block16)
                self._dimension_()
                self.name_last_node('id2')

                def block18():
                    self._hspace_()
                self._closure(block18)
                self._token(')')

                def block19():

                    def block20():
                        self._hspace_()
                    self._positive_closure(block20)
                    self._matrix_attribute_()
                    self.add_last_node_to_name('attr')
                self._closure(block19)
            self._error('no available options')
        self.ast._define(
            ['id1', 'id2', 'type'],
            ['attr']
        )

    @tatsumasu()
    def _matrix_attribute_(self):  # noqa
        self._SPARSE_()

    @tatsumasu('VectorType')
    def _vector_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('vector')

                def block0():
                    self._hspace_()
                self._closure(block0)
                self._token('(')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._dimension_()
                self.name_last_node('id1')

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._token(')')
            with self._option():
                self._pattern('[â„â„¤]')
                self.name_last_node('type')

                def block5():
                    self._hspace_()
                self._closure(block5)
                self._token('^')

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._token('(')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._dimension_()
                self.name_last_node('id1')

                def block9():
                    self._hspace_()
                self._closure(block9)
                self._token(')')
            with self._option():
                self._pattern('[â„â„¤]')
                self.name_last_node('type')

                def block11():
                    self._hspace_()
                self._closure(block11)
                self._token('^')

                def block12():
                    self._hspace_()
                self._closure(block12)
                self._dimension_()
                self.name_last_node('id1')
            with self._option():
                self._pattern('[â„â„¤]')
                self.name_last_node('type')
                self._sup_integer_()
                self.name_last_node('id1')
            self._error('no available options')
        self.ast._define(
            ['id1', 'type'],
            []
        )

    @tatsumasu('ScalarType')
    def _scalar_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('scalar')
            with self._option():
                self._pattern('â„')
            with self._option():
                self._pattern('â„¤')
                self.name_last_node('z')
            self._error('no available options')
        self.ast._define(
            ['z'],
            []
        )

    @tatsumasu('SetType')
    def _set_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('{')

                def block0():
                    self._hspace_()
                self._closure(block0)
                self._pattern('[â„â„¤]')
                self.add_last_node_to_name('type')

                def block2():
                    self._hspace_()
                self._closure(block2)

                def block3():
                    self._token('Ã—')

                    def block4():
                        self._hspace_()
                    self._closure(block4)
                    self._pattern('[â„â„¤]')
                    self.add_last_node_to_name('type')

                    def block6():
                        self._hspace_()
                    self._closure(block6)
                self._closure(block3)
                self._token('}')
            with self._option():
                self._token('{')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._pattern('[â„â„¤]')
                self.name_last_node('type1')

                def block9():
                    self._hspace_()
                self._closure(block9)
                self._token('^')

                def block10():
                    self._hspace_()
                self._closure(block10)
                with self._group():
                    self._integer_()
                self.name_last_node('cnt')

                def block12():
                    self._hspace_()
                self._closure(block12)
                self._token('}')
            with self._option():
                self._token('{')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._pattern('[â„â„¤]')
                self.name_last_node('type2')
                with self._optional():
                    self._sup_integer_()
                self.name_last_node('cnt')

                def block16():
                    self._hspace_()
                self._closure(block16)
                self._token('}')
            self._error('no available options')
        self.ast._define(
            ['cnt', 'type1', 'type2'],
            ['type']
        )

    @tatsumasu()
    def _dimension_(self):  # noqa
        self._arithmetic_expression_()

    @tatsumasu()
    def _la_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._function_type_()
            with self._option():
                self._mapping_type_()
            with self._option():
                self._matrix_type_()
            with self._option():
                self._vector_type_()
            with self._option():
                self._set_type_()
            with self._option():
                self._scalar_type_()
            self._error('no available options')

    @tatsumasu()
    def _params_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._matrix_type_()
            with self._option():
                self._vector_type_()
            with self._option():
                self._scalar_type_()
            with self._option():
                self._set_type_()
            self._error('no available options')

    @tatsumasu('FunctionType')
    def _function_type_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._params_type_()
                        self.add_last_node_to_name('params')

                        def block1():

                            def block2():
                                self._hspace_()
                            self._closure(block2)
                            self._params_separator_()
                            self.add_last_node_to_name('separators')

                            def block4():
                                self._hspace_()
                            self._closure(block4)
                            self._params_type_()
                            self.add_last_node_to_name('params')
                        self._closure(block1)
                with self._option():
                    self._token('âˆ…')
                    self.name_last_node('empty')
                with self._option():
                    self._token('{')

                    def block7():
                        self._hspace_()
                    self._closure(block7)
                    self._token('}')
                self._error('no available options')

        def block9():
            self._hspace_()
        self._closure(block9)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('â†’')
                with self._option():
                    self._token('->')
                self._error('no available options')

        def block11():
            self._hspace_()
        self._closure(block11)
        self._params_type_()
        self.add_last_node_to_name('ret')

        def block13():

            def block14():
                self._hspace_()
            self._closure(block14)
            self._params_separator_()
            self.add_last_node_to_name('ret_separators')

            def block16():
                self._hspace_()
            self._closure(block16)
            self._params_type_()
            self.add_last_node_to_name('ret')
        self._closure(block13)
        self.ast._define(
            ['empty'],
            ['params', 'ret', 'ret_separators', 'separators']
        )

    @tatsumasu('MappingType')
    def _mapping_type_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            with self._group():
                                self._identifier_()
                                self.add_last_node_to_name('params')

                                def block1():

                                    def block2():
                                        self._hspace_()
                                    self._closure(block2)
                                    self._params_separator_()
                                    self.add_last_node_to_name('separators')

                                    def block4():
                                        self._hspace_()
                                    self._closure(block4)
                                    self._identifier_()
                                    self.add_last_node_to_name('params')
                                self._closure(block1)
                        with self._option():
                            self._token('âˆ…')
                            self.name_last_node('empty')
                        with self._option():
                            self._token('{')

                            def block7():
                                self._hspace_()
                            self._closure(block7)
                            self._token('}')
                        self._error('no available options')

                def block9():
                    self._hspace_()
                self._closure(block9)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('â†’')
                        with self._option():
                            self._token('->')
                        self._error('no available options')

                def block11():
                    self._hspace_()
                self._closure(block11)
                self._params_type_()
                self.add_last_node_to_name('ret_type')

                def block13():

                    def block14():
                        self._hspace_()
                    self._closure(block14)
                    self._params_separator_()
                    self.add_last_node_to_name('ret_separators')

                    def block16():
                        self._hspace_()
                    self._closure(block16)
                    self._params_type_()
                    self.add_last_node_to_name('ret_type')
                self._closure(block13)
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            with self._group():
                                self._identifier_()
                                self.add_last_node_to_name('params')

                                def block19():

                                    def block20():
                                        self._hspace_()
                                    self._closure(block20)
                                    self._params_separator_()
                                    self.add_last_node_to_name('separators')

                                    def block22():
                                        self._hspace_()
                                    self._closure(block22)
                                    self._identifier_()
                                    self.add_last_node_to_name('params')
                                self._closure(block19)
                        with self._option():
                            self._token('âˆ…')
                            self.name_last_node('empty')
                        with self._option():
                            self._token('{')

                            def block25():
                                self._hspace_()
                            self._closure(block25)
                            self._token('}')
                        self._error('no available options')

                def block27():
                    self._hspace_()
                self._closure(block27)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('â†’')
                        with self._option():
                            self._token('->')
                        self._error('no available options')

                def block29():
                    self._hspace_()
                self._closure(block29)
                self._identifier_()
                self.add_last_node_to_name('ret')

                def block31():

                    def block32():
                        self._hspace_()
                    self._closure(block32)
                    self._params_separator_()
                    self.add_last_node_to_name('ret_separators')

                    def block34():
                        self._hspace_()
                    self._closure(block34)
                    self._identifier_()
                    self.add_last_node_to_name('ret')
                self._closure(block31)
            self._error('no available options')
        self.ast._define(
            ['empty'],
            ['params', 'ret', 'ret_separators', 'ret_type', 'separators']
        )

    @tatsumasu('Integer')
    def _integer_(self):  # noqa

        def block1():
            self._digit_()
        self._positive_closure(block1)
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('SupInteger')
    def _sup_integer_(self):  # noqa

        def block1():
            self._pattern('[\\u2070\\u00B9\\u00B2\\u00B3\\u2074-\\u2079]')
        self._positive_closure(block1)
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('SubInteger')
    def _sub_integer_(self):  # noqa

        def block1():
            self._pattern('[\\u2080-\\u2089]')
        self._positive_closure(block1)
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu()
    def _digit_(self):  # noqa
        self._pattern('\\d')

    @tatsumasu('Exponent')
    def _exponent_(self):  # noqa
        self._pattern('[E][+-]?')
        self.name_last_node('exp')

        def block2():
            self._digit_()
        self._positive_closure(block2)
        self.name_last_node('pow')
        self.ast._define(
            ['exp', 'pow'],
            []
        )

    @tatsumasu('Mantissa')
    def _mantissa_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():

                    def block1():
                        self._digit_()
                    self._closure(block1)
                    self.name_last_node('d')
                    self._token('.')

                    def block3():
                        self._digit_()
                    self._positive_closure(block3)
                    self.name_last_node('f')
            with self._option():
                with self._group():

                    def block5():
                        self._digit_()
                    self._positive_closure(block5)
                    self.name_last_node('d')
                    self._token('.')
            self._error('no available options')
        self.ast._define(
            ['d', 'f'],
            []
        )

    @tatsumasu('Float')
    def _floating_point_(self):  # noqa
        self._mantissa_()
        self.name_last_node('m')
        with self._optional():
            self._exponent_()
        self.name_last_node('e')
        self.ast._define(
            ['e', 'm'],
            []
        )

    @tatsumasu('Double')
    def _double_(self):  # noqa
        with self._choice():
            with self._option():
                self._integer_()
                self.name_last_node('i')
                self._exponent_()
                self.name_last_node('exp')
            with self._option():
                self._floating_point_()
                self.name_last_node('f')
            self._error('no available options')
        self.ast._define(
            ['exp', 'f', 'i'],
            []
        )

    @tatsumasu('Fraction')
    def _fraction_(self):  # noqa
        self._pattern('[\\u00BC-\\u00BE\\u2150-\\u215E]')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu()
    def _number_(self):  # noqa
        with self._choice():
            with self._option():
                self._double_()
            with self._option():
                self._fraction_()
            with self._option():
                self._integer_()
            self._error('no available options')

    @tatsumasu()
    def _KEYWORDS_(self):  # noqa
        self._CONF_KEYWORDS_()

    @tatsumasu('IdentifierAlone')
    def _identifier_alone_(self):  # noqa
        with self._ifnot():
            self._KEYWORDS_()
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._pattern('[A-Za-z\\p{Ll}\\p{Lu}\\p{Lo}](?![\\u0308\\u0307])\\p{M}*')
                            with self._option():
                                self._pattern('[A-Za-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?=[\\u0308\\u0307])')
                            self._error('no available options')
                    self.name_last_node('value')
                with self._option():
                    self._token('`')
                    self._pattern('[^`]*')
                    self.name_last_node('id')
                    self._token('`')
                self._error('no available options')
        self.ast._define(
            ['id', 'value'],
            []
        )

    @tatsumasu()
    def _valid_block_(self):  # noqa
        with self._choice():
            with self._option():
                self._definition_()
            with self._option():
                self._mapping_()
            with self._option():
                self._import_def_()
            with self._option():
                self._where_condition_()
            with self._option():
                self._solver_()
            self._error('no available options')

    @tatsumasu('Geometry')
    def _definition_(self):  # noqa
        self._identifier_()
        self.name_last_node('id')

        def block1():
            self._hspace_()
        self._positive_closure(block1)
        self._IS_()

        def block2():
            self._hspace_()
        self._positive_closure(block2)
        self._geometry_type_()
        self.name_last_node('g')
        self.ast._define(
            ['g', 'id'],
            []
        )

    @tatsumasu()
    def _geometry_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._triangle_mesh_()
            with self._option():
                self._point_cloud_()
            self._error('no available options')

    @tatsumasu('Triangle')
    def _triangle_mesh_(self):  # noqa
        self._TRIANGLE_()

        def block0():
            self._hspace_()
        self._positive_closure(block0)
        self._MESH_()

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('(')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._identifier_()
        self.name_last_node('v')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._token(',')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._identifier_()
        self.name_last_node('e')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(',')

        def block8():
            self._hspace_()
        self._closure(block8)
        self._identifier_()
        self.name_last_node('f')

        def block10():
            self._hspace_()
        self._closure(block10)
        self._token(')')
        self.ast._define(
            ['e', 'f', 'v'],
            []
        )

    @tatsumasu('Point')
    def _point_cloud_(self):  # noqa
        self._POINT_()

        def block0():
            self._hspace_()
        self._positive_closure(block0)
        self._CLOUD_()

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('(')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._identifier_()
        self.name_last_node('v')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._token(')')
        self.ast._define(
            ['v'],
            []
        )

    @tatsumasu('Operators')
    def _operators_(self):  # noqa
        with self._choice():
            with self._option():
                self._Divergence_()
                self.name_last_node('d')
            with self._option():
                self._Gradient_()
                self.name_last_node('g')
            with self._option():
                self._Laplacian_()
                self.name_last_node('l')
            self._error('no available options')
        self.ast._define(
            ['d', 'g', 'l'],
            []
        )

    @tatsumasu()
    def _Divergence_(self):  # noqa
        self._pattern('âˆ‡â‹…')

    @tatsumasu()
    def _Gradient_(self):  # noqa
        self._NABLA_()

    @tatsumasu()
    def _Laplacian_(self):  # noqa
        self._DELTA_()

    @tatsumasu('WhereCondition')
    def _where_condition_(self):  # noqa
        self._identifier_()
        self.add_last_node_to_name('id')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._identifier_()
            self.add_last_node_to_name('id')
        self._closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                with self._option():
                    self._IN_()
                self._error('no available options')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._la_type_()
        self.name_last_node('type')

        def block9():

            def block10():
                self._hspace_()
            self._closure(block10)
            self._token('index')
            self.name_last_node('index')
        self._closure(block9)

        def block12():

            def block13():
                self._hspace_()
            self._closure(block13)
            self._token(':')

            def block14():
                self._hspace_()
            self._closure(block14)
            self._description_()
            self.name_last_node('desc')
        self._closure(block12)
        self.ast._define(
            ['desc', 'index', 'type'],
            ['id']
        )

    @tatsumasu('Mapping')
    def _mapping_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._identifier_()
                with self._option():
                    self._operators_()
                self._error('no available options')
        self.name_last_node('lhs')

        def block2():
            self._hspace_()
        self._closure(block2)
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                with self._option():
                    self._IN_()
                self._error('no available options')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._mapping_rhs_()
        self.name_last_node('rhs')
        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @tatsumasu('Rhs')
    def _mapping_rhs_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._map_type_()
                        self.add_last_node_to_name('params')

                        def block1():

                            def block2():
                                self._hspace_()
                            self._closure(block2)
                            self._params_separator_()
                            self.add_last_node_to_name('separators')

                            def block4():
                                self._hspace_()
                            self._closure(block4)
                            self._map_type_()
                            self.add_last_node_to_name('params')
                        self._closure(block1)
                with self._option():
                    self._token('âˆ…')
                    self.name_last_node('empty')
                with self._option():
                    self._token('{')

                    def block7():
                        self._hspace_()
                    self._closure(block7)
                    self._token('}')
                self._error('no available options')

        def block9():
            self._hspace_()
        self._closure(block9)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('â†’')
                with self._option():
                    self._token('->')
                self._error('no available options')

        def block11():
            self._hspace_()
        self._closure(block11)
        self._map_type_()
        self.add_last_node_to_name('ret')

        def block13():

            def block14():
                self._hspace_()
            self._closure(block14)
            self._params_separator_()
            self.add_last_node_to_name('ret_separators')

            def block16():
                self._hspace_()
            self._closure(block16)
            self._map_type_()
            self.add_last_node_to_name('ret')
        self._closure(block13)
        self.ast._define(
            ['empty'],
            ['params', 'ret', 'ret_separators', 'separators']
        )

    @tatsumasu('ImportDef')
    def _import_def_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._identifier_()
                with self._option():
                    self._operators_()
                self._error('no available options')
        self.name_last_node('lhs')

        def block2():
            self._hspace_()
        self._closure(block2)
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                with self._option():
                    self._IN_()
                self._error('no available options')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._import_()
        self.name_last_node('rhs')
        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @tatsumasu('Import')
    def _import_(self):  # noqa
        self._import_var_()
        self.add_last_node_to_name('names')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._import_var_()
            self.add_last_node_to_name('names')
        self._closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        self._FROM_()

        def block6():
            self._hspace_()
        self._positive_closure(block6)
        self._module_()
        self.name_last_node('package')

        def block8():
            self._hspace_()
        self._closure(block8)

        def block9():
            self._token('(')

            def block10():

                def block11():
                    self._hspace_()
                self._closure(block11)
                self._module_param_()
                self.add_last_node_to_name('params')

                def block13():

                    def block14():
                        self._hspace_()
                    self._closure(block14)
                    self._params_separator_()
                    self.add_last_node_to_name('separators')

                    def block16():
                        self._hspace_()
                    self._closure(block16)
                    self._module_param_()
                    self.add_last_node_to_name('params')
                self._closure(block13)
            self._closure(block10)

            def block18():
                self._hspace_()
            self._closure(block18)
            self._token(')')
        self._closure(block9)

        def block19():
            self._hspace_()
        self._closure(block19)
        self.ast._define(
            ['package'],
            ['names', 'params', 'separators']
        )

    @tatsumasu('ImportVar')
    def _import_var_(self):  # noqa
        self._identifier_()
        self.name_last_node('name')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._AS_()

            def block3():
                self._hspace_()
            self._closure(block3)
            self._identifier_()
            self.name_last_node('r')
        self._closure(block1)
        self.ast._define(
            ['name', 'r'],
            []
        )

    @tatsumasu()
    def _map_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._params_type_()
            with self._option():
                self._size_op_()
            with self._option():
                self._identifier_()
            self._error('no available options')

    @tatsumasu()
    def _module_param_(self):  # noqa
        with self._choice():
            with self._option():
                self._size_op_()
            with self._option():
                self._identifier_()
            self._error('no available options')

    @tatsumasu('Module')
    def _module_(self):  # noqa
        with self._ifnot():
            self._KEYWORDS_()
        self._pattern('[A-Za-z0-9_]*')

    @tatsumasu()
    def _solver_(self):  # noqa
        self._SOLVE_()

        def block0():
            self._hspace_()
        self._closure(block0)
        self._target_()

        def block1():
            self._hspace_()
        self._closure(block1)
        self._WITH_()

        def block2():
            self._hspace_()
        self._closure(block2)
        self._method_()

    @tatsumasu()
    def _target_(self):  # noqa
        with self._choice():
            with self._option():
                self._ODE_()
            with self._option():
                self._module_()
            self._error('no available options')

    @tatsumasu()
    def _method_(self):  # noqa
        with self._choice():
            with self._option():
                self._LU_()
            with self._option():
                self._EXPLICIT_()

                def block0():
                    self._hspace_()
                self._positive_closure(block0)
                self._EULER_()
            with self._option():
                self._IMPLICIT_()

                def block1():
                    self._hspace_()
                self._positive_closure(block1)
                self._EULER_()
            with self._option():
                self._RK_()
            self._error('no available options')


class grammarconfigSemantics(object):
    def start(self, ast):  # noqa
        return ast

    def IS(self, ast):  # noqa
        return ast

    def TRIANGLE(self, ast):  # noqa
        return ast

    def MESH(self, ast):  # noqa
        return ast

    def POINT(self, ast):  # noqa
        return ast

    def CLOUD(self, ast):  # noqa
        return ast

    def LU(self, ast):  # noqa
        return ast

    def ODE(self, ast):  # noqa
        return ast

    def EXPLICIT(self, ast):  # noqa
        return ast

    def IMPLICIT(self, ast):  # noqa
        return ast

    def EULER(self, ast):  # noqa
        return ast

    def RK(self, ast):  # noqa
        return ast

    def CONF_KEYWORDS(self, ast):  # noqa
        return ast

    def TRACE(self, ast):  # noqa
        return ast

    def TR(self, ast):  # noqa
        return ast

    def VEC(self, ast):  # noqa
        return ast

    def DIAG(self, ast):  # noqa
        return ast

    def INV(self, ast):  # noqa
        return ast

    def DET(self, ast):  # noqa
        return ast

    def RANK(self, ast):  # noqa
        return ast

    def NULL(self, ast):  # noqa
        return ast

    def ORTH(self, ast):  # noqa
        return ast

    def QR(self, ast):  # noqa
        return ast

    def DERIVATIVE(self, ast):  # noqa
        return ast

    def PARTIAL(self, ast):  # noqa
        return ast

    def WHERE(self, ast):  # noqa
        return ast

    def GIVEN(self, ast):  # noqa
        return ast

    def SUM(self, ast):  # noqa
        return ast

    def MIN(self, ast):  # noqa
        return ast

    def MAX(self, ast):  # noqa
        return ast

    def ARGMIN(self, ast):  # noqa
        return ast

    def ARGMAX(self, ast):  # noqa
        return ast

    def INT(self, ast):  # noqa
        return ast

    def SPARSE(self, ast):  # noqa
        return ast

    def IF(self, ast):  # noqa
        return ast

    def OTHERWISE(self, ast):  # noqa
        return ast

    def IN(self, ast):  # noqa
        return ast

    def SIN(self, ast):  # noqa
        return ast

    def ASIN(self, ast):  # noqa
        return ast

    def ARCSIN(self, ast):  # noqa
        return ast

    def COS(self, ast):  # noqa
        return ast

    def ACOS(self, ast):  # noqa
        return ast

    def ARCCOS(self, ast):  # noqa
        return ast

    def TAN(self, ast):  # noqa
        return ast

    def ATAN(self, ast):  # noqa
        return ast

    def ARCTAN(self, ast):  # noqa
        return ast

    def SINH(self, ast):  # noqa
        return ast

    def ASINH(self, ast):  # noqa
        return ast

    def ARSINH(self, ast):  # noqa
        return ast

    def COSH(self, ast):  # noqa
        return ast

    def ACOSH(self, ast):  # noqa
        return ast

    def ARCOSH(self, ast):  # noqa
        return ast

    def TANH(self, ast):  # noqa
        return ast

    def ATANH(self, ast):  # noqa
        return ast

    def ARTANH(self, ast):  # noqa
        return ast

    def COT(self, ast):  # noqa
        return ast

    def SEC(self, ast):  # noqa
        return ast

    def CSC(self, ast):  # noqa
        return ast

    def ATAN2(self, ast):  # noqa
        return ast

    def EXP(self, ast):  # noqa
        return ast

    def LOG(self, ast):  # noqa
        return ast

    def LN(self, ast):  # noqa
        return ast

    def SQRT(self, ast):  # noqa
        return ast

    def SUBJECT_TO(self, ast):  # noqa
        return ast

    def FROM(self, ast):  # noqa
        return ast

    def PI(self, ast):  # noqa
        return ast

    def WITH(self, ast):  # noqa
        return ast

    def INITIAL(self, ast):  # noqa
        return ast

    def AND(self, ast):  # noqa
        return ast

    def OR(self, ast):  # noqa
        return ast

    def DELTA(self, ast):  # noqa
        return ast

    def NABLA(self, ast):  # noqa
        return ast

    def PRIME(self, ast):  # noqa
        return ast

    def UDOT(self, ast):  # noqa
        return ast

    def UDDOT(self, ast):  # noqa
        return ast

    def SOLVE(self, ast):  # noqa
        return ast

    def SUBSET(self, ast):  # noqa
        return ast

    def AS(self, ast):  # noqa
        return ast

    def POUND(self, ast):  # noqa
        return ast

    def hspace(self, ast):  # noqa
        return ast

    def line(self, ast):  # noqa
        return ast

    def lines(self, ast):  # noqa
        return ast

    def identifier(self, ast):  # noqa
        return ast

    def identifier_with_subscript(self, ast):  # noqa
        return ast

    def size_op(self, ast):  # noqa
        return ast

    def keyword_str(self, ast):  # noqa
        return ast

    def multi_str(self, ast):  # noqa
        return ast

    def description(self, ast):  # noqa
        return ast

    def desc_identifier(self, ast):  # noqa
        return ast

    def separator(self, ast):  # noqa
        return ast

    def separator_with_space(self, ast):  # noqa
        return ast

    def blank(self, ast):  # noqa
        return ast

    def params_separator(self, ast):  # noqa
        return ast

    def pi(self, ast):  # noqa
        return ast

    def e(self, ast):  # noqa
        return ast

    def arithmetic_expression(self, ast):  # noqa
        return ast

    def arithmetic_addition(self, ast):  # noqa
        return ast

    def arithmetic_subtraction(self, ast):  # noqa
        return ast

    def arithmetic_term(self, ast):  # noqa
        return ast

    def arithmetic_multiplication(self, ast):  # noqa
        return ast

    def arithmetic_division(self, ast):  # noqa
        return ast

    def arithmetic_factor(self, ast):  # noqa
        return ast

    def arithmetic_subexpression(self, ast):  # noqa
        return ast

    def matrix_type(self, ast):  # noqa
        return ast

    def matrix_attribute(self, ast):  # noqa
        return ast

    def vector_type(self, ast):  # noqa
        return ast

    def scalar_type(self, ast):  # noqa
        return ast

    def set_type(self, ast):  # noqa
        return ast

    def dimension(self, ast):  # noqa
        return ast

    def la_type(self, ast):  # noqa
        return ast

    def params_type(self, ast):  # noqa
        return ast

    def function_type(self, ast):  # noqa
        return ast

    def mapping_type(self, ast):  # noqa
        return ast

    def integer(self, ast):  # noqa
        return ast

    def sup_integer(self, ast):  # noqa
        return ast

    def sub_integer(self, ast):  # noqa
        return ast

    def digit(self, ast):  # noqa
        return ast

    def exponent(self, ast):  # noqa
        return ast

    def mantissa(self, ast):  # noqa
        return ast

    def floating_point(self, ast):  # noqa
        return ast

    def double(self, ast):  # noqa
        return ast

    def fraction(self, ast):  # noqa
        return ast

    def number(self, ast):  # noqa
        return ast

    def KEYWORDS(self, ast):  # noqa
        return ast

    def identifier_alone(self, ast):  # noqa
        return ast

    def valid_block(self, ast):  # noqa
        return ast

    def definition(self, ast):  # noqa
        return ast

    def geometry_type(self, ast):  # noqa
        return ast

    def triangle_mesh(self, ast):  # noqa
        return ast

    def point_cloud(self, ast):  # noqa
        return ast

    def operators(self, ast):  # noqa
        return ast

    def Divergence(self, ast):  # noqa
        return ast

    def Gradient(self, ast):  # noqa
        return ast

    def Laplacian(self, ast):  # noqa
        return ast

    def where_condition(self, ast):  # noqa
        return ast

    def mapping(self, ast):  # noqa
        return ast

    def mapping_rhs(self, ast):  # noqa
        return ast

    def import_def(self, ast):  # noqa
        return ast

    def import_(self, ast):  # noqa
        return ast

    def import_var(self, ast):  # noqa
        return ast

    def map_type(self, ast):  # noqa
        return ast

    def module_param(self, ast):  # noqa
        return ast

    def module(self, ast):  # noqa
        return ast

    def solver(self, ast):  # noqa
        return ast

    def target(self, ast):  # noqa
        return ast

    def method(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'start'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = grammarconfigParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, grammarconfigParser, name='grammarconfig')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.



from tatsu.objectmodel import Node
from tatsu.semantics import ModelBuilderSemantics


class ModelBase(Node):
    pass


class grammarconfigModelBuilderSemantics(ModelBuilderSemantics):
    def __init__(self, context=None, types=None):
        types = [
            t for t in globals().values()
            if type(t) is type and issubclass(t, ModelBase)
        ] + (types or [])
        super(grammarconfigModelBuilderSemantics, self).__init__(context=context, types=types)


class Start(ModelBase):
    vblock = None


class IdentifierSubscript(ModelBase):
    left = None
    right = None


class SizeOp(ModelBase):
    i = None


class IdentifierAlone(ModelBase):
    id = None
    value = None


class Pi(ModelBase):
    pass


class E(ModelBase):
    pass


class ArithExpression(ModelBase):
    sign = None
    value = None


class ArithAdd(ModelBase):
    left = None
    op = None
    right = None


class ArithSubtract(ModelBase):
    left = None
    op = None
    right = None


class ArithMultiply(ModelBase):
    left = None
    op = None
    right = None


class ArithDivide(ModelBase):
    left = None
    op = None
    right = None


class ArithFactor(ModelBase):
    id0 = None
    num = None
    size = None
    sub = None


class ArithSubexpression(ModelBase):
    value = None


class MatrixType(ModelBase):
    attr = None
    id1 = None
    id2 = None
    type = None


class VectorType(ModelBase):
    id1 = None
    type = None


class ScalarType(ModelBase):
    z = None


class SetType(ModelBase):
    cnt = None
    type = None
    type1 = None
    type2 = None


class FunctionType(ModelBase):
    empty = None
    params = None
    ret = None
    ret_separators = None
    separators = None


class MappingType(ModelBase):
    empty = None
    params = None
    ret = None
    ret_separators = None
    ret_type = None
    separators = None


class Integer(ModelBase):
    value = None


class SupInteger(ModelBase):
    value = None


class SubInteger(ModelBase):
    value = None


class Exponent(ModelBase):
    exp = None
    pow = None


class Mantissa(ModelBase):
    d = None
    f = None


class Float(ModelBase):
    e = None
    m = None


class Double(ModelBase):
    exp = None
    f = None
    i = None


class Fraction(ModelBase):
    value = None


class Geometry(ModelBase):
    g = None
    id = None


class Triangle(ModelBase):
    e = None
    f = None
    v = None


class Point(ModelBase):
    v = None


class Operators(ModelBase):
    d = None
    g = None
    l = None


class WhereCondition(ModelBase):
    desc = None
    id = None
    index = None
    type = None


class Mapping(ModelBase):
    lhs = None
    rhs = None


class Rhs(ModelBase):
    empty = None
    params = None
    ret = None
    ret_separators = None
    separators = None


class ImportDef(ModelBase):
    lhs = None
    rhs = None


class Import(ModelBase):
    names = None
    package = None
    params = None
    separators = None


class ImportVar(ModelBase):
    name = None
    r = None


class Module(ModelBase):
    pass
