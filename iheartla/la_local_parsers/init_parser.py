#!/usr/bin/env python

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.

from __future__ import annotations

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.parsing import leftrec, nomemo, isname # noqa
from tatsu.infos import ParserConfig
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class grammarinitBuffer(Buffer):
    def __init__(self, text, /, config: ParserConfig = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=re.compile('(?!.*)'),
            nameguard=None,
            comments_re=None,
            eol_comments_re=None,
            ignorecase=False,
            namechars='',
            parseinfo=False,
        )
        config = config.replace(**settings)
        super().__init__(text, config=config)


class grammarinitParser(Parser):
    def __init__(self, /, config: ParserConfig = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=re.compile('(?!.*)'),
            nameguard=None,
            comments_re=None,
            eol_comments_re=None,
            ignorecase=False,
            namechars='',
            parseinfo=False,
            keywords=KEYWORDS,
            start='start',
        )
        config = config.replace(**settings)
        super().__init__(config=config)

    @tatsumasu('Start')
    @nomemo
    def _start_(self):  # noqa

        def block0():

            def block1():
                self._separator_with_space_()
            self._closure(block1)

            def block2():
                self._hspace_()
            self._closure(block2)
            self._valid_block_()
            self.add_last_node_to_name('vblock')

            def block4():
                self._separator_with_space_()
            self._closure(block4)

            self._define(
                [],
                ['vblock']
            )
        self._positive_closure(block0)

        def block5():
            self._blank_()
        self._closure(block5)
        self._check_eof()

        self._define(
            [],
            ['vblock']
        )

    @tatsumasu()
    def _TRACE_(self):  # noqa
        self._pattern('trace')

    @tatsumasu()
    def _TR_(self):  # noqa
        self._pattern('tr')

    @tatsumasu()
    def _VEC_(self):  # noqa
        self._pattern('vec')

    @tatsumasu()
    def _INVERSEVEC_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('inversevec')
            with self._option():
                self._pattern('vec‚Åª¬π')
            self._error(
                'expecting one of: '
                'inversevec vec‚Åª¬π'
            )

    @tatsumasu()
    def _DIAG_(self):  # noqa
        self._pattern('diag')

    @tatsumasu()
    def _INV_(self):  # noqa
        self._pattern('inv')

    @tatsumasu()
    def _DET_(self):  # noqa
        self._pattern('det')

    @tatsumasu()
    def _RANK_(self):  # noqa
        self._pattern('rank')

    @tatsumasu()
    def _NULL_(self):  # noqa
        self._pattern('null')

    @tatsumasu()
    def _ORTH_(self):  # noqa
        self._pattern('orth')

    @tatsumasu()
    def _QR_(self):  # noqa
        self._pattern('qr')

    @tatsumasu()
    def _DERIVATIVE_(self):  # noqa
        self._pattern('ùïï')

    @tatsumasu()
    def _PARTIAL_(self):  # noqa
        self._pattern('‚àÇ')

    @tatsumasu()
    def _WHERE_(self):  # noqa
        self._pattern('where')

    @tatsumasu()
    def _GIVEN_(self):  # noqa
        self._pattern('given')

    @tatsumasu()
    def _SUM_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('sum')
            with self._option():
                self._pattern('‚àë')
            self._error(
                'expecting one of: '
                'sum ‚àë'
            )

    @tatsumasu()
    def _MIN_(self):  # noqa
        self._pattern('min')

    @tatsumasu()
    def _MAX_(self):  # noqa
        self._pattern('max')

    @tatsumasu()
    def _ARGMIN_(self):  # noqa
        self._pattern('argmin')

    @tatsumasu()
    def _ARGMAX_(self):  # noqa
        self._pattern('argmax')

    @tatsumasu()
    def _INT_(self):  # noqa
        self._pattern('int')

    @tatsumasu()
    def _SPARSE_(self):  # noqa
        self._pattern('sparse')

    @tatsumasu()
    def _IF_(self):  # noqa
        self._pattern('if')

    @tatsumasu()
    def _OTHERWISE_(self):  # noqa
        self._pattern('otherwise')

    @tatsumasu()
    def _IN_(self):  # noqa
        self._pattern('‚àà')

    @tatsumasu()
    def _SIN_(self):  # noqa
        self._pattern('sin')

    @tatsumasu()
    def _ASIN_(self):  # noqa
        self._pattern('asin')

    @tatsumasu()
    def _ARCSIN_(self):  # noqa
        self._pattern('arcsin')

    @tatsumasu()
    def _COS_(self):  # noqa
        self._pattern('cos')

    @tatsumasu()
    def _ACOS_(self):  # noqa
        self._pattern('acos')

    @tatsumasu()
    def _ARCCOS_(self):  # noqa
        self._pattern('arccos')

    @tatsumasu()
    def _TAN_(self):  # noqa
        self._pattern('tan')

    @tatsumasu()
    def _ATAN_(self):  # noqa
        self._pattern('atan')

    @tatsumasu()
    def _ARCTAN_(self):  # noqa
        self._pattern('arctan')

    @tatsumasu()
    def _SINH_(self):  # noqa
        self._pattern('sinh')

    @tatsumasu()
    def _ASINH_(self):  # noqa
        self._pattern('asinh')

    @tatsumasu()
    def _ARSINH_(self):  # noqa
        self._pattern('arsinh')

    @tatsumasu()
    def _COSH_(self):  # noqa
        self._pattern('cosh')

    @tatsumasu()
    def _ACOSH_(self):  # noqa
        self._pattern('acosh')

    @tatsumasu()
    def _ARCOSH_(self):  # noqa
        self._pattern('arcosh')

    @tatsumasu()
    def _TANH_(self):  # noqa
        self._pattern('tanh')

    @tatsumasu()
    def _ATANH_(self):  # noqa
        self._pattern('atanh')

    @tatsumasu()
    def _ARTANH_(self):  # noqa
        self._pattern('artanh')

    @tatsumasu()
    def _COT_(self):  # noqa
        self._pattern('cot')

    @tatsumasu()
    def _SEC_(self):  # noqa
        self._pattern('sec')

    @tatsumasu()
    def _CSC_(self):  # noqa
        self._pattern('csc')

    @tatsumasu()
    def _ATAN2_(self):  # noqa
        self._pattern('atan2')

    @tatsumasu()
    def _EXP_(self):  # noqa
        self._pattern('exp')

    @tatsumasu()
    def _LOG_(self):  # noqa
        self._pattern('log')

    @tatsumasu()
    def _LN_(self):  # noqa
        self._pattern('ln')

    @tatsumasu()
    def _SQRT_(self):  # noqa
        self._pattern('sqrt')

    @tatsumasu()
    def _SUBJECT_TO_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('s.t.')
            with self._option():
                self._pattern('subject to')
            self._error(
                'expecting one of: '
                's.t. subject to'
            )

    @tatsumasu()
    def _FROM_(self):  # noqa
        self._pattern('from')

    @tatsumasu()
    def _PI_(self):  # noqa
        self._pattern('œÄ')

    @tatsumasu()
    def _WITH_(self):  # noqa
        self._pattern('with')

    @tatsumasu()
    def _INITIAL_(self):  # noqa
        self._pattern('initial')

    @tatsumasu()
    def _AND_(self):  # noqa
        self._pattern('and')

    @tatsumasu()
    def _OR_(self):  # noqa
        self._pattern('or')

    @tatsumasu()
    def _DELTA_(self):  # noqa
        self._pattern('[Œî]')

    @tatsumasu()
    def _NABLA_(self):  # noqa
        self._pattern('‚àá')

    @tatsumasu()
    def _PRIME_(self):  # noqa
        self._pattern("'")

    @tatsumasu()
    def _UDOT_(self):  # noqa
        self._pattern('[\\u0307]')

    @tatsumasu()
    def _UDDOT_(self):  # noqa
        self._pattern('[\\u0308]')

    @tatsumasu()
    def _SOLVE_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('solve')
            with self._option():
                self._pattern('Solve')
            with self._option():
                self._pattern('SOLVE')
            self._error(
                'expecting one of: '
                'SOLVE Solve solve'
            )

    @tatsumasu()
    def _SUBSET_(self):  # noqa
        self._pattern('‚äÇ')

    @tatsumasu()
    def _AS_(self):  # noqa
        self._pattern('as')

    @tatsumasu()
    def _POUND_(self):  # noqa
        self._pattern('#')

    @tatsumasu()
    def _FOR_(self):  # noqa
        self._pattern('for')

    @tatsumasu()
    def _SCALAR_(self):  # noqa
        self._pattern('scalar')

    @tatsumasu()
    def _VECTOR_(self):  # noqa
        self._pattern('vector')

    @tatsumasu()
    def _MATRIX_(self):  # noqa
        self._pattern('matrix')

    @tatsumasu()
    def _VERTEXSET_(self):  # noqa
        self._pattern('[Vv]ertex[Ss]et')

    @tatsumasu()
    def _EDGESET_(self):  # noqa
        self._pattern('[Ee]dge[Ss]et')

    @tatsumasu()
    def _FACESET_(self):  # noqa
        self._pattern('[Ff]ace[Ss]et')

    @tatsumasu()
    def _TETSET_(self):  # noqa
        self._pattern('[Cc]ell[Ss]et')

    @tatsumasu()
    def _SIMPLICIALSET_(self):  # noqa
        self._pattern('[Cc]ellular[Ss]et')

    @tatsumasu()
    def _EDGEMESH_(self):  # noqa
        self._pattern('[Ee]dge[Mm]esh')

    @tatsumasu()
    def _FACEMESH_(self):  # noqa
        self._pattern('[Ff]ace[Mm]esh')

    @tatsumasu()
    def _CELLMESH_(self):  # noqa
        self._pattern('[Cc]ell[Mm]esh')

    @tatsumasu()
    def _INDEX_(self):  # noqa
        self._pattern('index')

    @tatsumasu()
    def _VERTICES_(self):  # noqa
        self._pattern('vertices')

    @tatsumasu()
    def _EDGES_(self):  # noqa
        self._pattern('edges')

    @tatsumasu()
    def _FACES_(self):  # noqa
        self._pattern('faces')

    @tatsumasu()
    def _TETS_(self):  # noqa
        self._pattern('cells')

    @tatsumasu()
    def _TUPLE_(self):  # noqa
        self._pattern('tuple')

    @tatsumasu()
    def _SEQUENCE_(self):  # noqa
        self._pattern('sequence')

    @tatsumasu()
    def _SVD_(self):  # noqa
        self._pattern('svd')

    @tatsumasu()
    def _BUILTIN_KEYWORDS_(self):  # noqa
        with self._choice():
            with self._option():
                self._WHERE_()
            with self._option():
                self._GIVEN_()
            with self._option():
                self._pattern('sum')
            with self._option():
                self._MIN_()
            with self._option():
                self._MAX_()
            with self._option():
                self._ARGMIN_()
            with self._option():
                self._ARGMAX_()
            with self._option():
                self._INT_()
            with self._option():
                self._IF_()
            with self._option():
                self._OTHERWISE_()
            with self._option():
                self._IN_()
            with self._option():
                self._EXP_()
            with self._option():
                self._LOG_()
            with self._option():
                self._LN_()
            with self._option():
                self._SQRT_()
            with self._option():
                self._SUBJECT_TO_()
            with self._option():
                self._FROM_()
            with self._option():
                self._PI_()
            with self._option():
                self._pattern('‚Ñù')
            with self._option():
                self._pattern('‚Ñ§')
            with self._option():
                self._SCALAR_()
            with self._option():
                self._VECTOR_()
            with self._option():
                self._MATRIX_()
            with self._option():
                self._WITH_()
            with self._option():
                self._INITIAL_()
            with self._option():
                self._AND_()
            with self._option():
                self._OR_()
            with self._option():
                self._DELTA_()
            with self._option():
                self._NABLA_()
            with self._option():
                self._DERIVATIVE_()
            with self._option():
                self._SOLVE_()
            with self._option():
                self._PRIME_()
            with self._option():
                self._SUBSET_()
            with self._option():
                self._AS_()
            with self._option():
                self._POUND_()
            with self._option():
                self._FOR_()
            with self._option():
                self._VERTEXSET_()
            with self._option():
                self._EDGESET_()
            with self._option():
                self._FACESET_()
            with self._option():
                self._TETSET_()
            with self._option():
                self._SIMPLICIALSET_()
            with self._option():
                self._EDGEMESH_()
            with self._option():
                self._FACEMESH_()
            with self._option():
                self._CELLMESH_()
            with self._option():
                self._SPARSE_()
            with self._option():
                self._INDEX_()
            with self._option():
                self._VERTICES_()
            with self._option():
                self._EDGES_()
            with self._option():
                self._FACES_()
            with self._option():
                self._TETS_()
            with self._option():
                self._TUPLE_()
            with self._option():
                self._SEQUENCE_()
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<CELLMESH> <DELTA> <DERIVATIVE>'
                '<EDGEMESH> <EDGES> <EDGESET> <EXP>'
                '<FACEMESH> <FACES> <FACESET> <FOR>'
                '<FROM> <GIVEN> <IF> <IN> <INDEX>'
                '<INITIAL> <INT> <LN> <LOG> <MATRIX>'
                '<MAX> <MIN> <NABLA> <OR> <OTHERWISE>'
                '<PI> <POUND> <PRIME> <SCALAR> <SEQUENCE>'
                '<SIMPLICIALSET> <SOLVE> <SPARSE> <SQRT>'
                '<SUBJECT_TO> <SUBSET> <TETS> <TETSET>'
                '<TUPLE> <VECTOR> <VERTEXSET> <VERTICES>'
                '<WHERE> <WITH> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu()
    def _NOT_PREFIX_KEYWORD_(self):  # noqa
        with self._choice():
            with self._option():
                self._POUND_()
            with self._option():
                self._DELTA_()
            with self._option():
                self._NABLA_()
            with self._option():
                self._IN_()
            with self._option():
                self._DERIVATIVE_()
            self._error(
                'expecting one of: '
                '# <DELTA> <DERIVATIVE> <IN> <NABLA>'
                '<POUND> [Œî] ‚àá ‚àà ùïï'
            )

    @tatsumasu()
    def _PREFIX_KEYWORD_(self):  # noqa
        with self._ifnot():
            self._NOT_PREFIX_KEYWORD_()
        with self._group():
            self._KEYWORDS_()

    @tatsumasu('Exponent')
    def _exponent_(self):  # noqa
        self._pattern('[E][+-]?')
        self.name_last_node('exp')

        def block2():
            self._digit_()
        self._positive_closure(block2)
        self.name_last_node('pow')

        self._define(
            ['exp', 'pow'],
            []
        )

    @tatsumasu('Mantissa')
    def _mantissa_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():

                    def block2():
                        self._digit_()
                    self._closure(block2)
                    self.name_last_node('d')
                    self._token('.')

                    def block4():
                        self._digit_()
                    self._positive_closure(block4)
                    self.name_last_node('f')

                    self._define(
                        ['d', 'f'],
                        []
                    )
            with self._option():
                with self._group():

                    def block6():
                        self._digit_()
                    self._positive_closure(block6)
                    self.name_last_node('d')
                    self._token('.')

                    self._define(
                        ['d'],
                        []
                    )
            self._error(
                'expecting one of: '
                "'.' <digit> \\d"
            )

    @tatsumasu('Float')
    def _floating_point_(self):  # noqa
        self._mantissa_()
        self.name_last_node('m')
        with self._optional():
            self._exponent_()
        self.name_last_node('e')

        self._define(
            ['e', 'm'],
            []
        )

    @tatsumasu('Double')
    def _double_(self):  # noqa
        with self._choice():
            with self._option():
                self._integer_()
                self.name_last_node('i')
                self._exponent_()
                self.name_last_node('exp')

                self._define(
                    ['exp', 'i'],
                    []
                )
            with self._option():
                self._floating_point_()
                self.name_last_node('f')
            self._error(
                'expecting one of: '
                "'.' <digit> <floating_point> <integer>"
                '<mantissa> \\d'
            )

    @tatsumasu('Fraction')
    def _fraction_(self):  # noqa
        self._pattern('[\\u00BC-\\u00BE\\u2150-\\u215E]')
        self.name_last_node('value')

    @tatsumasu()
    def _number_(self):  # noqa
        with self._choice():
            with self._option():
                self._double_()
            with self._option():
                self._fraction_()
            with self._option():
                self._integer_()
            self._error(
                'expecting one of: '
                "'.' <digit> <double> <floating_point>"
                '<fraction> <integer> <mantissa>'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] \\d'
            )

    @tatsumasu()
    @nomemo
    def _operations_(self):  # noqa
        with self._choice():
            with self._option():
                self._size_op_()
            with self._option():
                self._derivative_()
            with self._option():
                self._partial_()
            with self._option():
                self._divergence_()
            with self._option():
                self._gradient_()
            with self._option():
                self._laplacian_()
            with self._option():
                self._solver_operator_()
            with self._option():
                self._norm_operator_()
            with self._option():
                self._power_operator_()
            with self._option():
                self._inner_product_operator_()
            with self._option():
                self._frobenius_product_operator_()
            with self._option():
                self._hadamard_product_operator_()
            with self._option():
                self._cross_product_operator_()
            with self._option():
                self._kronecker_product_operator_()
            with self._option():
                self._set_operators_()
            with self._option():
                self._sum_operator_()
            with self._option():
                self._integral_operator_()
            with self._option():
                self._trans_operator_()
            with self._option():
                self._sqrt_operator_()
            with self._option():
                self._function_operator_()
            with self._option():
                self._builtin_operators_()
            with self._option():
                self._pseudoinverse_operator_()
            self._error(
                'expecting one of: '
                "# '<' '|' '||' '‚Äñ' '‚à™' '‚à´' '‚ü®' <DELTA>"
                '<DERIVATIVE> <INT> <INVERSEVEC> <NABLA>'
                '<PARTIAL> <POUND> <SUM>'
                '<builtin_operators>'
                '<cross_product_operator> <derivative>'
                '<divergence> <element_convert_func>'
                '<exp_func> <factor>'
                '<frobenius_product_operator> <func_id>'
                '<function_operator> <gradient>'
                '<hadamard_product_operator>'
                '<identifier_alone>'
                '<inner_product_operator>'
                '<integral_operator> <intersect_operator>'
                '<kronecker_product_operator> <laplacian>'
                '<ln_func> <log_func> <minmax_func>'
                '<norm_operator> <partial>'
                '<power_operator>'
                '<predefined_built_operators>'
                '<pseudoinverse_operator> <set_operators>'
                '<size_op> <solver_operator> <sqrt_func>'
                '<sqrt_operator> <sum_operator>'
                '<trans_operator> <union_operator> [Œî]'
                'int inversevec sum vec‚Åª¬π ‚àÇ ‚àá ‚àë ‚àö ùïï'
            )

    @tatsumasu('Add')
    @nomemo
    def _addition_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('+')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._term_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('Subtract')
    @nomemo
    def _subtraction_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('-')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._term_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('AddSub')
    @nomemo
    def _add_sub_operator_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('+-')
                with self._option():
                    self._token('¬±')
                self._error(
                    'expecting one of: '
                    "'+-' '¬±'"
                )
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._term_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('Multiply')
    @nomemo
    def _multiplication_(self):  # noqa
        with self._choice():
            with self._option():
                self._term_()
                self.name_last_node('left')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._token('‚ãÖ')
                self.name_last_node('op')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._factor_()
                self.name_last_node('right')

                self._define(
                    ['left', 'op', 'right'],
                    []
                )
            with self._option():
                self._term_()
                self.name_last_node('left')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._factor_()
                self.name_last_node('right')

                self._define(
                    ['left', 'right'],
                    []
                )
            self._error(
                'expecting one of: '
                '<division> <factor> <multiplication>'
                '<term>'
            )

    @tatsumasu('Divide')
    @nomemo
    def _division_(self):  # noqa
        self._term_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/')
                with self._option():
                    self._token('√∑')
                self._error(
                    'expecting one of: '
                    "'/' '√∑'"
                )
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('Derivative')
    def _derivative_(self):  # noqa
        with self._choice():
            with self._option():
                self._DERIVATIVE_()
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._sup_integer_()
                            self.name_last_node('uorder')
                        with self._option():
                            self._token('^')
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._identifier_()
                                    with self._option():
                                        self._number_()
                                    self._error(
                                        'expecting one of: '
                                        '<identifier> <number>'
                                    )
                            self.name_last_node('uorder')

                            self._define(
                                ['uorder'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'^' <sup_integer>"
                        )
                self._factor_()
                self.name_last_node('upper')
                self._token('/')
                self.name_last_node('f')
                self._DERIVATIVE_()
                self._identifier_()
                self.name_last_node('lower')
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._sup_integer_()
                            self.name_last_node('lorder')
                        with self._option():
                            self._token('^')
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._identifier_()
                                    with self._option():
                                        self._number_()
                                    self._error(
                                        'expecting one of: '
                                        '<identifier> <number>'
                                    )
                            self.name_last_node('lorder')

                            self._define(
                                ['lorder'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'^' <sup_integer>"
                        )

                self._define(
                    ['f', 'lorder', 'lower', 'uorder', 'upper'],
                    []
                )
            with self._option():
                self._DERIVATIVE_()
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._sup_integer_()
                            self.name_last_node('uorder')
                        with self._option():
                            self._token('^')
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._identifier_()
                                    with self._option():
                                        self._number_()
                                    self._error(
                                        'expecting one of: '
                                        '<identifier> <number>'
                                    )
                            self.name_last_node('uorder')

                            self._define(
                                ['uorder'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'^' <sup_integer>"
                        )
                self._token('/')
                self.name_last_node('s')
                self._DERIVATIVE_()
                self._identifier_()
                self.name_last_node('lower')
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._sup_integer_()
                            self.name_last_node('lorder')
                        with self._option():
                            self._token('^')
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._identifier_()
                                    with self._option():
                                        self._number_()
                                    self._error(
                                        'expecting one of: '
                                        '<identifier> <number>'
                                    )
                            self.name_last_node('lorder')

                            self._define(
                                ['lorder'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'^' <sup_integer>"
                        )

                def block22():
                    self._hspace_()
                self._positive_closure(block22)
                self._factor_()
                self.name_last_node('upper')

                self._define(
                    ['lorder', 'lower', 's', 'uorder', 'upper'],
                    []
                )
            self._error(
                'expecting one of: '
                '<DERIVATIVE> ùïï'
            )

    @tatsumasu('Partial')
    def _partial_(self):  # noqa
        with self._choice():
            with self._option():
                self._PARTIAL_()
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._sup_integer_()
                            self.name_last_node('uorder')
                        with self._option():
                            self._token('^')
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._identifier_()
                                    with self._option():
                                        self._number_()
                                    self._error(
                                        'expecting one of: '
                                        '<identifier> <number>'
                                    )
                            self.name_last_node('uorder')

                            self._define(
                                ['uorder'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'^' <sup_integer>"
                        )
                self._factor_()
                self.name_last_node('upper')
                self._token('/')
                self.name_last_node('f')

                def block8():
                    self._PARTIAL_()
                    self._identifier_()
                    self.add_last_node_to_name('lower')
                    with self._optional():
                        with self._choice():
                            with self._option():
                                self._sup_integer_()
                                self.add_last_node_to_name('lorder')
                            with self._option():
                                self._token('^')
                                with self._group():
                                    with self._choice():
                                        with self._option():
                                            self._identifier_()
                                        with self._option():
                                            self._number_()
                                        self._error(
                                            'expecting one of: '
                                            '<identifier> <number>'
                                        )
                                self.add_last_node_to_name('lorder')

                                self._define(
                                    [],
                                    ['lorder']
                                )
                            self._error(
                                'expecting one of: '
                                "'^' <sup_integer>"
                            )

                    self._define(
                        [],
                        ['lorder', 'lower']
                    )
                self._positive_closure(block8)
                self.name_last_node('l')

                self._define(
                    ['f', 'l', 'uorder', 'upper'],
                    ['lorder', 'lower']
                )
            with self._option():
                self._PARTIAL_()
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._sup_integer_()
                            self.name_last_node('uorder')
                        with self._option():
                            self._token('^')
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._identifier_()
                                    with self._option():
                                        self._number_()
                                    self._error(
                                        'expecting one of: '
                                        '<identifier> <number>'
                                    )
                            self.name_last_node('uorder')

                            self._define(
                                ['uorder'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'^' <sup_integer>"
                        )
                self._token('/')
                self.name_last_node('s')

                def block20():
                    self._PARTIAL_()
                    self._identifier_()
                    self.add_last_node_to_name('lower')
                    with self._optional():
                        with self._choice():
                            with self._option():
                                self._sup_integer_()
                                self.add_last_node_to_name('lorder')
                            with self._option():
                                self._token('^')
                                with self._group():
                                    with self._choice():
                                        with self._option():
                                            self._identifier_()
                                        with self._option():
                                            self._number_()
                                        self._error(
                                            'expecting one of: '
                                            '<identifier> <number>'
                                        )
                                self.add_last_node_to_name('lorder')

                                self._define(
                                    [],
                                    ['lorder']
                                )
                            self._error(
                                'expecting one of: '
                                "'^' <sup_integer>"
                            )

                    self._define(
                        [],
                        ['lorder', 'lower']
                    )
                self._positive_closure(block20)
                self.name_last_node('l')

                def block26():
                    self._hspace_()
                self._positive_closure(block26)
                self._factor_()
                self.name_last_node('upper')

                self._define(
                    ['l', 's', 'uorder', 'upper'],
                    ['lorder', 'lower']
                )
            self._error(
                'expecting one of: '
                '<PARTIAL> ‚àÇ'
            )

    @tatsumasu('Divergence')
    def _divergence_(self):  # noqa
        self._NABLA_()
        self.name_last_node('name')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('‚ãÖ')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._factor_()
        self.name_last_node('value')

        self._define(
            ['name', 'value'],
            []
        )

    @tatsumasu('Gradient')
    def _gradient_(self):  # noqa
        with self._choice():
            with self._option():
                self._NABLA_()
                self.name_last_node('name')
                self._token('_')
                self._identifier_alone_()
                self.name_last_node('sub')

                def block3():
                    self._hspace_()
                self._positive_closure(block3)
                self._factor_()
                self.name_last_node('value')

                self._define(
                    ['name', 'sub', 'value'],
                    []
                )
            with self._option():
                self._NABLA_()
                self.name_last_node('name')
                self._unicode_subscript_()
                self.name_last_node('sub')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._factor_()
                self.name_last_node('value')

                self._define(
                    ['name', 'sub', 'value'],
                    []
                )
            with self._option():
                self._NABLA_()
                self.name_last_node('name')

                def block10():
                    self._hspace_()
                self._closure(block10)
                self._factor_()
                self.name_last_node('value')

                self._define(
                    ['name', 'value'],
                    []
                )
            self._error(
                'expecting one of: '
                '<NABLA> ‚àá'
            )

    @tatsumasu('Laplace')
    def _laplacian_(self):  # noqa
        self._DELTA_()
        self.name_last_node('name')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._factor_()
        self.name_last_node('value')

        self._define(
            ['name', 'value'],
            []
        )

    @tatsumasu('Power')
    @nomemo
    def _power_operator_(self):  # noqa
        with self._choice():
            with self._option():
                self._factor_()
                self.name_last_node('base')
                self._token('^T')
                self.name_last_node('t')

                self._define(
                    ['base', 't'],
                    []
                )
            with self._option():
                self._factor_()
                self.name_last_node('base')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('^(-1)')
                        with self._option():
                            self._token('‚Åª¬π')
                        self._error(
                            'expecting one of: '
                            "'^(-1)' '‚Åª¬π'"
                        )
                self.name_last_node('r')

                self._define(
                    ['base', 'r'],
                    []
                )
            with self._option():
                self._factor_()
                self.name_last_node('base')
                self._token('^')
                self._factor_()
                self.name_last_node('power')

                self._define(
                    ['base', 'power'],
                    []
                )
            with self._option():
                self._factor_()
                self.name_last_node('base')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._sup_integer_()
                        with self._option():
                            self._unicode_superscript_()
                        self._error(
                            'expecting one of: '
                            '<sup_integer> <unicode_superscript>'
                        )
                self.name_last_node('power')

                self._define(
                    ['base', 'power'],
                    []
                )
            self._error(
                'expecting one of: '
                "'(' '.' '0' '1' '[' '{' '‚é°' 'ùüô'"
                '<builtin_operators> <constant>'
                '<cross_product_operator> <derivative>'
                '<digit> <divergence> <double> <factor>'
                '<floating_point> <fraction>'
                '<frobenius_product_operator>'
                '<function_operator> <gradient>'
                '<hadamard_product_operator> <identifier>'
                '<inner_product_operator> <integer>'
                '<integral_operator>'
                '<kronecker_product_operator> <laplacian>'
                '<mantissa> <matrix> <norm_operator>'
                '<number> <number_matrix> <operations>'
                '<partial> <power_operator>'
                '<pseudoinverse_operator> <set>'
                '<set_operators> <size_op>'
                '<solver_operator> <sqrt_operator>'
                '<subexpression> <sum_operator>'
                '<trans_operator> <vector> [01\\u1D7D9]'
                '[\\u00BC-\\u00BE\\u2150-\\u215E]'
            )

    @tatsumasu('Solver')
    @nomemo
    def _solver_operator_(self):  # noqa
        with self._choice():
            with self._option():
                self._factor_()
                self.name_last_node('left')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._token('\\')

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._factor_()
                self.name_last_node('right')

                self._define(
                    ['left', 'right'],
                    []
                )
            with self._option():
                self._factor_()
                self.name_last_node('left')

                def block6():
                    self._hspace_()
                self._closure(block6)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('^(-1)')
                        with self._option():
                            self._token('‚Åª¬π')
                        self._error(
                            'expecting one of: '
                            "'^(-1)' '‚Åª¬π'"
                        )
                self.name_last_node('p')

                def block9():
                    self._hspace_()
                self._closure(block9)
                self._factor_()
                self.name_last_node('right')

                self._define(
                    ['left', 'p', 'right'],
                    []
                )
            self._error(
                'expecting one of: '
                "'(' '.' '0' '1' '[' '{' '‚é°' 'ùüô'"
                '<builtin_operators> <constant>'
                '<cross_product_operator> <derivative>'
                '<digit> <divergence> <double> <factor>'
                '<floating_point> <fraction>'
                '<frobenius_product_operator>'
                '<function_operator> <gradient>'
                '<hadamard_product_operator> <identifier>'
                '<inner_product_operator> <integer>'
                '<integral_operator>'
                '<kronecker_product_operator> <laplacian>'
                '<mantissa> <matrix> <norm_operator>'
                '<number> <number_matrix> <operations>'
                '<partial> <power_operator>'
                '<pseudoinverse_operator> <set>'
                '<set_operators> <size_op>'
                '<solver_operator> <sqrt_operator>'
                '<subexpression> <sum_operator>'
                '<trans_operator> <vector> [01\\u1D7D9]'
                '[\\u00BC-\\u00BE\\u2150-\\u215E]'
            )

    @tatsumasu('Summation')
    def _sum_operator_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._SUM_()
                            with self._option():
                                self._token('‚à™')
                                self.name_last_node('u')
                            self._error(
                                'expecting one of: '
                                "'‚à™' <SUM>"
                            )
                    self._token('_')
                    self._identifier_alone_()
                    self.name_last_node('sub')

                    def block4():
                        self._hspace_()
                    self._positive_closure(block4)
                    with self._optional():
                        self._token('-')
                    self.name_last_node('sign')
                    self._term_()
                    self.name_last_node('exp')

                    self._define(
                        ['exp', 'sign', 'sub', 'u'],
                        []
                    )
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._SUM_()
                            with self._option():
                                self._token('‚à™')
                                self.name_last_node('u')
                            self._error(
                                'expecting one of: '
                                "'‚à™' <SUM>"
                            )
                    self._token('_')
                    self._identifier_alone_()
                    self.name_last_node('sub')
                    with self._if():
                        self._token('(')

                    def block10():
                        self._hspace_()
                    self._closure(block10)
                    with self._optional():
                        self._token('-')
                    self.name_last_node('sign')
                    self._term_()
                    self.name_last_node('exp')

                    self._define(
                        ['exp', 'sign', 'sub', 'u'],
                        []
                    )
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._SUM_()
                            with self._option():
                                self._token('‚à™')
                                self.name_last_node('u')
                            self._error(
                                'expecting one of: '
                                "'‚à™' <SUM>"
                            )
                    self._token('_(')

                    def block15():
                        self._hspace_()
                    self._closure(block15)
                    self._identifier_alone_()
                    self.name_last_node('id')

                    def block17():
                        self._hspace_()
                    self._closure(block17)
                    self._token('for')

                    def block18():
                        self._hspace_()
                    self._closure(block18)
                    self._if_condition_()
                    self.name_last_node('cond')

                    def block20():
                        self._hspace_()
                    self._closure(block20)
                    self._token(')')

                    def block21():
                        self._hspace_()
                    self._closure(block21)
                    with self._optional():
                        self._token('-')
                    self.name_last_node('sign')
                    self._term_()
                    self.name_last_node('exp')

                    self._define(
                        ['cond', 'exp', 'id', 'sign', 'u'],
                        []
                    )
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._SUM_()
                            with self._option():
                                self._token('‚à™')
                                self.name_last_node('u')
                            self._error(
                                'expecting one of: '
                                "'‚à™' <SUM>"
                            )
                    self._token('_(')

                    def block26():
                        self._hspace_()
                    self._closure(block26)
                    self._identifier_alone_()
                    self.name_last_node('id')

                    def block28():
                        self._hspace_()
                    self._closure(block28)
                    self._token('=')

                    def block29():
                        self._hspace_()
                    self._closure(block29)
                    self._expression_()
                    self.name_last_node('lower')

                    def block31():
                        self._hspace_()
                    self._closure(block31)
                    self._token(')^')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._identifier_alone_()
                            with self._option():
                                self._integer_()
                            self._error(
                                'expecting one of: '
                                '<identifier_alone> <integer>'
                            )
                    self.name_last_node('upper')

                    def block34():
                        self._hspace_()
                    self._positive_closure(block34)
                    with self._optional():
                        self._token('-')
                    self.name_last_node('sign')
                    self._term_()
                    self.name_last_node('exp')

                    self._define(
                        ['exp', 'id', 'lower', 'sign', 'u', 'upper'],
                        []
                    )
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._SUM_()
                            with self._option():
                                self._token('‚à™')
                                self.name_last_node('u')
                            self._error(
                                'expecting one of: '
                                "'‚à™' <SUM>"
                            )
                    self._token('_(')

                    def block39():
                        self._hspace_()
                    self._closure(block39)
                    self._identifier_alone_()
                    self.name_last_node('id')

                    def block41():
                        self._hspace_()
                    self._closure(block41)
                    self._token('=')

                    def block42():
                        self._hspace_()
                    self._closure(block42)
                    self._expression_()
                    self.name_last_node('lower')

                    def block44():
                        self._hspace_()
                    self._closure(block44)
                    self._token(')^(')

                    def block45():
                        self._hspace_()
                    self._closure(block45)
                    self._expression_()
                    self.name_last_node('upper')

                    def block47():
                        self._hspace_()
                    self._closure(block47)
                    self._token(')')

                    def block48():
                        self._hspace_()
                    self._positive_closure(block48)
                    with self._optional():
                        self._token('-')
                    self.name_last_node('sign')
                    self._term_()
                    self.name_last_node('exp')

                    self._define(
                        ['exp', 'id', 'lower', 'sign', 'u', 'upper'],
                        []
                    )
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._SUM_()
                            with self._option():
                                self._token('‚à™')
                                self.name_last_node('u')
                            self._error(
                                'expecting one of: '
                                "'‚à™' <SUM>"
                            )
                    self._token('_(')

                    def block53():
                        self._hspace_()
                    self._closure(block53)
                    self._identifier_alone_()
                    self.add_last_node_to_name('enum')

                    def block55():

                        def block56():
                            self._hspace_()
                        self._closure(block56)

                        def block57():
                            self._token(',')
                        self._closure(block57)

                        def block58():
                            self._hspace_()
                        self._closure(block58)
                        self._identifier_alone_()
                        self.add_last_node_to_name('enum')

                        self._define(
                            [],
                            ['enum']
                        )
                    self._closure(block55)

                    def block60():
                        self._hspace_()
                    self._closure(block60)
                    self._IN_()

                    def block61():
                        self._hspace_()
                    self._closure(block61)
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._function_operator_()
                            with self._option():
                                self._builtin_operators_()
                            with self._option():
                                self._identifier_alone_()
                            self._error(
                                'expecting one of: '
                                '<builtin_operators> <function_operator>'
                                '<identifier_alone>'
                            )
                    self.name_last_node('range')

                    def block64():
                        self._hspace_()
                    self._closure(block64)
                    self._token(')')

                    def block65():
                        self._hspace_()
                    self._closure(block65)
                    with self._optional():
                        self._token('-')
                    self.name_last_node('sign')
                    self._term_()
                    self.name_last_node('exp')

                    self._define(
                        ['exp', 'range', 'sign', 'u'],
                        ['enum']
                    )
                self._error(
                    'expecting one of: '
                    "'‚à™' <SUM>"
                )

        def block68():
            with self._optional():

                def block69():
                    self._hspace_()
                self._closure(block69)
                self._line_()

            def block70():
                self._hspace_()
            self._closure(block70)
            with self._group():
                with self._choice():
                    with self._option():
                        self._WHERE_()
                    with self._option():
                        self._WITH_()
                    self._error(
                        'expecting one of: '
                        '<WHERE> <WITH>'
                    )

            def block72():
                self._hspace_()
            self._closure(block72)
            self._general_assign_()
            self.add_last_node_to_name('extra')

            def block74():

                def block75():
                    self._hspace_()
                self._closure(block75)
                self._token(',')

                def block76():
                    self._hspace_()
                self._closure(block76)
                with self._optional():
                    self._line_()

                def block77():
                    self._hspace_()
                self._closure(block77)
                self._general_assign_()
                self.add_last_node_to_name('extra')

                self._define(
                    [],
                    ['extra']
                )
            self._closure(block74)

            self._define(
                [],
                ['extra']
            )
        self._closure(block68)

        self._define(
            ['cond', 'exp', 'id', 'lower', 'range', 'sign', 'sub', 'u', 'upper'],
            ['enum', 'extra']
        )

    @tatsumasu('Optimize')
    def _optimize_operator_(self):  # noqa

        def block0():
            self._token('with')

            def block1():
                self._hspace_()
            self._closure(block1)
            self._token('initial')

            def block2():
                self._hspace_()
            self._closure(block2)
            self._statement_()
            self.add_last_node_to_name('init')

            def block4():

                def block5():
                    self._hspace_()
                self._closure(block5)
                self._token(';')

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._statement_()
                self.add_last_node_to_name('init')

                self._define(
                    [],
                    ['init']
                )
            self._closure(block4)

            def block8():
                self._hspace_()
            self._closure(block8)
            self._token('\n')

            self._define(
                [],
                ['init']
            )
        self._closure(block0)
        with self._group():
            with self._choice():
                with self._option():
                    self._MIN_()
                    self.name_last_node('min')
                with self._option():
                    self._MAX_()
                    self.name_last_node('max')
                with self._option():
                    self._ARGMIN_()
                    self.name_last_node('amin')
                with self._option():
                    self._ARGMAX_()
                    self.name_last_node('amax')
                self._error(
                    'expecting one of: '
                    '<ARGMAX> <ARGMIN> <MAX> <MIN>'
                )
        self._token('_(')

        def block14():
            self._hspace_()
        self._closure(block14)
        self._where_condition_terse_()
        self.add_last_node_to_name('defs')

        def block16():

            def block17():
                self._hspace_()
            self._closure(block17)
            self._token(',')

            def block18():
                self._hspace_()
            self._closure(block18)
            self._where_condition_terse_()
            self.add_last_node_to_name('defs')

            self._define(
                [],
                ['defs']
            )
        self._closure(block16)

        def block20():
            self._hspace_()
        self._closure(block20)
        self._token(')')

        def block21():
            self._hspace_()
        self._closure(block21)
        self._expression_()
        self.name_last_node('exp')

        def block23():

            def block24():
                self._hspace_()
            self._closure(block24)

            def block25():
                self._separator_()
            self._closure(block25)

            def block26():
                self._hspace_()
            self._closure(block26)
            self._SUBJECT_TO_()

            def block27():
                self._hspace_()
            self._closure(block27)

            def block28():
                self._separator_()
            self._closure(block28)

            def block29():
                self._hspace_()
            self._closure(block29)
            self._multi_cond_()
            self.name_last_node('cond')

            self._define(
                ['cond'],
                []
            )
        self._closure(block23)

        self._define(
            ['amax', 'amin', 'cond', 'exp', 'max', 'min'],
            ['defs', 'init']
        )

    @tatsumasu('MultiCond')
    @leftrec
    def _multi_cond_(self):  # noqa
        with self._choice():
            with self._option():

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._multi_cond_()
                self.name_last_node('m_cond')
                self._separator_with_space_()
                self._atom_condition_()
                self.name_last_node('cond')

                def block4():
                    self._hspace_()
                self._closure(block4)

                self._define(
                    ['cond', 'm_cond'],
                    []
                )
            with self._option():

                def block5():
                    self._hspace_()
                self._closure(block5)
                self._atom_condition_()
                self.name_last_node('cond')

                def block7():
                    self._hspace_()
                self._closure(block7)

                self._define(
                    ['cond'],
                    []
                )
            self._error(
                'expecting one of: '
                "'(' <atom_condition> <equal> <greater>"
                '<greater_equal> <hspace> <in> <less>'
                '<less_equal> <multi_cond> <not_equal>'
                '<not_in> [ \\t]'
            )

    @tatsumasu('Integral')
    def _integral_operator_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._INT_()
                with self._option():
                    self._token('‚à´')
                self._error(
                    'expecting one of: '
                    "'‚à´' <INT>"
                )
        self._token('_')
        with self._group():
            with self._choice():
                with self._option():
                    self._domain_()
                    self.name_last_node('d')
                with self._option():
                    with self._group():
                        self._sub_factor_()
                        self.name_last_node('lower')

                        def block4():
                            self._hspace_()
                        self._closure(block4)
                        self._token('^')

                        def block5():
                            self._hspace_()
                        self._closure(block5)
                        self._sub_factor_()
                        self.name_last_node('upper')

                        self._define(
                            ['lower', 'upper'],
                            []
                        )
                self._error(
                    'expecting one of: '
                    '<domain> <sub_factor>'
                )

        def block7():
            self._hspace_()
        self._closure(block7)
        self._expression_()
        self.name_last_node('exp')

        def block9():
            self._hspace_()
        self._closure(block9)
        self._DERIVATIVE_()
        self._identifier_alone_()
        self.name_last_node('id')

        self._define(
            ['d', 'exp', 'id', 'lower', 'upper'],
            []
        )

    @tatsumasu('Domain')
    def _domain_(self):  # noqa
        self._token('[')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('lower')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(',')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._expression_()
        self.name_last_node('upper')
        self._token(']')

        self._define(
            ['lower', 'upper'],
            []
        )

    @tatsumasu('Norm')
    def _norm_operator_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('||')
                    self.name_last_node('double')

                    def block2():
                        self._hspace_()
                    self._closure(block2)
                    self._expression_()
                    self.name_last_node('value')

                    def block4():
                        self._hspace_()
                    self._closure(block4)
                    self._token('||')

                    self._define(
                        ['double', 'value'],
                        []
                    )
                with self._option():
                    self._token('‚Äñ')
                    self.name_last_node('double')

                    def block6():
                        self._hspace_()
                    self._closure(block6)
                    self._expression_()
                    self.name_last_node('value')

                    def block8():
                        self._hspace_()
                    self._closure(block8)
                    self._token('‚Äñ')

                    self._define(
                        ['double', 'value'],
                        []
                    )
                with self._option():
                    self._token('|')
                    self.name_last_node('single')

                    def block10():
                        self._hspace_()
                    self._closure(block10)
                    self._expression_()
                    self.name_last_node('value')

                    def block12():
                        self._hspace_()
                    self._closure(block12)
                    self._token('|')

                    self._define(
                        ['single', 'value'],
                        []
                    )
                self._error(
                    'expecting one of: '
                    "'|' '||' '‚Äñ'"
                )
        with self._optional():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('_')
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._integer_()
                                            with self._option():
                                                self._token('*')
                                            with self._option():
                                                self._token('‚àû')
                                            with self._option():
                                                self._identifier_alone_()
                                            self._error(
                                                'expecting one of: '
                                                "'*' '‚àû' <identifier_alone> <integer>"
                                            )
                                    self.name_last_node('sub')

                                    self._define(
                                        ['sub'],
                                        []
                                    )
                                with self._option():
                                    self._sub_integer_()
                                    self.name_last_node('sub')
                                self._error(
                                    'expecting one of: '
                                    "'_' <sub_integer>"
                                )
                        with self._optional():
                            with self._choice():
                                with self._option():
                                    self._token('^')
                                    self._factor_()
                                    self.name_last_node('power')

                                    self._define(
                                        ['power'],
                                        []
                                    )
                                with self._option():
                                    self._sup_integer_()
                                    self.name_last_node('power')
                                self._error(
                                    'expecting one of: '
                                    "'^' <sup_integer>"
                                )

                        self._define(
                            ['power', 'sub'],
                            []
                        )
                with self._option():
                    with self._group():
                        self._token('_(')
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._integer_()
                                with self._option():
                                    self._token('*')
                                with self._option():
                                    self._token('‚àû')
                                with self._option():
                                    self._identifier_()
                                self._error(
                                    'expecting one of: '
                                    "'*' '‚àû' <identifier> <integer>"
                                )
                        self.name_last_node('sub')
                        self._token(')')
                        with self._optional():
                            with self._choice():
                                with self._option():
                                    self._token('^')
                                    self._factor_()
                                    self.name_last_node('power')

                                    self._define(
                                        ['power'],
                                        []
                                    )
                                with self._option():
                                    self._sup_integer_()
                                    self.name_last_node('power')
                                self._error(
                                    'expecting one of: '
                                    "'^' <sup_integer>"
                                )

                        self._define(
                            ['power', 'sub'],
                            []
                        )
                with self._option():
                    with self._group():
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('^')
                                    self._factor_()
                                    self.name_last_node('power')

                                    self._define(
                                        ['power'],
                                        []
                                    )
                                with self._option():
                                    self._sup_integer_()
                                    self.name_last_node('power')
                                self._error(
                                    'expecting one of: '
                                    "'^' <sup_integer>"
                                )
                        with self._optional():
                            with self._choice():
                                with self._option():
                                    self._token('_')
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._integer_()
                                            with self._option():
                                                self._token('*')
                                            with self._option():
                                                self._token('‚àû')
                                            with self._option():
                                                self._identifier_alone_()
                                            self._error(
                                                'expecting one of: '
                                                "'*' '‚àû' <identifier_alone> <integer>"
                                            )
                                    self.name_last_node('sub')

                                    self._define(
                                        ['sub'],
                                        []
                                    )
                                with self._option():
                                    self._sub_integer_()
                                    self.name_last_node('sub')
                                self._error(
                                    'expecting one of: '
                                    "'_' <sub_integer>"
                                )

                        self._define(
                            ['power', 'sub'],
                            []
                        )
                self._error(
                    'expecting one of: '
                    "'^' '_' '_(' <sub_integer> <sup_integer>"
                )

        self._define(
            ['double', 'power', 'single', 'sub', 'value'],
            []
        )

    @tatsumasu('InnerProduct')
    def _inner_product_operator_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('<')

                        def block1():
                            self._hspace_()
                        self._closure(block1)
                        self._expression_()
                        self.name_last_node('left')

                        def block3():
                            self._hspace_()
                        self._closure(block3)
                        self._token(',')

                        def block4():
                            self._hspace_()
                        self._closure(block4)
                        self._expression_()
                        self.name_last_node('right')

                        def block6():
                            self._hspace_()
                        self._closure(block6)
                        self._token('>')

                        self._define(
                            ['left', 'right'],
                            []
                        )
                with self._option():
                    with self._group():
                        self._token('‚ü®')

                        def block7():
                            self._hspace_()
                        self._closure(block7)
                        self._expression_()
                        self.name_last_node('left')

                        def block9():
                            self._hspace_()
                        self._closure(block9)
                        self._token(',')

                        def block10():
                            self._hspace_()
                        self._closure(block10)
                        self._expression_()
                        self.name_last_node('right')

                        def block12():
                            self._hspace_()
                        self._closure(block12)
                        self._token('‚ü©')

                        self._define(
                            ['left', 'right'],
                            []
                        )
                self._error(
                    'expecting one of: '
                    "'<' '‚ü®'"
                )

        def block13():
            self._token('_')
            self._identifier_()
            self.name_last_node('sub')

            self._define(
                ['sub'],
                []
            )
        self._closure(block13)

        self._define(
            ['left', 'right', 'sub'],
            []
        )

    @tatsumasu('FroProduct')
    @nomemo
    def _frobenius_product_operator_(self):  # noqa
        self._factor_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token(':')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('HadamardProduct')
    @nomemo
    def _hadamard_product_operator_(self):  # noqa
        self._factor_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('‚àò')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('CrossProduct')
    @nomemo
    def _cross_product_operator_(self):  # noqa
        self._factor_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('√ó')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('KroneckerProduct')
    @nomemo
    def _kronecker_product_operator_(self):  # noqa
        self._factor_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('‚äó')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Transpose')
    @nomemo
    def _trans_operator_(self):  # noqa
        self._factor_()
        self.name_last_node('f')
        self._pattern('·µÄ')

        self._define(
            ['f'],
            []
        )

    @tatsumasu('PseudoInverse')
    @nomemo
    def _pseudoinverse_operator_(self):  # noqa
        self._factor_()
        self.name_last_node('f')
        self._pattern('‚Å∫')

        self._define(
            ['f'],
            []
        )

    @tatsumasu('Squareroot')
    def _sqrt_operator_(self):  # noqa
        self._pattern('‚àö')
        self._factor_()
        self.name_last_node('f')

        self._define(
            ['f'],
            []
        )

    @tatsumasu()
    def _predefined_built_operators_(self):  # noqa
        with self._choice():
            with self._option():
                self._exp_func_()
            with self._option():
                self._log_func_()
            with self._option():
                self._ln_func_()
            with self._option():
                self._sqrt_func_()
            with self._option():
                self._element_convert_func_()
            with self._option():
                self._minmax_func_()
            self._error(
                'expecting one of: '
                '<EDGES> <EDGESET> <EXP> <FACES>'
                '<FACESET> <LN> <LOG> <MAX> <MIN>'
                '<SEQUENCE> <SIMPLICIALSET> <SQRT> <TETS>'
                '<TETSET> <TUPLE> <VERTEXSET> <VERTICES>'
                '<element_convert_func> <exp_func>'
                '<ln_func> <log_func> <minmax_func>'
                '<sqrt_func> [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Ss]et'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et cells'
                'edges exp faces ln log'
                'log[\\u2081][\\u2080] log[\\u2082] max min'
                'sequence sqrt tuple vertices'
            )

    @tatsumasu('ElementConvertFunc')
    def _element_convert_func_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._VERTEXSET_()
                    self.name_last_node('vs')
                with self._option():
                    self._EDGESET_()
                    self.name_last_node('es')
                with self._option():
                    self._FACESET_()
                    self.name_last_node('fs')
                with self._option():
                    self._TETSET_()
                    self.name_last_node('ts')
                with self._option():
                    self._SIMPLICIALSET_()
                    self.name_last_node('s')
                with self._option():
                    self._TUPLE_()
                    self.name_last_node('tu')
                with self._option():
                    self._SEQUENCE_()
                    self.name_last_node('se')
                with self._option():
                    self._VERTICES_()
                    self.name_last_node('v')
                with self._option():
                    self._EDGES_()
                    self.name_last_node('e')
                with self._option():
                    self._FACES_()
                    self.name_last_node('f')
                with self._option():
                    self._TETS_()
                    self.name_last_node('t')
                self._error(
                    'expecting one of: '
                    '<EDGES> <EDGESET> <FACES> <FACESET>'
                    '<SEQUENCE> <SIMPLICIALSET> <TETS>'
                    '<TETSET> <TUPLE> <VERTEXSET> <VERTICES>'
                )
        self._token('(')

        def block12():

            def block13():
                self._hspace_()
            self._closure(block13)
            self._expression_()
            self.add_last_node_to_name('params')

            def block15():

                def block16():
                    self._hspace_()
                self._closure(block16)
                self._params_separator_()
                self.add_last_node_to_name('separators')

                def block18():
                    self._hspace_()
                self._closure(block18)
                self._expression_()
                self.add_last_node_to_name('params')

                self._define(
                    [],
                    ['params', 'separators']
                )
            self._closure(block15)

            self._define(
                [],
                ['params', 'separators']
            )
        self._closure(block12)

        def block20():
            self._hspace_()
        self._closure(block20)
        self._token(')')

        self._define(
            ['e', 'es', 'f', 'fs', 's', 'se', 't', 'ts', 'tu', 'v', 'vs'],
            ['params', 'separators']
        )

    @tatsumasu('ExpFunc')
    def _exp_func_(self):  # noqa
        self._EXP_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('MinmaxFunc')
    def _minmax_func_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._MIN_()
                    self.name_last_node('min')
                with self._option():
                    self._MAX_()
                    self.name_last_node('max')
                self._error(
                    'expecting one of: '
                    '<MAX> <MIN>'
                )
        self._token('(')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._expression_()
        self.add_last_node_to_name('params')

        def block5():

            def block6():
                self._hspace_()
            self._closure(block6)
            self._params_separator_()
            self.add_last_node_to_name('separators')

            def block8():
                self._hspace_()
            self._closure(block8)
            self._expression_()
            self.add_last_node_to_name('params')

            self._define(
                [],
                ['params', 'separators']
            )
        self._closure(block5)

        def block10():
            self._hspace_()
        self._closure(block10)
        self._token(')')

        self._define(
            ['max', 'min'],
            ['params', 'separators']
        )

    @tatsumasu('LogFunc')
    def _log_func_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._pattern('log[\\u2082]')
                                self.name_last_node('f')
                            with self._option():
                                self._pattern('log[\\u2081][\\u2080]')
                                self.name_last_node('s')
                            self._error(
                                'expecting one of: '
                                'log[\\u2081][\\u2080] log[\\u2082]'
                            )
                    self._token('(')

                    def block4():
                        self._hspace_()
                    self._closure(block4)
                    self._expression_()
                    self.name_last_node('param')

                    def block6():
                        self._hspace_()
                    self._closure(block6)
                    self._token(')')

                    self._define(
                        ['f', 'param', 's'],
                        []
                    )
            with self._option():
                with self._group():
                    self._LOG_()
                    with self._optional():
                        with self._choice():
                            with self._option():
                                self._token('_2')
                                self.name_last_node('f')
                            with self._option():
                                self._token('_10')
                                self.name_last_node('s')
                            self._error(
                                'expecting one of: '
                                "'_10' '_2'"
                            )
                    self._token('(')

                    def block10():
                        self._hspace_()
                    self._closure(block10)
                    self._expression_()
                    self.name_last_node('param')

                    def block12():
                        self._hspace_()
                    self._closure(block12)
                    self._token(')')

                    self._define(
                        ['f', 'param', 's'],
                        []
                    )
            self._error(
                'expecting one of: '
                '<LOG> log log[\\u2081][\\u2080]'
                'log[\\u2082]'
            )

    @tatsumasu('LnFunc')
    def _ln_func_(self):  # noqa
        self._LN_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('SqrtFunc')
    def _sqrt_func_(self):  # noqa
        self._SQRT_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('Matrix')
    def _matrix_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('[')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._rows_()
                self.name_last_node('value')

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._token(']')

                self._define(
                    ['value'],
                    []
                )
            with self._option():
                self._token('‚é°')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._rows_()
                self.name_last_node('value')

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._token('‚é¶')

                self._define(
                    ['value'],
                    []
                )
            self._error(
                'expecting one of: '
                "'[' '‚é°'"
            )

    @tatsumasu('Vector')
    def _vector_(self):  # noqa
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.add_last_node_to_name('exp')

        def block2():

            def block3():
                self._hspace_()
            self._closure(block3)
            self._token(',')

            def block4():
                self._hspace_()
            self._closure(block4)
            self._expression_()
            self.add_last_node_to_name('exp')

            self._define(
                [],
                ['exp']
            )
        self._positive_closure(block2)

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            [],
            ['exp']
        )

    @tatsumasu('Set')
    def _set_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('{')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._expression_()
                self.add_last_node_to_name('exp')

                def block3():

                    def block4():
                        self._hspace_()
                    self._closure(block4)
                    self._token(',')

                    def block5():
                        self._hspace_()
                    self._closure(block5)
                    self._expression_()
                    self.add_last_node_to_name('exp')

                    self._define(
                        [],
                        ['exp']
                    )
                self._closure(block3)

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._token('}')

                self._define(
                    [],
                    ['exp']
                )
            with self._option():
                self._token('{')

                def block8():
                    self._hspace_()
                self._closure(block8)
                self._expression_()
                self.add_last_node_to_name('exp')

                def block10():
                    self._hspace_()
                self._closure(block10)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._FOR_()
                        with self._option():
                            self._pattern('‚àÄ')
                        self._error(
                            'expecting one of: '
                            '<FOR> ‚àÄ'
                        )
                self.name_last_node('f')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._identifier_alone_()
                self.add_last_node_to_name('enum')

                def block15():

                    def block16():
                        self._hspace_()
                    self._closure(block16)

                    def block17():
                        self._token(',')
                    self._closure(block17)

                    def block18():
                        self._hspace_()
                    self._closure(block18)
                    self._identifier_alone_()
                    self.add_last_node_to_name('enum')

                    self._define(
                        [],
                        ['enum']
                    )
                self._closure(block15)

                def block20():
                    self._hspace_()
                self._closure(block20)
                self._IN_()

                def block21():
                    self._hspace_()
                self._closure(block21)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._function_operator_()
                        with self._option():
                            self._builtin_operators_()
                        with self._option():
                            self._identifier_alone_()
                        self._error(
                            'expecting one of: '
                            '<builtin_operators> <function_operator>'
                            '<identifier_alone>'
                        )
                self.name_last_node('range')

                def block24():
                    self._hspace_()
                self._closure(block24)

                def block25():
                    self._IF_()

                    def block26():
                        self._hspace_()
                    self._closure(block26)
                    self._if_condition_()
                    self.name_last_node('cond')

                    def block28():
                        self._hspace_()
                    self._closure(block28)

                    self._define(
                        ['cond'],
                        []
                    )
                self._closure(block25)
                self._token('}')

                self._define(
                    ['cond', 'f', 'range'],
                    ['enum', 'exp']
                )
            with self._option():
                self._token('{')

                def block29():
                    self._hspace_()
                self._closure(block29)
                self._expression_()
                self.add_last_node_to_name('exp')

                def block31():
                    self._hspace_()
                self._closure(block31)
                self._pattern('\\|')
                self.name_last_node('o')

                def block33():
                    self._hspace_()
                self._closure(block33)
                self._identifier_alone_()
                self.add_last_node_to_name('enum')

                def block35():

                    def block36():
                        self._hspace_()
                    self._closure(block36)

                    def block37():
                        self._token(',')
                    self._closure(block37)

                    def block38():
                        self._hspace_()
                    self._closure(block38)
                    self._identifier_alone_()
                    self.add_last_node_to_name('enum')

                    self._define(
                        [],
                        ['enum']
                    )
                self._closure(block35)

                def block40():
                    self._hspace_()
                self._closure(block40)
                self._IN_()

                def block41():
                    self._hspace_()
                self._closure(block41)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._function_operator_()
                        with self._option():
                            self._builtin_operators_()
                        with self._option():
                            self._identifier_alone_()
                        self._error(
                            'expecting one of: '
                            '<builtin_operators> <function_operator>'
                            '<identifier_alone>'
                        )
                self.name_last_node('range')

                def block44():
                    self._hspace_()
                self._closure(block44)

                def block45():
                    self._token(',')

                    def block46():
                        self._hspace_()
                    self._closure(block46)
                    self._if_condition_()
                    self.name_last_node('cond')

                    def block48():
                        self._hspace_()
                    self._closure(block48)

                    self._define(
                        ['cond'],
                        []
                    )
                self._closure(block45)
                self._token('}')

                self._define(
                    ['cond', 'o', 'range'],
                    ['enum', 'exp']
                )
            self._error(
                'expecting one of: '
                "'{'"
            )

    @tatsumasu('MultiCondExpr')
    def _multi_cond_expr_(self):  # noqa
        self._token('{')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._multi_if_conditions_()
        self.name_last_node('ifs')
        with self._optional():

            def block2():
                self._separator_with_space_()
            self._positive_closure(block2)

            def block3():
                self._hspace_()
            self._closure(block3)
            self._expression_()
            self.name_last_node('other')

            def block5():
                self._hspace_()
            self._closure(block5)
            self._OTHERWISE_()

            self._define(
                ['other'],
                []
            )

        self._define(
            ['ifs', 'other'],
            []
        )

    @tatsumasu('MultiIfs')
    @leftrec
    def _multi_if_conditions_(self):  # noqa
        with self._choice():
            with self._option():
                self._multi_if_conditions_()
                self.name_last_node('ifs')

                def block2():
                    self._separator_with_space_()
                self._positive_closure(block2)
                self._single_if_condition_()
                self.name_last_node('value')

                self._define(
                    ['ifs', 'value'],
                    []
                )
            with self._option():
                self._single_if_condition_()
                self.name_last_node('value')
            self._error(
                'expecting one of: '
                '<expression> <if_condition>'
                '<multi_if_conditions>'
                '<single_if_condition>'
            )

    @tatsumasu('SingleIf')
    @nomemo
    def _single_if_condition_(self):  # noqa
        with self._choice():
            with self._option():
                self._expression_()
                self.name_last_node('stat')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._IF_()

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._if_condition_()
                self.name_last_node('cond')

                self._define(
                    ['cond', 'stat'],
                    []
                )
            with self._option():
                self._if_condition_()
                self.name_last_node('cond')

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._token(':')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._expression_()
                self.name_last_node('stat')

                self._define(
                    ['cond', 'stat'],
                    []
                )
            self._error(
                'expecting one of: '
                "'-' <add_sub_operator> <addition>"
                '<and_condition> <expression>'
                '<if_condition> <subtraction> <term>'
            )

    @tatsumasu('MatrixRows')
    @leftrec
    def _rows_(self):  # noqa
        with self._choice():
            with self._option():
                self._rows_()
                self.name_last_node('rs')

                def block2():
                    self._separator_with_space_()
                self._positive_closure(block2)
                self._row_()
                self.name_last_node('r')

                def block4():
                    self._hspace_()
                self._closure(block4)

                self._define(
                    ['r', 'rs'],
                    []
                )
            with self._option():
                self._rows_()
                self.name_last_node('rs')

                def block6():
                    self._separator_with_space_()
                self._positive_closure(block6)

                self._define(
                    ['rs'],
                    []
                )
            with self._option():
                self._row_()
                self.name_last_node('r')

                def block8():
                    self._hspace_()
                self._closure(block8)

                self._define(
                    ['r'],
                    []
                )
            self._error(
                'expecting one of: '
                "'|' <expr_in_matrix> <row>"
                '<row_with_commas> <rows>'
            )

    @tatsumasu('MatrixRow')
    @nomemo
    def _row_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('|')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._row_()
                self.add_last_node_to_name('value')

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._token('|')

                self._define(
                    [],
                    ['value']
                )
            with self._option():
                self._row_with_commas_()
                self.name_last_node('rc')

                def block5():
                    self._hspace_()
                self._closure(block5)
                self._expr_in_matrix_()
                self.name_last_node('exp')

                self._define(
                    ['exp', 'rc'],
                    []
                )
            with self._option():
                self._row_with_commas_()
                self.name_last_node('rc')
            with self._option():
                self._expr_in_matrix_()
                self.name_last_node('exp')
            self._error(
                'expecting one of: '
                "'-' '|' <addition_in_matrix>"
                '<expr_in_matrix> <hspace>'
                '<row_with_commas>'
                '<subtraction_in_matrix> <term_in_matrix>'
            )

    @tatsumasu('MatrixRowCommas')
    @leftrec
    def _row_with_commas_(self):  # noqa
        with self._choice():
            with self._option():
                self._row_with_commas_()
                self.name_last_node('value')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._expr_in_matrix_()
                self.name_last_node('exp')
                with self._group():
                    with self._choice():
                        with self._option():

                            def block5():
                                self._hspace_()
                            self._closure(block5)
                            self._token(',')
                        with self._option():

                            def block6():
                                self._hspace_()
                            self._positive_closure(block6)
                        self._error(
                            'expecting one of: '
                            "',' <hspace>"
                        )

                self._define(
                    ['exp', 'value'],
                    []
                )
            with self._option():

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._expr_in_matrix_()
                self.name_last_node('exp')
                with self._group():
                    with self._choice():
                        with self._option():

                            def block10():
                                self._hspace_()
                            self._closure(block10)
                            self._token(',')
                        with self._option():

                            def block11():
                                self._hspace_()
                            self._positive_closure(block11)
                        self._error(
                            'expecting one of: '
                            "',' <hspace>"
                        )

                self._define(
                    ['exp'],
                    []
                )
            self._error(
                'expecting one of: '
                "'-' <addition_in_matrix>"
                '<expr_in_matrix> <hspace>'
                '<row_with_commas>'
                '<subtraction_in_matrix> <term_in_matrix>'
                '[ \\t]'
            )

    @tatsumasu('ExpInMatrix')
    @leftrec
    def _expr_in_matrix_(self):  # noqa
        with self._choice():
            with self._option():
                self._addition_in_matrix_()
                self.name_last_node('value')
            with self._option():
                self._subtraction_in_matrix_()
                self.name_last_node('value')
            with self._option():
                with self._optional():
                    self._token('-')
                self.name_last_node('sign')
                self._term_in_matrix_()
                self.name_last_node('value')

                self._define(
                    ['sign', 'value'],
                    []
                )
            self._error(
                'expecting one of: '
                "'-' <addition_in_matrix>"
                '<division_in_matrix> <expr_in_matrix>'
                '<factor_in_matrix>'
                '<multiplication_in_matrix>'
                '<subtraction_in_matrix> <term_in_matrix>'
            )

    @tatsumasu('Add')
    @nomemo
    def _addition_in_matrix_(self):  # noqa
        self._expr_in_matrix_()
        self.name_last_node('left')
        self._token('+')
        self.name_last_node('op')
        self._term_in_matrix_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('Subtract')
    @nomemo
    def _subtraction_in_matrix_(self):  # noqa
        self._expr_in_matrix_()
        self.name_last_node('left')
        self._token('-')
        self.name_last_node('op')
        self._term_in_matrix_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    @leftrec
    def _term_in_matrix_(self):  # noqa
        with self._choice():
            with self._option():
                self._multiplication_in_matrix_()
            with self._option():
                self._division_in_matrix_()
            with self._option():
                self._factor_in_matrix_()
            self._error(
                'expecting one of: '
                "'(' '.' '0' '1' '[' '{' '‚é°' 'ùüô'"
                '<constant> <digit> <division_in_matrix>'
                '<double> <factor_in_matrix>'
                '<floating_point> <fraction> <identifier>'
                '<integer> <mantissa> <matrix>'
                '<multiplication_in_matrix> <number>'
                '<number_matrix> <operations_in_matrix>'
                '<set> <subexpression> <term_in_matrix>'
                '<vector> [01\\u1D7D9]'
                '[\\u00BC-\\u00BE\\u2150-\\u215E]'
            )

    @tatsumasu('Multiply')
    @nomemo
    def _multiplication_in_matrix_(self):  # noqa
        with self._choice():
            with self._option():
                self._term_in_matrix_()
                self.name_last_node('left')
                self._token('‚ãÖ')
                self.name_last_node('op')
                self._factor_in_matrix_()
                self.name_last_node('right')

                self._define(
                    ['left', 'op', 'right'],
                    []
                )
            with self._option():
                self._term_in_matrix_()
                self.name_last_node('left')
                self._factor_in_matrix_()
                self.name_last_node('right')

                self._define(
                    ['left', 'right'],
                    []
                )
            self._error(
                'expecting one of: '
                "'(' '.' '0' '1' '[' '{' '‚é°' 'ùüô'"
                '<constant> <digit> <division_in_matrix>'
                '<double> <factor_in_matrix>'
                '<floating_point> <fraction> <identifier>'
                '<integer> <mantissa> <matrix>'
                '<multiplication_in_matrix> <number>'
                '<number_matrix> <operations_in_matrix>'
                '<set> <subexpression> <term_in_matrix>'
                '<vector> [01\\u1D7D9]'
                '[\\u00BC-\\u00BE\\u2150-\\u215E]'
            )

    @tatsumasu('Divide')
    @nomemo
    def _division_in_matrix_(self):  # noqa
        self._term_in_matrix_()
        self.name_last_node('left')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/')
                with self._option():
                    self._token('√∑')
                self._error(
                    'expecting one of: '
                    "'/' '√∑'"
                )
        self.name_last_node('op')
        self._factor_in_matrix_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('NumMatrix')
    def _number_matrix_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('0')
                        with self._option():
                            self._token('1')
                        with self._option():
                            self._token('ùüô')
                        self._error(
                            'expecting one of: '
                            "'0' '1' 'ùüô'"
                        )
                self.name_last_node('left')
                self._token('_')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._integer_()
                        with self._option():
                            self._identifier_()
                        self._error(
                            'expecting one of: '
                            '<identifier> <integer>'
                        )
                self.name_last_node('id1')

                def block5():
                    self._token(',')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._integer_()
                            with self._option():
                                self._identifier_()
                            self._error(
                                'expecting one of: '
                                '<identifier> <integer>'
                            )
                    self.name_last_node('id2')

                    self._define(
                        ['id2'],
                        []
                    )
                self._closure(block5)

                self._define(
                    ['id1', 'id2', 'left'],
                    []
                )
            with self._option():
                self._pattern('[01\\u1D7D9]')
                self.name_last_node('left')
                self._sub_integer_()
                self.name_last_node('id1')

                def block10():
                    self._token(',')
                    self._sub_integer_()
                    self.name_last_node('id2')

                    self._define(
                        ['id2'],
                        []
                    )
                self._closure(block10)

                self._define(
                    ['id1', 'id2', 'left'],
                    []
                )
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('0')
                        with self._option():
                            self._token('1')
                        with self._option():
                            self._token('ùüô')
                        self._error(
                            'expecting one of: '
                            "'0' '1' 'ùüô'"
                        )
                self.name_last_node('left')
                self._token('_')
                self._token('(')

                def block14():
                    self._hspace_()
                self._closure(block14)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._integer_()
                        with self._option():
                            self._identifier_()
                        self._error(
                            'expecting one of: '
                            '<identifier> <integer>'
                        )
                self.name_last_node('id1')

                def block17():

                    def block18():
                        self._hspace_()
                    self._closure(block18)
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token(',')
                            with self._option():
                                self._token('√ó')
                            self._error(
                                'expecting one of: '
                                "',' '√ó'"
                            )

                    def block20():
                        self._hspace_()
                    self._closure(block20)
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._integer_()
                            with self._option():
                                self._identifier_()
                            self._error(
                                'expecting one of: '
                                '<identifier> <integer>'
                            )
                    self.name_last_node('id2')

                    self._define(
                        ['id2'],
                        []
                    )
                self._closure(block17)

                def block23():
                    self._hspace_()
                self._closure(block23)
                self._token(')')

                self._define(
                    ['id1', 'id2', 'left'],
                    []
                )
            self._error(
                'expecting one of: '
                "'0' '1' 'ùüô' [01\\u1D7D9]"
            )

    @tatsumasu('Factor')
    @leftrec
    def _factor_in_matrix_(self):  # noqa
        with self._choice():
            with self._option():
                self._operations_in_matrix_()
                self.name_last_node('op')
            with self._option():
                self._subexpression_()
                self.name_last_node('sub')
            with self._option():
                self._number_matrix_()
                self.name_last_node('nm')
            with self._option():
                self._identifier_()
                self.name_last_node('id0')
            with self._option():
                self._number_()
                self.name_last_node('num')
            with self._option():
                self._matrix_()
                self.name_last_node('m')
            with self._option():
                self._vector_()
                self.name_last_node('v')
            with self._option():
                self._set_()
                self.name_last_node('s')
            with self._option():
                self._constant_()
                self.name_last_node('c')
            self._error(
                'expecting one of: '
                "# ' '(' '.' '0' '1' '<' '[' '{' '|' '||'"
                "'‚Äñ' '‚à´' '‚é°' '‚ü®' 'ùüô' <AND> <ARGMAX>"
                '<ARGMIN> <AS> <BUILTIN_KEYWORDS>'
                '<CELLMESH> <DELTA> <DERIVATIVE>'
                '<EDGEMESH> <EDGES> <EDGESET> <EXP>'
                '<FACEMESH> <FACES> <FACESET> <FOR>'
                '<FROM> <GIVEN> <IF> <IN> <INDEX>'
                '<INITIAL> <INT> <KEYWORDS> <LN> <LOG>'
                '<MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <builtin_operators> <constant>'
                '<cross_product_in_matrix_operator>'
                '<digit> <double> <floating_point>'
                '<fraction>'
                '<frobenius_product_in_matrix_operator>'
                '<function_operator>'
                '<hadamard_product_in_matrix_operator>'
                '<identifier> <identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> <infinity>'
                '<inner_product_operator> <integer>'
                '<integral_operator>'
                '<kronecker_product_in_matrix_operator>'
                '<mantissa> <matrix> <norm_operator>'
                '<number> <number_matrix>'
                '<operations_in_matrix> <pi>'
                '<power_in_matrix_operator>'
                '<pseudoinverse_in_matrix_operator> <set>'
                '<solver_in_matrix_operator>'
                '<sqrt_in_matrix_operator>'
                '<subexpression> <sum_in_matrix_operator>'
                '<trans_in_matrix_operator> <vector>'
                'SOLVE Solve [01\\u1D7D9] [Cc]ell[Mm]esh'
                '[Cc]ell[Ss]et [Cc]ellular[Ss]et'
                '[Ee]dge[Mm]esh [Ee]dge[Ss]et'
                '[Ff]ace[Mm]esh [Ff]ace[Ss]et'
                '[Vv]ertex[Ss]et'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] [Œî] \\d and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚àû ‚äÇ ùïï'
            )

    @tatsumasu()
    @nomemo
    def _operations_in_matrix_(self):  # noqa
        with self._choice():
            with self._option():
                self._solver_in_matrix_operator_()
            with self._option():
                self._norm_operator_()
            with self._option():
                self._power_in_matrix_operator_()
            with self._option():
                self._inner_product_operator_()
            with self._option():
                self._frobenius_product_in_matrix_operator_()
            with self._option():
                self._hadamard_product_in_matrix_operator_()
            with self._option():
                self._cross_product_in_matrix_operator_()
            with self._option():
                self._kronecker_product_in_matrix_operator_()
            with self._option():
                self._sum_in_matrix_operator_()
            with self._option():
                self._integral_operator_()
            with self._option():
                self._trans_in_matrix_operator_()
            with self._option():
                self._sqrt_in_matrix_operator_()
            with self._option():
                self._function_operator_()
            with self._option():
                self._builtin_operators_()
            with self._option():
                self._pseudoinverse_in_matrix_operator_()
            self._error(
                'expecting one of: '
                "'(' '.' '0' '1' '<' '[' '{' '|' '||' '‚Äñ'"
                "'‚à´' '‚é°' '‚ü®' 'ùüô' <INT> <INVERSEVEC> <SUM>"
                '<builtin_operators> <constant>'
                '<cross_product_in_matrix_operator>'
                '<digit> <double> <element_convert_func>'
                '<exp_func> <factor_in_matrix>'
                '<floating_point> <fraction>'
                '<frobenius_product_in_matrix_operator>'
                '<func_id> <function_operator>'
                '<hadamard_product_in_matrix_operator>'
                '<identifier> <identifier_alone>'
                '<inner_product_operator> <integer>'
                '<integral_operator>'
                '<kronecker_product_in_matrix_operator>'
                '<ln_func> <log_func> <mantissa> <matrix>'
                '<minmax_func> <norm_operator> <number>'
                '<number_matrix> <operations_in_matrix>'
                '<power_in_matrix_operator>'
                '<predefined_built_operators>'
                '<pseudoinverse_in_matrix_operator> <set>'
                '<solver_in_matrix_operator> <sqrt_func>'
                '<sqrt_in_matrix_operator>'
                '<subexpression> <sum_in_matrix_operator>'
                '<trans_in_matrix_operator> <vector>'
                '[01\\u1D7D9] [\\u00BC-\\u00BE\\u2150-\\u215E]'
                'int inversevec sum vec‚Åª¬π ‚àë ‚àö'
            )

    @tatsumasu('Power')
    @nomemo
    def _power_in_matrix_operator_(self):  # noqa
        with self._choice():
            with self._option():
                self._factor_in_matrix_()
                self.name_last_node('base')
                self._token('^T')
                self.name_last_node('t')

                self._define(
                    ['base', 't'],
                    []
                )
            with self._option():
                self._factor_in_matrix_()
                self.name_last_node('base')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('^(-1)')
                        with self._option():
                            self._token('‚Åª¬π')
                        self._error(
                            'expecting one of: '
                            "'^(-1)' '‚Åª¬π'"
                        )
                self.name_last_node('r')

                self._define(
                    ['base', 'r'],
                    []
                )
            with self._option():
                self._factor_in_matrix_()
                self.name_last_node('base')
                self._token('^')
                self._factor_in_matrix_()
                self.name_last_node('power')

                self._define(
                    ['base', 'power'],
                    []
                )
            with self._option():
                self._factor_in_matrix_()
                self.name_last_node('base')
                self._sup_integer_()
                self.name_last_node('power')

                self._define(
                    ['base', 'power'],
                    []
                )
            self._error(
                'expecting one of: '
                "# ' '(' '.' '0' '1' '<' '[' '{' '|' '||'"
                "'‚Äñ' '‚à´' '‚é°' '‚ü®' 'ùüô' <AND> <ARGMAX>"
                '<ARGMIN> <AS> <BUILTIN_KEYWORDS>'
                '<CELLMESH> <DELTA> <DERIVATIVE>'
                '<EDGEMESH> <EDGES> <EDGESET> <EXP>'
                '<FACEMESH> <FACES> <FACESET> <FOR>'
                '<FROM> <GIVEN> <IF> <IN> <INDEX>'
                '<INITIAL> <INT> <KEYWORDS> <LN> <LOG>'
                '<MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <builtin_operators> <constant>'
                '<cross_product_in_matrix_operator>'
                '<digit> <double> <factor_in_matrix>'
                '<floating_point> <fraction>'
                '<frobenius_product_in_matrix_operator>'
                '<function_operator>'
                '<hadamard_product_in_matrix_operator>'
                '<identifier> <identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> <infinity>'
                '<inner_product_operator> <integer>'
                '<integral_operator>'
                '<kronecker_product_in_matrix_operator>'
                '<mantissa> <matrix> <norm_operator>'
                '<number> <number_matrix>'
                '<operations_in_matrix> <pi>'
                '<power_in_matrix_operator>'
                '<pseudoinverse_in_matrix_operator> <set>'
                '<solver_in_matrix_operator>'
                '<sqrt_in_matrix_operator>'
                '<subexpression> <sum_in_matrix_operator>'
                '<trans_in_matrix_operator> <vector>'
                'SOLVE Solve [01\\u1D7D9] [Cc]ell[Mm]esh'
                '[Cc]ell[Ss]et [Cc]ellular[Ss]et'
                '[Ee]dge[Mm]esh [Ee]dge[Ss]et'
                '[Ff]ace[Mm]esh [Ff]ace[Ss]et'
                '[Vv]ertex[Ss]et'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] [Œî] \\d and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚àû ‚äÇ ùïï'
            )

    @tatsumasu('FroProduct')
    @nomemo
    def _frobenius_product_in_matrix_operator_(self):  # noqa
        self._factor_in_matrix_()
        self.name_last_node('left')
        self._token(':')
        self._factor_in_matrix_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('HadamardProduct')
    @nomemo
    def _hadamard_product_in_matrix_operator_(self):  # noqa
        self._factor_in_matrix_()
        self.name_last_node('left')
        self._token('‚àò')
        self._factor_in_matrix_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('CrossProduct')
    @nomemo
    def _cross_product_in_matrix_operator_(self):  # noqa
        self._factor_in_matrix_()
        self.name_last_node('left')
        self._token('√ó')
        self._factor_in_matrix_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('KroneckerProduct')
    @nomemo
    def _kronecker_product_in_matrix_operator_(self):  # noqa
        self._factor_in_matrix_()
        self.name_last_node('left')
        self._token('‚äó')
        self._factor_in_matrix_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Transpose')
    @nomemo
    def _trans_in_matrix_operator_(self):  # noqa
        self._factor_in_matrix_()
        self.name_last_node('f')
        self._pattern('·µÄ')

        self._define(
            ['f'],
            []
        )

    @tatsumasu('PseudoInverse')
    @nomemo
    def _pseudoinverse_in_matrix_operator_(self):  # noqa
        self._factor_in_matrix_()
        self.name_last_node('f')
        self._pattern('‚Å∫')

        self._define(
            ['f'],
            []
        )

    @tatsumasu('Squareroot')
    def _sqrt_in_matrix_operator_(self):  # noqa
        self._pattern('‚àö')
        self._factor_in_matrix_()
        self.name_last_node('f')

        self._define(
            ['f'],
            []
        )

    @tatsumasu('Solver')
    @nomemo
    def _solver_in_matrix_operator_(self):  # noqa
        with self._choice():
            with self._option():
                self._factor_in_matrix_()
                self.name_last_node('left')
                self._token('\\')
                self._factor_in_matrix_()
                self.name_last_node('right')

                self._define(
                    ['left', 'right'],
                    []
                )
            with self._option():
                self._factor_in_matrix_()
                self.name_last_node('left')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('^(-1)')
                        with self._option():
                            self._token('‚Åª¬π')
                        self._error(
                            'expecting one of: '
                            "'^(-1)' '‚Åª¬π'"
                        )
                self.name_last_node('p')
                self._factor_in_matrix_()
                self.name_last_node('right')

                self._define(
                    ['left', 'p', 'right'],
                    []
                )
            self._error(
                'expecting one of: '
                "# ' '(' '.' '0' '1' '<' '[' '{' '|' '||'"
                "'‚Äñ' '‚à´' '‚é°' '‚ü®' 'ùüô' <AND> <ARGMAX>"
                '<ARGMIN> <AS> <BUILTIN_KEYWORDS>'
                '<CELLMESH> <DELTA> <DERIVATIVE>'
                '<EDGEMESH> <EDGES> <EDGESET> <EXP>'
                '<FACEMESH> <FACES> <FACESET> <FOR>'
                '<FROM> <GIVEN> <IF> <IN> <INDEX>'
                '<INITIAL> <INT> <KEYWORDS> <LN> <LOG>'
                '<MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <builtin_operators> <constant>'
                '<cross_product_in_matrix_operator>'
                '<digit> <double> <factor_in_matrix>'
                '<floating_point> <fraction>'
                '<frobenius_product_in_matrix_operator>'
                '<function_operator>'
                '<hadamard_product_in_matrix_operator>'
                '<identifier> <identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> <infinity>'
                '<inner_product_operator> <integer>'
                '<integral_operator>'
                '<kronecker_product_in_matrix_operator>'
                '<mantissa> <matrix> <norm_operator>'
                '<number> <number_matrix>'
                '<operations_in_matrix> <pi>'
                '<power_in_matrix_operator>'
                '<pseudoinverse_in_matrix_operator> <set>'
                '<solver_in_matrix_operator>'
                '<sqrt_in_matrix_operator>'
                '<subexpression> <sum_in_matrix_operator>'
                '<trans_in_matrix_operator> <vector>'
                'SOLVE Solve [01\\u1D7D9] [Cc]ell[Mm]esh'
                '[Cc]ell[Ss]et [Cc]ellular[Ss]et'
                '[Ee]dge[Mm]esh [Ee]dge[Ss]et'
                '[Ff]ace[Mm]esh [Ff]ace[Ss]et'
                '[Vv]ertex[Ss]et'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] [Œî] \\d and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚àû ‚äÇ ùïï'
            )

    @tatsumasu('Summation')
    def _sum_in_matrix_operator_(self):  # noqa
        with self._choice():
            with self._option():
                self._SUM_()
                self._token('_')
                self._identifier_alone_()
                self.name_last_node('sub')
                with self._if():
                    self._token('(')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._term_in_matrix_()
                self.name_last_node('exp')

                self._define(
                    ['exp', 'sub'],
                    []
                )
            with self._option():
                self._SUM_()
                self._token('_(')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._identifier_alone_()
                self.name_last_node('id')

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._token('for')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._if_condition_()
                self.name_last_node('cond')

                def block9():
                    self._hspace_()
                self._closure(block9)
                self._token(')')
                self._term_in_matrix_()
                self.name_last_node('exp')

                self._define(
                    ['cond', 'exp', 'id'],
                    []
                )
            with self._option():
                self._SUM_()
                self._token('_(')

                def block11():
                    self._hspace_()
                self._closure(block11)
                self._identifier_alone_()
                self.add_last_node_to_name('enum')

                def block13():

                    def block14():
                        self._hspace_()
                    self._closure(block14)
                    self._token(',')

                    def block15():
                        self._hspace_()
                    self._closure(block15)
                    self._identifier_alone_()
                    self.add_last_node_to_name('enum')

                    self._define(
                        [],
                        ['enum']
                    )
                self._closure(block13)

                def block17():
                    self._hspace_()
                self._closure(block17)
                self._IN_()

                def block18():
                    self._hspace_()
                self._closure(block18)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._function_operator_()
                        with self._option():
                            self._identifier_alone_()
                        self._error(
                            'expecting one of: '
                            '<function_operator> <identifier_alone>'
                        )
                self.name_last_node('range')

                def block21():
                    self._hspace_()
                self._closure(block21)
                self._token(')')
                self._term_()
                self.name_last_node('exp')

                self._define(
                    ['exp', 'range'],
                    ['enum']
                )
            self._error(
                'expecting one of: '
                '<SUM> sum ‚àë'
            )

    @tatsumasu()
    def _hspace_(self):  # noqa
        self._pattern('[ \\t]')

    @tatsumasu()
    def _line_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('\n')
            with self._option():
                self._token('\r')
            with self._option():
                self._token('\x0c')
            self._error(
                'expecting one of: '
                "'\\n' '\\r' '\\x0c'"
            )

    @tatsumasu()
    def _lines_(self):  # noqa

        def block0():
            self._line_()
        self._positive_closure(block0)

    @tatsumasu('IdentifierSubscript')
    def _identifier_with_subscript_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    self._token('_')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._integer_()
                            with self._option():
                                self._token('*')
                            with self._option():
                                self._identifier_alone_()
                            self._error(
                                'expecting one of: '
                                "'*' <identifier_alone> <integer>"
                            )
                    self.add_last_node_to_name('right')

                    def block4():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            with self._option():
                                with self._group():

                                    def block7():
                                        self._token(',')
                                    self._closure(block7)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._integer_()
                                            with self._option():
                                                self._identifier_alone_()
                                            self._error(
                                                'expecting one of: '
                                                '<identifier_alone> <integer>'
                                            )
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <identifier_alone> <integer>"
                            )
                    self._closure(block4)

                    self._define(
                        ['left'],
                        ['right']
                    )
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    self._token('_(')
                    self.name_last_node('p')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._integer_()
                            with self._option():
                                self._token('*')
                            with self._option():
                                self._identifier_alone_()
                            self._error(
                                'expecting one of: '
                                "'*' <identifier_alone> <integer>"
                            )
                    self.add_last_node_to_name('right')

                    def block14():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            with self._option():
                                with self._group():

                                    def block17():
                                        self._token(',')
                                    self._closure(block17)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._integer_()
                                            with self._option():
                                                self._identifier_alone_()
                                            self._error(
                                                'expecting one of: '
                                                '<identifier_alone> <integer>'
                                            )
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <identifier_alone> <integer>"
                            )
                    self._closure(block14)
                    self._token(')')

                    self._define(
                        ['left', 'p'],
                        ['right']
                    )
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._sub_integer_()
                            with self._option():
                                self._unicode_subscript_()
                            self._error(
                                'expecting one of: '
                                '<sub_integer> <unicode_subscript>'
                            )
                    self.add_last_node_to_name('right')

                    def block23():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            with self._option():
                                with self._group():

                                    def block26():
                                        self._token(',')
                                    self._closure(block26)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._sub_integer_()
                                            with self._option():
                                                self._unicode_subscript_()
                                            self._error(
                                                'expecting one of: '
                                                '<sub_integer> <unicode_subscript>'
                                            )
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <sub_integer> <unicode_subscript>"
                            )
                    self._closure(block23)

                    self._define(
                        ['left'],
                        ['right']
                    )
            with self._option():
                with self._group():
                    self._identifier_alone_()
                    self.name_last_node('left')
                    self._token('_(')
                    self.name_last_node('p')

                    def block31():
                        self._hspace_()
                    self._closure(block31)
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('*')
                            with self._option():
                                self._expression_()
                            self._error(
                                'expecting one of: '
                                "'*' <expression>"
                            )
                    self.add_last_node_to_name('exp')

                    def block34():
                        with self._choice():
                            with self._option():
                                with self._group():

                                    def block36():
                                        self._hspace_()
                                    self._closure(block36)
                                    self._token(',')

                                    def block37():
                                        self._hspace_()
                                    self._closure(block37)
                                    self._token('*')
                                    self.add_last_node_to_name('exp')

                                    self._define(
                                        [],
                                        ['exp']
                                    )
                            with self._option():
                                with self._group():

                                    def block39():
                                        self._hspace_()
                                    self._closure(block39)
                                    self._token(',')

                                    def block40():
                                        self._hspace_()
                                    self._closure(block40)
                                    self._expression_()
                                    self.add_last_node_to_name('exp')

                                    self._define(
                                        [],
                                        ['exp']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <hspace>"
                            )
                    self._closure(block34)

                    def block42():
                        self._hspace_()
                    self._closure(block42)
                    self._token(')')

                    self._define(
                        ['left', 'p'],
                        ['exp']
                    )
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <identifier_alone> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu('IdentifierSubscript')
    def _identifier_with_unicode_subscript_(self):  # noqa
        self._identifier_alone_()
        self.name_last_node('left')
        with self._group():
            with self._choice():
                with self._option():
                    self._sub_integer_()
                with self._option():
                    self._unicode_subscript_()
                self._error(
                    'expecting one of: '
                    '<sub_integer> <unicode_subscript>'
                )
        self.add_last_node_to_name('right')

        def block3():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token(',')
                        self._token('*')
                        self.add_last_node_to_name('right')

                        self._define(
                            [],
                            ['right']
                        )
                with self._option():
                    with self._group():

                        def block6():
                            self._token(',')
                        self._closure(block6)
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._sub_integer_()
                                with self._option():
                                    self._unicode_subscript_()
                                self._error(
                                    'expecting one of: '
                                    '<sub_integer> <unicode_subscript>'
                                )
                        self.add_last_node_to_name('right')

                        self._define(
                            [],
                            ['right']
                        )
                self._error(
                    'expecting one of: '
                    "',' <sub_integer> <unicode_subscript>"
                )
        self._closure(block3)

        self._define(
            ['left'],
            ['right']
        )

    @tatsumasu('IdentifierAlone')
    def _unicode_subscript_(self):  # noqa
        self._pattern('[\\u2090-\\u209C\\u1D62\\u2C7C]')
        self.name_last_node('value')

    @tatsumasu('IdentifierAlone')
    def _unicode_superscript_(self):  # noqa
        self._pattern('[\\u1D43\\u1D47\\u1D9C\\u1D48\\u1D49\\u1DA0\\u1D4D\\u02B0\\u2071\\u02B2\\u1D4F\\u02E1\\u1D50\\u207F\\u1D52\\u1D56\\u02B3\\u02E2\\u1D57\\u1D58\\u1D5B\\u02B7\\u02E3\\u02B8\\u1DBB\\u1DA6\\u1DAB\\u1DB0\\u1DB8\\u1D2C\\u1D2E\\u1D30\\u1D31\\u1D33\\u1D34\\u1D35\\u1D36\\u1D37\\u1D38\\u1D39\\u1D3A\\u1D3C\\u1D3E\\u1D3F\\u1D40\\u1D41\\u2C7D\\u1D42]')
        self.name_last_node('value')

    @tatsumasu('SizeOp')
    def _size_op_(self):  # noqa
        self._POUND_()
        self._identifier_()
        self.name_last_node('i')

        self._define(
            ['i'],
            []
        )

    @tatsumasu()
    def _keyword_str_(self):  # noqa
        self._pattern('[A-Za-z][A-Za-z0-9]*')

    @tatsumasu('IdentifierAlone')
    def _multi_str_(self):  # noqa
        with self._choice():
            with self._option():
                with self._ifnot():
                    self._KEYWORDS_()
                with self._group():
                    with self._choice():
                        with self._option():
                            with self._group():
                                self._pattern('[A-Za-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:[‚Åª¬πA-Z0-9a-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*')
                            self.name_last_node('value')
                        with self._option():
                            self._token('`')
                            self._pattern('[^`]*')
                            self.name_last_node('id')
                            self._token('`')

                            self._define(
                                ['id'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'`' [A-Za-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:"
                            '[‚Åª¬πA-Z0-9a-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*'
                        )

                self._define(
                    ['id', 'value'],
                    []
                )
            with self._option():
                with self._group():
                    self._PREFIX_KEYWORD_()
                    with self._group():
                        self._pattern('[A-Za-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:[‚Åª¬πA-Z0-9a-z_\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*')
                self.name_last_node('value')
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> SOLVE Solve [Cc]ell[Mm]esh'
                '[Cc]ell[Ss]et [Cc]ellular[Ss]et'
                '[Ee]dge[Mm]esh [Ee]dge[Ss]et'
                '[Ff]ace[Mm]esh [Ff]ace[Ss]et'
                '[Vv]ertex[Ss]et [Œî] and argmax argmin as'
                'cells edges exp faces for from given if'
                'index initial int ln log matrix max min'
                'or otherwise s.t. scalar sequence solve'
                'sparse sqrt subject to sum tuple vector'
                'vertices where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu()
    def _description_(self):  # noqa
        self._pattern('[^;\\n\\r\\f]*')

    @tatsumasu()
    def _desc_identifier_(self):  # noqa
        with self._ifnot():
            self._KEYWORDS_()
        self._token('`')
        self._pattern('[A-Za-z][[A-Za-z0-9]*')
        self._token('`')

    @tatsumasu()
    def _separator_(self):  # noqa
        with self._choice():
            with self._option():
                self._line_()
            with self._option():
                self._token(';')
            self._error(
                'expecting one of: '
                "';' '\\n' '\\r' '\\x0c' <line>"
            )

    @tatsumasu()
    def _separator_with_space_(self):  # noqa

        def block0():
            self._hspace_()
        self._closure(block0)
        self._separator_()

        def block1():
            self._hspace_()
        self._closure(block1)

    @tatsumasu()
    def _blank_(self):  # noqa

        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._hspace_()
                    with self._option():
                        self._separator_()
                    self._error(
                        'expecting one of: '
                        '<hspace> <separator>'
                    )
        self._closure(block0)

    @tatsumasu()
    def _params_separator_(self):  # noqa
        self._pattern('[,;x\\u00D7]')

    @tatsumasu('Pi')
    def _pi_(self):  # noqa
        self._pattern('œÄ')

    @tatsumasu('Infinity')
    def _infinity_(self):  # noqa
        self._pattern('‚àû')

    @tatsumasu('E')
    def _e_(self):  # noqa
        self._pattern('e')

    @tatsumasu('SinFunc')
    def _sin_func_(self):  # noqa
        self._SIN_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('AsinFunc')
    def _asin_func_(self):  # noqa
        self._ASIN_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('AsinFunc')
    def _arcsin_func_(self):  # noqa
        self._ARCSIN_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('CosFunc')
    def _cos_func_(self):  # noqa
        self._COS_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('AcosFunc')
    def _acos_func_(self):  # noqa
        self._ACOS_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('AcosFunc')
    def _arccos_func_(self):  # noqa
        self._ARCCOS_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('TanFunc')
    def _tan_func_(self):  # noqa
        self._TAN_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('AtanFunc')
    def _atan_func_(self):  # noqa
        self._ATAN_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('AtanFunc')
    def _arctan_func_(self):  # noqa
        self._ARCTAN_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('SinhFunc')
    def _sinh_func_(self):  # noqa
        self._SINH_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('AsinhFunc')
    def _asinh_func_(self):  # noqa
        self._ASINH_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('AsinhFunc')
    def _arsinh_func_(self):  # noqa
        self._ARSINH_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('CoshFunc')
    def _cosh_func_(self):  # noqa
        self._COSH_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('AcoshFunc')
    def _acosh_func_(self):  # noqa
        self._ACOSH_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('AcoshFunc')
    def _arcosh_func_(self):  # noqa
        self._ARCOSH_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('TanhFunc')
    def _tanh_func_(self):  # noqa
        self._TANH_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('AtanhFunc')
    def _atanh_func_(self):  # noqa
        self._ATANH_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('AtanhFunc')
    def _artanh_func_(self):  # noqa
        self._ARTANH_()
        self.name_last_node('name')

        def block1():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block1)
        self._token('(')

        def block5():
            self._hspace_()
        self._closure(block5)
        self._expression_()
        self.name_last_node('param')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['name', 'param', 'power'],
            []
        )

    @tatsumasu('CotFunc')
    def _cot_func_(self):  # noqa
        self._COT_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('SecFunc')
    def _sec_func_(self):  # noqa
        self._SEC_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('CscFunc')
    def _csc_func_(self):  # noqa
        self._CSC_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('^')
                        self._integer_()
                        self.name_last_node('power')

                        self._define(
                            ['power'],
                            []
                        )
                with self._option():
                    self._sup_integer_()
                    self.name_last_node('power')
                self._error(
                    'expecting one of: '
                    "'^' <sup_integer>"
                )
        self._closure(block0)
        self._token('(')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('param')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'power'],
            []
        )

    @tatsumasu('Atan2Func')
    def _atan2_func_(self):  # noqa
        self._ATAN2_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._params_separator_()
        self.name_last_node('separator')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('second')

        def block6():
            self._hspace_()
        self._closure(block6)
        self._token(')')

        self._define(
            ['param', 'second', 'separator'],
            []
        )

    @tatsumasu('TraceFunc')
    def _trace_func_(self):  # noqa
        self._TRACE_()
        self.name_last_node('name')
        self._token('(')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._expression_()
        self.name_last_node('param')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._token(')')

        self._define(
            ['name', 'param'],
            []
        )

    @tatsumasu('TraceFunc')
    def _tr_func_(self):  # noqa
        self._TR_()
        self.name_last_node('name')
        self._token('(')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._expression_()
        self.name_last_node('param')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._token(')')

        self._define(
            ['name', 'param'],
            []
        )

    @tatsumasu('DiagFunc')
    def _diag_func_(self):  # noqa
        self._DIAG_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():

            def block3():
                self._hspace_()
            self._closure(block3)
            self._params_separator_()
            self.name_last_node('separator')

            def block5():
                self._hspace_()
            self._closure(block5)
            self._expression_()
            self.add_last_node_to_name('extra')

            self._define(
                ['separator'],
                ['extra']
            )
        self._closure(block2)

        def block7():
            self._hspace_()
        self._closure(block7)
        self._token(')')

        self._define(
            ['param', 'separator'],
            ['extra']
        )

    @tatsumasu('VecFunc')
    def _vec_func_(self):  # noqa
        self._VEC_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('InverseVecFunc')
    def _inversevec_func_(self):  # noqa
        with self._choice():
            with self._option():
                self._INVERSEVEC_()
                self.name_last_node('name')
                self._token('(')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._expression_()
                self.name_last_node('origin')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._params_separator_()
                self.name_last_node('separator')

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._expression_()
                self.name_last_node('param')

                def block8():
                    self._hspace_()
                self._closure(block8)
                self._token(')')

                self._define(
                    ['name', 'origin', 'param', 'separator'],
                    []
                )
            with self._option():
                self._INVERSEVEC_()
                self.name_last_node('name')
                self._token('_')
                self.name_last_node('s')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._integer_()
                        with self._option():
                            self._identifier_alone_()
                        self._error(
                            'expecting one of: '
                            '<identifier_alone> <integer>'
                        )
                self.name_last_node('origin')
                self._token('(')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._expression_()
                self.name_last_node('param')

                def block15():
                    self._hspace_()
                self._closure(block15)
                self._token(')')

                self._define(
                    ['name', 'origin', 'param', 's'],
                    []
                )
            self._error(
                'expecting one of: '
                '<INVERSEVEC> inversevec vec‚Åª¬π'
            )

    @tatsumasu('DetFunc')
    def _det_func_(self):  # noqa
        self._DET_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('RankFunc')
    def _rank_func_(self):  # noqa
        self._RANK_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('NullFunc')
    def _null_func_(self):  # noqa
        self._NULL_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('OrthFunc')
    def _orth_func_(self):  # noqa
        self._ORTH_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('InvFunc')
    def _inv_func_(self):  # noqa
        self._INV_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu('SvdFunc')
    def _svd_func_(self):  # noqa
        self._SVD_()
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('param')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['param'],
            []
        )

    @tatsumasu()
    def _Directive_(self):  # noqa
        self._import_()

    @tatsumasu('Import')
    def _import_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._import_var_()
                    self.add_last_node_to_name('names')

                    def block2():

                        def block3():
                            self._hspace_()
                        self._closure(block3)
                        self._token(',')

                        def block4():
                            self._hspace_()
                        self._closure(block4)
                        self._import_var_()
                        self.add_last_node_to_name('names')

                        self._define(
                            [],
                            ['names']
                        )
                    self._closure(block2)

                    self._define(
                        [],
                        ['names']
                    )
                with self._option():
                    self._token('*')
                    self.name_last_node('star')
                self._error(
                    'expecting one of: '
                    "'*' <import_var>"
                )

        def block7():
            self._hspace_()
        self._closure(block7)
        self._FROM_()

        def block8():
            self._hspace_()
        self._positive_closure(block8)
        self._multi_str_()
        self.name_last_node('package')

        def block10():
            self._hspace_()
        self._closure(block10)

        def block11():
            self._token('(')

            def block12():

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._identifier_alone_()
                self.add_last_node_to_name('params')

                def block15():

                    def block16():
                        self._hspace_()
                    self._closure(block16)
                    self._params_separator_()
                    self.add_last_node_to_name('separators')

                    def block18():
                        self._hspace_()
                    self._closure(block18)
                    self._identifier_alone_()
                    self.add_last_node_to_name('params')

                    self._define(
                        [],
                        ['params', 'separators']
                    )
                self._closure(block15)

                self._define(
                    [],
                    ['params', 'separators']
                )
            self._closure(block12)

            def block20():
                self._hspace_()
            self._closure(block20)
            self._token(')')

            self._define(
                [],
                ['params', 'separators']
            )
        self._closure(block11)

        def block21():
            self._hspace_()
        self._closure(block21)

        self._define(
            ['package', 'star'],
            ['names', 'params', 'separators']
        )

    @tatsumasu('ImportVar')
    def _import_var_(self):  # noqa
        self._multi_str_()
        self.name_last_node('name')

        def block1():

            def block2():
                self._hspace_()
            self._positive_closure(block2)
            self._AS_()

            def block3():
                self._hspace_()
            self._positive_closure(block3)
            self._multi_str_()
            self.name_last_node('r')

            self._define(
                ['r'],
                []
            )
        self._closure(block1)

        self._define(
            ['name', 'r'],
            []
        )

    @tatsumasu('WhereConditions')
    def _where_conditions_(self):  # noqa

        def block0():
            self._hspace_()
        self._closure(block0)
        self._where_condition_()
        self.add_last_node_to_name('value')

        def block2():

            def block3():
                self._separator_with_space_()
            self._positive_closure(block3)
            self._where_condition_()
            self.add_last_node_to_name('value')

            self._define(
                [],
                ['value']
            )
        self._closure(block2)

        self._define(
            [],
            ['value']
        )

    @tatsumasu()
    def _where_condition_(self):  # noqa
        self._la_where_condition_()

    @tatsumasu()
    def _attribute_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('index')
            with self._option():
                self._pattern('vertices')
            with self._option():
                self._pattern('edges')
            with self._option():
                self._pattern('faces')
            with self._option():
                self._pattern('tets')
            self._error(
                'expecting one of: '
                'edges faces index tets vertices'
            )

    @tatsumasu('WhereCondition')
    def _la_where_condition_(self):  # noqa
        self._identifier_()
        self.add_last_node_to_name('id')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._identifier_()
            self.add_last_node_to_name('id')

            self._define(
                [],
                ['id']
            )
        self._closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                    self.name_last_node('belong')
                with self._option():
                    self._IN_()
                    self.name_last_node('belong')
                with self._option():
                    self._SUBSET_()
                    self.name_last_node('subset')
                self._error(
                    'expecting one of: '
                    "':' <IN> <SUBSET>"
                )

        def block10():
            self._hspace_()
        self._closure(block10)
        self._la_type_()
        self.name_last_node('type')

        def block12():

            def block13():
                self._hspace_()
            self._closure(block13)
            self._attribute_()
            self.name_last_node('attrib')

            self._define(
                ['attrib'],
                []
            )
        self._closure(block12)

        def block15():

            def block16():
                self._hspace_()
            self._closure(block16)
            self._token(':')

            def block17():
                self._hspace_()
            self._closure(block17)
            self._description_()
            self.name_last_node('desc')

            self._define(
                ['desc'],
                []
            )
        self._closure(block15)

        self._define(
            ['attrib', 'belong', 'desc', 'subset', 'type'],
            ['id']
        )

    @tatsumasu('DeWhereCondition')
    def _de_where_condition_(self):  # noqa
        self._identifier_()
        self.add_last_node_to_name('id')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._identifier_()
            self.add_last_node_to_name('id')

            self._define(
                [],
                ['id']
            )
        self._closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        self._SUBSET_()
        self.name_last_node('subset')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._la_type_()
        self.name_last_node('type')

        def block9():

            def block10():
                self._hspace_()
            self._closure(block10)
            self._attribute_()
            self.name_last_node('attrib')

            self._define(
                ['attrib'],
                []
            )
        self._closure(block9)

        def block12():

            def block13():
                self._hspace_()
            self._closure(block13)
            self._token(':')

            def block14():
                self._hspace_()
            self._closure(block14)
            self._description_()
            self.name_last_node('desc')

            self._define(
                ['desc'],
                []
            )
        self._closure(block12)

        self._define(
            ['attrib', 'desc', 'subset', 'type'],
            ['id']
        )

    @tatsumasu('WhereCondition')
    def _where_condition_terse_(self):  # noqa
        self._identifier_()
        self.add_last_node_to_name('id')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._identifier_()
            self.add_last_node_to_name('id')

            self._define(
                [],
                ['id']
            )
        self._closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                with self._option():
                    self._IN_()
                with self._option():
                    self._SUBSET_()
                    self.name_last_node('subset')
                self._error(
                    'expecting one of: '
                    "':' <IN> <SUBSET>"
                )

        def block8():
            self._hspace_()
        self._closure(block8)
        self._la_type_()
        self.name_last_node('type')

        def block10():

            def block11():
                self._hspace_()
            self._closure(block11)
            self._attribute_()
            self.name_last_node('attrib')

            self._define(
                ['attrib'],
                []
            )
        self._closure(block10)

        self._define(
            ['attrib', 'subset', 'type'],
            ['id']
        )

    @tatsumasu()
    @nomemo
    def _valid_block_(self):  # noqa
        with self._choice():
            with self._option():
                self._Directive_()
            with self._option():
                self._params_block_()
            with self._option():
                self._statements_()
            self._error(
                'expecting one of: '
                "'*' <Directive> <GIVEN> <WHERE> <hspace>"
                '<import> <import_var> <params_block>'
                '<statement> <statements>'
                '<where_condition> <where_conditions> ['
                '\\t] given where'
            )

    @tatsumasu('ParamsBlock')
    def _params_block_(self):  # noqa

        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._WHERE_()
                    with self._option():
                        self._GIVEN_()
                    self._error(
                        'expecting one of: '
                        '<GIVEN> <WHERE>'
                    )
            self.name_last_node('annotation')

            def block3():
                self._separator_with_space_()
            self._positive_closure(block3)

            self._define(
                ['annotation'],
                []
            )
        self._closure(block0)
        self._where_conditions_()
        self.name_last_node('conds')

        self._define(
            ['annotation', 'conds'],
            []
        )

    @tatsumasu()
    def _builtin_operators_(self):  # noqa
        self._predefined_built_operators_()

    @tatsumasu('Statements')
    @nomemo
    def _statements_(self):  # noqa
        self._statement_()
        self.name_last_node('stat')

    @tatsumasu()
    @nomemo
    def _statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._local_func_()
            with self._option():
                self._destructure_()
            with self._option():
                self._assignment_()
            with self._option():
                self._right_hand_side_()
            self._error(
                'expecting one of: '
                "# ' '-' 'with' '{' <AND> <ARGMAX>"
                '<ARGMIN> <AS> <BUILTIN_KEYWORDS>'
                '<CELLMESH> <DELTA> <DERIVATIVE>'
                '<EDGEMESH> <EDGES> <EDGESET> <EXP>'
                '<FACEMESH> <FACES> <FACESET> <FOR>'
                '<FROM> <GIVEN> <IF> <IN> <INDEX>'
                '<INITIAL> <INT> <KEYWORDS> <LN> <LOG>'
                '<MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <add_sub_operator> <addition>'
                '<assignment> <destructure> <expression>'
                '<identifier> <identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> <local_func>'
                '<multi_cond_expr> <optimize_operator>'
                '<right_hand_side> <subtraction> <term>'
                'SOLVE Solve [Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu('Expression')
    @leftrec
    def _expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._addition_()
                self.name_last_node('value')
            with self._option():
                self._subtraction_()
                self.name_last_node('value')
            with self._option():
                self._add_sub_operator_()
                self.name_last_node('value')
            with self._option():
                with self._optional():
                    self._token('-')
                self.name_last_node('sign')
                self._term_()
                self.name_last_node('value')

                self._define(
                    ['sign', 'value'],
                    []
                )
            self._error(
                'expecting one of: '
                "'-' <add_sub_operator> <addition>"
                '<division> <expression> <factor>'
                '<multiplication> <subtraction> <term>'
            )

    @tatsumasu('Destructure')
    def _destructure_(self):  # noqa
        self._identifier_alone_()
        self.add_last_node_to_name('left')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._identifier_alone_()
            self.add_last_node_to_name('left')

            self._define(
                [],
                ['left']
            )
        self._positive_closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        self._token('=')
        self.name_last_node('op')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._simplified_right_hand_side_()
        self.add_last_node_to_name('right')

        self._define(
            ['op'],
            ['left', 'right']
        )

    @tatsumasu('Assignment')
    def _assignment_(self):  # noqa
        with self._choice():
            with self._option():
                self._identifier_()
                self.add_last_node_to_name('left')

                def block2():

                    def block3():
                        self._hspace_()
                    self._closure(block3)
                    self._token(',')

                    def block4():
                        self._hspace_()
                    self._closure(block4)
                    self._identifier_()
                    self.add_last_node_to_name('left')

                    self._define(
                        [],
                        ['left']
                    )
                self._closure(block2)

                def block6():
                    self._hspace_()
                self._closure(block6)
                self._token('=')
                self.name_last_node('op')

                def block8():
                    self._hspace_()
                self._closure(block8)
                self._right_hand_side_()
                self.add_last_node_to_name('right')

                self._define(
                    ['op'],
                    ['left', 'right']
                )
            with self._option():
                self._identifier_()
                self.add_last_node_to_name('left')

                def block11():

                    def block12():
                        self._hspace_()
                    self._closure(block12)
                    self._token(',')

                    def block13():
                        self._hspace_()
                    self._closure(block13)
                    self._identifier_()
                    self.add_last_node_to_name('left')

                    self._define(
                        [],
                        ['left']
                    )
                self._closure(block11)

                def block15():
                    self._hspace_()
                self._closure(block15)
                self._token('+=')
                self.name_last_node('op')

                def block17():
                    self._hspace_()
                self._closure(block17)
                self._right_hand_side_()
                self.add_last_node_to_name('right')

                self._define(
                    ['op'],
                    ['left', 'right']
                )
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <identifier> <identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu()
    def _general_assign_(self):  # noqa
        with self._choice():
            with self._option():
                self._destructure_()
            with self._option():
                self._general_assignment_()
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <destructure>'
                '<general_assignment> <identifier_alone>'
                '<left_hand_side> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu('GeneralAssignment')
    def _general_assignment_(self):  # noqa
        self._left_hand_side_()
        self.add_last_node_to_name('left')

        def block1():

            def block2():
                self._hspace_()
            self._closure(block2)
            self._token(',')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._left_hand_side_()
            self.add_last_node_to_name('left')

            self._define(
                [],
                ['left']
            )
        self._closure(block1)

        def block5():
            self._hspace_()
        self._closure(block5)
        self._token('=')
        self.name_last_node('op')

        def block7():
            self._hspace_()
        self._closure(block7)
        self._right_hand_side_()
        self.add_last_node_to_name('right')

        self._define(
            ['op'],
            ['left', 'right']
        )

    @tatsumasu()
    def _simplified_right_hand_side_(self):  # noqa
        with self._choice():
            with self._option():
                self._expression_()
            with self._option():
                self._multi_cond_expr_()
            self._error(
                'expecting one of: '
                "'-' '{' <add_sub_operator> <addition>"
                '<division> <expression> <factor>'
                '<multi_cond_expr> <multiplication>'
                '<subtraction> <term>'
            )

    @tatsumasu()
    @nomemo
    def _right_hand_side_(self):  # noqa
        with self._choice():
            with self._option():
                self._expression_()
            with self._option():
                self._optimize_operator_()
            with self._option():
                self._multi_cond_expr_()
            self._error(
                'expecting one of: '
                "'-' 'with' '{' <ARGMAX> <ARGMIN> <MAX>"
                '<MIN> <add_sub_operator> <addition>'
                '<division> <expression> <factor>'
                '<multi_cond_expr> <multiplication>'
                '<optimize_operator> <subtraction> <term>'
                'argmax argmin max min'
            )

    @tatsumasu()
    def _left_hand_side_(self):  # noqa
        with self._choice():
            with self._option():
                self._identifier_()
            with self._option():
                self._vector_()
            with self._option():
                self._matrix_()
            self._error(
                'expecting one of: '
                "# ' '(' '[' '‚é°' <AND> <ARGMAX> <ARGMIN>"
                '<AS> <BUILTIN_KEYWORDS> <CELLMESH>'
                '<DELTA> <DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <identifier> <identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> <matrix>'
                '<vector> SOLVE Solve [Cc]ell[Mm]esh'
                '[Cc]ell[Ss]et [Cc]ellular[Ss]et'
                '[Ee]dge[Mm]esh [Ee]dge[Ss]et'
                '[Ff]ace[Mm]esh [Ff]ace[Ss]et'
                '[Vv]ertex[Ss]et [Œî] and argmax argmin as'
                'cells edges exp faces for from given if'
                'index initial int ln log matrix max min'
                'or otherwise s.t. scalar sequence solve'
                'sparse sqrt subject to sum tuple vector'
                'vertices where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu()
    @leftrec
    def _term_(self):  # noqa
        with self._choice():
            with self._option():
                self._multiplication_()
            with self._option():
                self._division_()
            with self._option():
                self._factor_()
            self._error(
                'expecting one of: '
                "'(' '.' '0' '1' '[' '{' '‚é°' 'ùüô'"
                '<builtin_operators> <constant>'
                '<cross_product_operator> <derivative>'
                '<digit> <divergence> <division> <double>'
                '<factor> <floating_point> <fraction>'
                '<frobenius_product_operator>'
                '<function_operator> <gradient>'
                '<hadamard_product_operator> <identifier>'
                '<inner_product_operator> <integer>'
                '<integral_operator>'
                '<kronecker_product_operator> <laplacian>'
                '<mantissa> <matrix> <multiplication>'
                '<norm_operator> <number> <number_matrix>'
                '<operations> <partial> <power_operator>'
                '<pseudoinverse_operator> <set>'
                '<set_operators> <size_op>'
                '<solver_operator> <sqrt_operator>'
                '<subexpression> <sum_operator> <term>'
                '<trans_operator> <vector> [01\\u1D7D9]'
                '[\\u00BC-\\u00BE\\u2150-\\u215E]'
            )

    @tatsumasu('Factor')
    @leftrec
    def _factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._operations_()
                self.name_last_node('op')
            with self._option():
                self._subexpression_()
                self.name_last_node('sub')
            with self._option():
                self._number_matrix_()
                self.name_last_node('nm')
            with self._option():
                self._identifier_()
                self.name_last_node('id0')
            with self._option():
                self._number_()
                self.name_last_node('num')
            with self._option():
                self._matrix_()
                self.name_last_node('m')
            with self._option():
                self._vector_()
                self.name_last_node('v')
            with self._option():
                self._set_()
                self.name_last_node('s')
            with self._option():
                self._constant_()
                self.name_last_node('c')
            self._error(
                'expecting one of: '
                "# ' '(' '.' '0' '1' '<' '[' '{' '|' '||'"
                "'‚Äñ' '‚à™' '‚à´' '‚é°' '‚ü®' 'ùüô' <AND> <ARGMAX>"
                '<ARGMIN> <AS> <BUILTIN_KEYWORDS>'
                '<CELLMESH> <DELTA> <DERIVATIVE>'
                '<EDGEMESH> <EDGES> <EDGESET> <EXP>'
                '<FACEMESH> <FACES> <FACESET> <FOR>'
                '<FROM> <GIVEN> <IF> <IN> <INDEX>'
                '<INITIAL> <INT> <INVERSEVEC> <KEYWORDS>'
                '<LN> <LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PARTIAL> <PI> <POUND> <PREFIX_KEYWORD>'
                '<PRIME> <SCALAR> <SEQUENCE>'
                '<SIMPLICIALSET> <SOLVE> <SPARSE> <SQRT>'
                '<SUBJECT_TO> <SUBSET> <SUM> <TETS>'
                '<TETSET> <TUPLE> <VECTOR> <VERTEXSET>'
                '<VERTICES> <WHERE> <WITH>'
                '<builtin_operators> <constant>'
                '<cross_product_operator> <derivative>'
                '<digit> <divergence> <double>'
                '<element_convert_func> <exp_func>'
                '<factor> <floating_point> <fraction>'
                '<frobenius_product_operator> <func_id>'
                '<function_operator> <gradient>'
                '<hadamard_product_operator> <identifier>'
                '<identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> <infinity>'
                '<inner_product_operator> <integer>'
                '<integral_operator> <intersect_operator>'
                '<kronecker_product_operator> <laplacian>'
                '<ln_func> <log_func> <mantissa> <matrix>'
                '<minmax_func> <norm_operator> <number>'
                '<number_matrix> <operations> <partial>'
                '<pi> <power_operator>'
                '<predefined_built_operators>'
                '<pseudoinverse_operator> <set>'
                '<set_operators> <size_op>'
                '<solver_operator> <sqrt_func>'
                '<sqrt_operator> <subexpression>'
                '<sum_operator> <trans_operator>'
                '<union_operator> <vector> SOLVE Solve'
                '[01\\u1D7D9] [Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] [Œî] \\d and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int'
                'inversevec ln log matrix max min or'
                'otherwise s.t. scalar sequence solve'
                'sparse sqrt subject to sum tuple vector'
                'vec‚Åª¬π vertices where with œÄ ‚Ñù ‚Ñ§ ‚àÇ ‚àá ‚àà ‚àë'
                '‚àö ‚àû ‚äÇ ùïï'
            )

    @tatsumasu()
    def _sub_factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._subexpression_()
            with self._option():
                self._identifier_alone_()
            with self._option():
                self._number_()
            with self._option():
                self._constant_()
            self._error(
                'expecting one of: '
                "# ' '(' '.' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <constant> <digit> <double>'
                '<floating_point> <fraction>'
                '<identifier_alone> <infinity> <integer>'
                '<mantissa> <number> <pi> <subexpression>'
                'SOLVE Solve [Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] [Œî] \\d and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚àû ‚äÇ ùïï'
            )

    @tatsumasu()
    def _constant_(self):  # noqa
        with self._choice():
            with self._option():
                self._pi_()
            with self._option():
                self._infinity_()
            self._error(
                'expecting one of: '
                '<infinity> <pi> œÄ ‚àû'
            )

    @tatsumasu()
    def _KEYWORDS_(self):  # noqa
        self._BUILTIN_KEYWORDS_()

    @tatsumasu('Subexpression')
    def _subexpression_(self):  # noqa
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._expression_()
        self.name_last_node('value')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['value'],
            []
        )

    @tatsumasu('IfCondition')
    @leftrec
    def _if_condition_(self):  # noqa
        with self._choice():
            with self._option():
                self._if_condition_()
                self.name_last_node('se')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._OR_()

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._and_condition_()
                self.name_last_node('other')

                self._define(
                    ['other', 'se'],
                    []
                )
            with self._option():
                self._and_condition_()
                self.name_last_node('single')
            self._error(
                'expecting one of: '
                '<and_condition> <atom_condition>'
                '<if_condition>'
            )

    @tatsumasu('AndCondition')
    @leftrec
    def _and_condition_(self):  # noqa
        with self._choice():
            with self._option():
                self._and_condition_()
                self.name_last_node('se')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._AND_()

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._atom_condition_()
                self.name_last_node('other')

                self._define(
                    ['other', 'se'],
                    []
                )
            with self._option():
                self._atom_condition_()
                self.name_last_node('atom')
            self._error(
                'expecting one of: '
                "'(' <and_condition> <atom_condition>"
                '<equal> <greater> <greater_equal> <in>'
                '<less> <less_equal> <not_equal> <not_in>'
            )

    @tatsumasu('AtomCondition')
    def _atom_condition_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._if_condition_()
                self.name_last_node('p')

                def block3():
                    self._hspace_()
                self._closure(block3)
                self._token(')')

                self._define(
                    ['p'],
                    []
                )
            with self._option():
                self._not_equal_()
                self.name_last_node('cond')
            with self._option():
                self._equal_()
                self.name_last_node('cond')
            with self._option():
                self._in_()
                self.name_last_node('cond')
            with self._option():
                self._not_in_()
                self.name_last_node('cond')
            with self._option():
                self._greater_()
                self.name_last_node('cond')
            with self._option():
                self._greater_equal_()
                self.name_last_node('cond')
            with self._option():
                self._less_()
                self.name_last_node('cond')
            with self._option():
                self._less_equal_()
                self.name_last_node('cond')
            self._error(
                'expecting one of: '
                "'(' '-' <add_sub_operator> <addition>"
                '<equal> <expression> <greater>'
                '<greater_equal> <in> <less> <less_equal>'
                '<not_equal> <not_in> <subtraction>'
                '<term>'
            )

    @tatsumasu('InCondition')
    def _in_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._expression_()
                self.add_last_node_to_name('left')

                def block3():
                    self._hspace_()
                self._closure(block3)

                def block4():
                    self._token(',')

                    def block5():
                        self._hspace_()
                    self._closure(block5)
                    self._expression_()
                    self.add_last_node_to_name('left')

                    def block7():
                        self._hspace_()
                    self._closure(block7)

                    self._define(
                        [],
                        ['left']
                    )
                self._closure(block4)
                self._token(')')

                def block8():
                    self._hspace_()
                self._closure(block8)
                self._IN_()

                def block9():
                    self._hspace_()
                self._closure(block9)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._function_operator_()
                        with self._option():
                            self._identifier_()
                        self._error(
                            'expecting one of: '
                            '<function_operator> <identifier>'
                        )
                self.name_last_node('right')

                self._define(
                    ['right'],
                    ['left']
                )
            with self._option():
                self._expression_()
                self.add_last_node_to_name('left')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._IN_()

                def block14():
                    self._hspace_()
                self._closure(block14)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._function_operator_()
                        with self._option():
                            self._identifier_()
                        self._error(
                            'expecting one of: '
                            '<function_operator> <identifier>'
                        )
                self.name_last_node('right')

                self._define(
                    ['right'],
                    ['left']
                )
            self._error(
                'expecting one of: '
                "'(' '-' <add_sub_operator> <addition>"
                '<division> <expression> <factor>'
                '<multiplication> <subtraction> <term>'
            )

    @tatsumasu('NotInCondition')
    def _not_in_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._expression_()
                self.add_last_node_to_name('left')

                def block3():
                    self._hspace_()
                self._closure(block3)

                def block4():
                    self._token(',')

                    def block5():
                        self._hspace_()
                    self._closure(block5)
                    self._expression_()
                    self.add_last_node_to_name('left')

                    def block7():
                        self._hspace_()
                    self._closure(block7)

                    self._define(
                        [],
                        ['left']
                    )
                self._closure(block4)
                self._token(')')

                def block8():
                    self._hspace_()
                self._closure(block8)
                self._token('‚àâ')

                def block9():
                    self._hspace_()
                self._closure(block9)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._function_operator_()
                        with self._option():
                            self._identifier_()
                        self._error(
                            'expecting one of: '
                            '<function_operator> <identifier>'
                        )
                self.name_last_node('right')

                self._define(
                    ['right'],
                    ['left']
                )
            with self._option():
                self._expression_()
                self.add_last_node_to_name('left')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._token('‚àâ')

                def block14():
                    self._hspace_()
                self._closure(block14)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._function_operator_()
                        with self._option():
                            self._identifier_()
                        self._error(
                            'expecting one of: '
                            '<function_operator> <identifier>'
                        )
                self.name_last_node('right')

                self._define(
                    ['right'],
                    ['left']
                )
            self._error(
                'expecting one of: '
                "'(' '-' <add_sub_operator> <addition>"
                '<division> <expression> <factor>'
                '<multiplication> <subtraction> <term>'
            )

    @tatsumasu('NeCondition')
    def _not_equal_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('‚â†')
                with self._option():
                    self._token('!=')
                self._error(
                    'expecting one of: '
                    "'!=' '‚â†'"
                )
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('EqCondition')
    def _equal_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('==')
                with self._option():
                    self._token('=')
                self._error(
                    'expecting one of: '
                    "'=' '=='"
                )
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('GreaterCondition')
    def _greater_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('>')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._expression_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('GreaterEqualCondition')
    def _greater_equal_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('>=')
                with self._option():
                    self._token('‚â•')
                with self._option():
                    self._token('‚©æ')
                self._error(
                    'expecting one of: '
                    "'>=' '‚â•' '‚©æ'"
                )
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('LessCondition')
    def _less_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('<')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._expression_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('LessEqualCondition')
    def _less_equal_(self):  # noqa
        self._expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('<=')
                with self._option():
                    self._token('‚â§')
                with self._option():
                    self._token('‚©Ω')
                self._error(
                    'expecting one of: '
                    "'<=' '‚â§' '‚©Ω'"
                )
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._expression_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('ArithExpression')
    @leftrec
    def _arithmetic_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_addition_()
                self.name_last_node('value')
            with self._option():
                self._arithmetic_subtraction_()
                self.name_last_node('value')
            with self._option():
                with self._optional():
                    self._token('-')
                self.name_last_node('sign')
                self._arithmetic_term_()
                self.name_last_node('value')

                self._define(
                    ['sign', 'value'],
                    []
                )
            self._error(
                'expecting one of: '
                "'-' <arithmetic_addition>"
                '<arithmetic_division>'
                '<arithmetic_expression>'
                '<arithmetic_factor>'
                '<arithmetic_multiplication>'
                '<arithmetic_subtraction>'
                '<arithmetic_term>'
            )

    @tatsumasu('ArithAdd')
    @nomemo
    def _arithmetic_addition_(self):  # noqa
        self._arithmetic_expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('+')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._arithmetic_term_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('ArithSubtract')
    @nomemo
    def _arithmetic_subtraction_(self):  # noqa
        self._arithmetic_expression_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('-')
        self.name_last_node('op')

        def block3():
            self._hspace_()
        self._closure(block3)
        self._arithmetic_term_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    @leftrec
    def _arithmetic_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_multiplication_()
            with self._option():
                self._arithmetic_division_()
            with self._option():
                self._arithmetic_factor_()
            self._error(
                'expecting one of: '
                "# '.' <POUND> <arithmetic_division>"
                '<arithmetic_factor>'
                '<arithmetic_multiplication>'
                '<arithmetic_subexpression>'
                '<arithmetic_term> <digit> <double>'
                '<floating_point> <fraction> <identifier>'
                '<integer> <mantissa> <number> <size_op>'
                '[\\u00BC-\\u00BE\\u2150-\\u215E]'
            )

    @tatsumasu('ArithMultiply')
    @nomemo
    def _arithmetic_multiplication_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_term_()
                self.name_last_node('left')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._token('‚ãÖ')
                self.name_last_node('op')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._arithmetic_factor_()
                self.name_last_node('right')

                self._define(
                    ['left', 'op', 'right'],
                    []
                )
            with self._option():
                self._arithmetic_term_()
                self.name_last_node('left')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._arithmetic_factor_()
                self.name_last_node('right')

                self._define(
                    ['left', 'right'],
                    []
                )
            self._error(
                'expecting one of: '
                "# '.' <POUND> <arithmetic_division>"
                '<arithmetic_factor>'
                '<arithmetic_multiplication>'
                '<arithmetic_subexpression>'
                '<arithmetic_term> <digit> <double>'
                '<floating_point> <fraction> <identifier>'
                '<integer> <mantissa> <number> <size_op>'
                '[\\u00BC-\\u00BE\\u2150-\\u215E]'
            )

    @tatsumasu('ArithDivide')
    @nomemo
    def _arithmetic_division_(self):  # noqa
        self._arithmetic_term_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/')
                with self._option():
                    self._token('√∑')
                self._error(
                    'expecting one of: '
                    "'/' '√∑'"
                )
        self.name_last_node('op')

        def block4():
            self._hspace_()
        self._closure(block4)
        self._arithmetic_factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('ArithFactor')
    def _arithmetic_factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._arithmetic_subexpression_()
                self.name_last_node('sub')
            with self._option():
                self._size_op_()
                self.name_last_node('size')
            with self._option():
                self._identifier_()
                self.name_last_node('id0')
            with self._option():
                self._number_()
                self.name_last_node('num')
            self._error(
                'expecting one of: '
                "# ' '(' '.' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <arithmetic_subexpression>'
                '<digit> <double> <floating_point>'
                '<fraction> <identifier>'
                '<identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> <integer>'
                '<mantissa> <number> <size_op> SOLVE'
                'Solve [Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et'
                '[\\u00BC-\\u00BE\\u2150-\\u215E] [Œî] \\d and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu('ArithSubexpression')
    def _arithmetic_subexpression_(self):  # noqa
        self._token('(')

        def block0():
            self._hspace_()
        self._closure(block0)
        self._arithmetic_expression_()
        self.name_last_node('value')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._token(')')

        self._define(
            ['value'],
            []
        )

    @tatsumasu('MatrixType')
    def _matrix_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._MATRIX_()

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._token('(')

                def block2():
                    self._hspace_()
                self._closure(block2)
                self._dimension_()
                self.name_last_node('id1')

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._token(',')

                def block5():
                    self._hspace_()
                self._closure(block5)
                self._dimension_()
                self.name_last_node('id2')

                def block7():
                    self._hspace_()
                self._closure(block7)
                self._token(')')

                def block8():

                    def block9():
                        self._hspace_()
                    self._positive_closure(block9)
                    self._matrix_attribute_()
                    self.add_last_node_to_name('attr')

                    self._define(
                        [],
                        ['attr']
                    )
                self._closure(block8)

                self._define(
                    ['id1', 'id2'],
                    ['attr']
                )
            with self._option():
                self._pattern('[‚Ñù‚Ñ§]')
                self.name_last_node('type')

                def block12():
                    self._hspace_()
                self._closure(block12)
                self._token('^')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._token('(')

                def block14():
                    self._hspace_()
                self._closure(block14)
                self._dimension_()
                self.name_last_node('id1')

                def block16():
                    self._hspace_()
                self._closure(block16)
                self._token('√ó')

                def block17():
                    self._hspace_()
                self._closure(block17)
                self._dimension_()
                self.name_last_node('id2')

                def block19():
                    self._hspace_()
                self._closure(block19)
                self._token(')')

                def block20():

                    def block21():
                        self._hspace_()
                    self._positive_closure(block21)
                    self._matrix_attribute_()
                    self.add_last_node_to_name('attr')

                    self._define(
                        [],
                        ['attr']
                    )
                self._closure(block20)

                self._define(
                    ['id1', 'id2', 'type'],
                    ['attr']
                )
            self._error(
                'expecting one of: '
                '<MATRIX> [‚Ñù‚Ñ§] matrix'
            )

    @tatsumasu()
    def _matrix_attribute_(self):  # noqa
        self._SPARSE_()

    @tatsumasu('VectorType')
    def _vector_type_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._VECTOR_()

                    def block1():
                        self._hspace_()
                    self._closure(block1)
                    self._token('(')

                    def block2():
                        self._hspace_()
                    self._closure(block2)
                    self._dimension_()
                    self.name_last_node('id1')

                    def block4():
                        self._hspace_()
                    self._closure(block4)
                    self._token(')')

                    self._define(
                        ['id1'],
                        []
                    )
                with self._option():
                    self._pattern('[‚Ñù‚Ñ§]')
                    self.name_last_node('type')

                    def block6():
                        self._hspace_()
                    self._closure(block6)
                    self._token('^')

                    def block7():
                        self._hspace_()
                    self._closure(block7)
                    self._token('(')

                    def block8():
                        self._hspace_()
                    self._closure(block8)
                    self._dimension_()
                    self.name_last_node('id1')

                    def block10():
                        self._hspace_()
                    self._closure(block10)
                    self._token(')')

                    self._define(
                        ['id1', 'type'],
                        []
                    )
                with self._option():
                    self._pattern('[‚Ñù‚Ñ§]')
                    self.name_last_node('type')

                    def block12():
                        self._hspace_()
                    self._closure(block12)
                    self._token('^')

                    def block13():
                        self._hspace_()
                    self._closure(block13)
                    self._dimension_()
                    self.name_last_node('id1')

                    self._define(
                        ['id1', 'type'],
                        []
                    )
                with self._option():
                    self._pattern('[‚Ñù‚Ñ§]')
                    self.name_last_node('type')
                    self._sup_integer_()
                    self.name_last_node('id1')

                    self._define(
                        ['id1', 'type'],
                        []
                    )
                self._error(
                    'expecting one of: '
                    '<VECTOR> [‚Ñù‚Ñ§]'
                )

        def block17():

            def block18():
                self._hspace_()
            self._positive_closure(block18)
            self._matrix_attribute_()
            self.add_last_node_to_name('attr')

            self._define(
                [],
                ['attr']
            )
        self._closure(block17)

        self._define(
            ['id1', 'type'],
            ['attr']
        )

    @tatsumasu('ScalarType')
    def _scalar_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._SCALAR_()
            with self._option():
                self._pattern('‚Ñù')
            with self._option():
                self._pattern('‚Ñ§')
                self.name_last_node('z')
            self._error(
                'expecting one of: '
                '<SCALAR> scalar ‚Ñù ‚Ñ§'
            )

    @tatsumasu('SetType')
    def _set_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('{')

                def block1():
                    self._hspace_()
                self._closure(block1)
                self._pattern('[‚Ñù‚Ñ§]')
                self.add_last_node_to_name('type')

                def block3():
                    self._hspace_()
                self._closure(block3)

                def block4():
                    self._token('√ó')

                    def block5():
                        self._hspace_()
                    self._closure(block5)
                    self._pattern('[‚Ñù‚Ñ§]')
                    self.add_last_node_to_name('type')

                    def block7():
                        self._hspace_()
                    self._closure(block7)

                    self._define(
                        [],
                        ['type']
                    )
                self._closure(block4)
                self._token('}')

                self._define(
                    [],
                    ['type']
                )
            with self._option():
                self._token('{')

                def block8():
                    self._hspace_()
                self._closure(block8)
                self._pattern('[‚Ñù‚Ñ§]')
                self.name_last_node('type1')

                def block10():
                    self._hspace_()
                self._closure(block10)
                self._token('^')

                def block11():
                    self._hspace_()
                self._closure(block11)
                with self._group():
                    self._integer_()
                self.name_last_node('cnt')

                def block13():
                    self._hspace_()
                self._closure(block13)
                self._token('}')

                self._define(
                    ['cnt', 'type1'],
                    []
                )
            with self._option():
                self._token('{')

                def block14():
                    self._hspace_()
                self._closure(block14)
                self._pattern('[‚Ñù‚Ñ§]')
                self.name_last_node('type2')
                with self._optional():
                    self._sup_integer_()
                self.name_last_node('cnt')

                def block17():
                    self._hspace_()
                self._closure(block17)
                self._token('}')

                self._define(
                    ['cnt', 'type2'],
                    []
                )
            with self._option():
                self._token('{')

                def block18():
                    self._hspace_()
                self._closure(block18)
                self._params_type_()
                self.add_last_node_to_name('sub_types')

                def block20():
                    self._hspace_()
                self._closure(block20)

                def block21():
                    self._token('√ó')

                    def block22():
                        self._hspace_()
                    self._closure(block22)
                    self._params_type_()
                    self.add_last_node_to_name('sub_types')

                    def block24():
                        self._hspace_()
                    self._closure(block24)

                    self._define(
                        [],
                        ['sub_types']
                    )
                self._closure(block21)
                self._token('}')

                self._define(
                    [],
                    ['sub_types']
                )
            with self._option():
                self._token('{')

                def block25():
                    self._hspace_()
                self._closure(block25)
                self._params_type_()
                self.add_last_node_to_name('homogeneous_types')

                def block27():
                    self._hspace_()
                self._closure(block27)

                def block28():
                    self._token('‚à®')

                    def block29():
                        self._hspace_()
                    self._closure(block29)
                    self._params_type_()
                    self.add_last_node_to_name('homogeneous_types')

                    def block31():
                        self._hspace_()
                    self._closure(block31)

                    self._define(
                        [],
                        ['homogeneous_types']
                    )
                self._positive_closure(block28)
                self._token('}')

                self._define(
                    [],
                    ['homogeneous_types']
                )
            self._error(
                'expecting one of: '
                "'{'"
            )

    @tatsumasu('TupleType')
    @leftrec
    def _tuple_type_(self):  # noqa
        self._params_type_()
        self.add_last_node_to_name('sub_types')

        def block1():
            self._hspace_()
        self._closure(block1)

        def block2():
            self._token('√ó')

            def block3():
                self._hspace_()
            self._closure(block3)
            self._params_type_()
            self.add_last_node_to_name('sub_types')

            def block5():
                self._hspace_()
            self._closure(block5)

            self._define(
                [],
                ['sub_types']
            )
        self._positive_closure(block2)

        self._define(
            [],
            ['sub_types']
        )

    @tatsumasu()
    def _dimension_(self):  # noqa
        self._arithmetic_expression_()

    @tatsumasu('NamedType')
    def _named_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._VERTEXSET_()
                self.name_last_node('v')
            with self._option():
                self._EDGESET_()
                self.name_last_node('e')
            with self._option():
                self._FACESET_()
                self.name_last_node('f')
            with self._option():
                self._TETSET_()
                self.name_last_node('t')
            with self._option():
                self._SIMPLICIALSET_()
                self.name_last_node('s')
            with self._option():
                self._mesh_type_()
                self.name_last_node('m')
            self._error(
                'expecting one of: '
                '<CELLMESH> <EDGEMESH> <EDGESET>'
                '<FACEMESH> <FACESET> <SIMPLICIALSET>'
                '<TETSET> <VERTEXSET> <mesh_type>'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et'
            )

    @tatsumasu()
    def _mesh_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._EDGEMESH_()
                self.name_last_node('e')
            with self._option():
                self._FACEMESH_()
                self.name_last_node('f')
            with self._option():
                self._CELLMESH_()
                self.name_last_node('c')
            self._error(
                'expecting one of: '
                '<CELLMESH> <EDGEMESH> <FACEMESH>'
                '[Cc]ell[Mm]esh [Ee]dge[Mm]esh'
                '[Ff]ace[Mm]esh'
            )

    @tatsumasu()
    def _la_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._function_type_()
            with self._option():
                self._mapping_type_()
            with self._option():
                self._matrix_type_()
            with self._option():
                self._vector_type_()
            with self._option():
                self._set_type_()
            with self._option():
                self._tuple_type_()
            with self._option():
                self._scalar_type_()
            with self._option():
                self._named_type_()
            self._error(
                'expecting one of: '
                "'{' '‚àÖ' <CELLMESH> <EDGEMESH> <EDGESET>"
                '<FACEMESH> <FACESET> <MATRIX> <SCALAR>'
                '<SIMPLICIALSET> <TETSET> <VECTOR>'
                '<VERTEXSET> <function_type> <identifier>'
                '<mapping_type> <matrix_type> <mesh_type>'
                '<named_type> <params_type> <scalar_type>'
                '<set_type> <tuple_type> <vector_type>'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [‚Ñù‚Ñ§]'
                'matrix scalar vector ‚Ñù ‚Ñ§'
            )

    @tatsumasu()
    @nomemo
    def _params_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._matrix_type_()
            with self._option():
                self._vector_type_()
            with self._option():
                self._scalar_type_()
            with self._option():
                self._set_type_()
            with self._option():
                self._tuple_type_()
            self._error(
                'expecting one of: '
                "'{' <MATRIX> <SCALAR> <VECTOR>"
                '<matrix_type> <params_type>'
                '<scalar_type> <set_type> <tuple_type>'
                '<vector_type> [‚Ñù‚Ñ§] matrix scalar vector'
                '‚Ñù ‚Ñ§'
            )

    @tatsumasu('FunctionType')
    def _function_type_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._params_type_()
                        self.add_last_node_to_name('params')

                        def block2():

                            def block3():
                                self._hspace_()
                            self._closure(block3)
                            self._params_separator_()
                            self.add_last_node_to_name('separators')

                            def block5():
                                self._hspace_()
                            self._closure(block5)
                            self._params_type_()
                            self.add_last_node_to_name('params')

                            self._define(
                                [],
                                ['params', 'separators']
                            )
                        self._closure(block2)

                        self._define(
                            [],
                            ['params', 'separators']
                        )
                with self._option():
                    self._token('‚àÖ')
                    self.name_last_node('empty')
                with self._option():
                    self._token('{')

                    def block8():
                        self._hspace_()
                    self._closure(block8)
                    self._token('}')
                self._error(
                    'expecting one of: '
                    "'{' '‚àÖ' <params_type>"
                )

        def block9():
            self._hspace_()
        self._closure(block9)
        with self._group():
            with self._choice():
                with self._option():
                    self._token('‚Üí')
                with self._option():
                    self._token('->')
                self._error(
                    'expecting one of: '
                    "'->' '‚Üí'"
                )

        def block11():
            self._hspace_()
        self._closure(block11)
        self._params_type_()
        self.add_last_node_to_name('ret')

        def block13():

            def block14():
                self._hspace_()
            self._closure(block14)
            self._params_separator_()
            self.add_last_node_to_name('ret_separators')

            def block16():
                self._hspace_()
            self._closure(block16)
            self._params_type_()
            self.add_last_node_to_name('ret')

            self._define(
                [],
                ['ret', 'ret_separators']
            )
        self._closure(block13)

        self._define(
            ['empty'],
            ['params', 'ret', 'ret_separators', 'separators']
        )

    @tatsumasu('MappingType')
    def _mapping_type_(self):  # noqa
        with self._choice():
            with self._option():
                self._identifier_()
                self.name_last_node('src')

                def block2():
                    self._hspace_()
                self._closure(block2)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('‚Üí')
                        with self._option():
                            self._token('->')
                        self._error(
                            'expecting one of: '
                            "'->' '‚Üí'"
                        )

                def block4():
                    self._hspace_()
                self._closure(block4)
                self._params_type_()
                self.name_last_node('dst')

                self._define(
                    ['dst', 'src'],
                    []
                )
            with self._option():
                self._identifier_()
                self.name_last_node('s')
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <identifier> <identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu('Integer')
    def _integer_(self):  # noqa

        def block1():
            self._digit_()
        self._positive_closure(block1)
        self.name_last_node('value')

    @tatsumasu('SupInteger')
    def _sup_integer_(self):  # noqa

        def block1():
            self._pattern('[\\u2070\\u00B9\\u00B2\\u00B3\\u2074-\\u2079]')
        self._positive_closure(block1)
        self.name_last_node('value')

    @tatsumasu('SubInteger')
    def _sub_integer_(self):  # noqa

        def block1():
            self._pattern('[\\u2080-\\u2089]')
        self._positive_closure(block1)
        self.name_last_node('value')

    @tatsumasu()
    def _digit_(self):  # noqa
        self._pattern('\\d')

    @tatsumasu()
    @nomemo
    def _set_operators_(self):  # noqa
        with self._choice():
            with self._option():
                self._union_operator_()
            with self._option():
                self._intersect_operator_()
            self._error(
                'expecting one of: '
                "'(' '.' '0' '1' '[' '{' '‚é°' 'ùüô'"
                '<builtin_operators> <constant>'
                '<cross_product_operator> <derivative>'
                '<digit> <divergence> <double> <factor>'
                '<floating_point> <fraction>'
                '<frobenius_product_operator>'
                '<function_operator> <gradient>'
                '<hadamard_product_operator> <identifier>'
                '<inner_product_operator> <integer>'
                '<integral_operator> <intersect_operator>'
                '<kronecker_product_operator> <laplacian>'
                '<mantissa> <matrix> <norm_operator>'
                '<number> <number_matrix> <operations>'
                '<partial> <power_operator>'
                '<pseudoinverse_operator> <set>'
                '<set_operators> <size_op>'
                '<solver_operator> <sqrt_operator>'
                '<subexpression> <sum_operator>'
                '<trans_operator> <union_operator>'
                '<vector> [01\\u1D7D9]'
                '[\\u00BC-\\u00BE\\u2150-\\u215E]'
            )

    @tatsumasu('Union')
    @nomemo
    def _union_operator_(self):  # noqa
        self._factor_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('‚à™')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Intersection')
    @nomemo
    def _intersect_operator_(self):  # noqa
        self._factor_()
        self.name_last_node('left')

        def block1():
            self._hspace_()
        self._closure(block1)
        self._token('‚à©')

        def block2():
            self._hspace_()
        self._closure(block2)
        self._factor_()
        self.name_last_node('right')

        self._define(
            ['left', 'right'],
            []
        )

    @tatsumasu()
    def _func_id_(self):  # noqa
        with self._choice():
            with self._option():
                self._INVERSEVEC_()
            with self._option():
                self._identifier_alone_()

                def block1():
                    with self._choice():
                        with self._option():
                            self._token('_')
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._identifier_alone_()
                                    with self._option():
                                        self._integer_()
                                    self._error(
                                        'expecting one of: '
                                        '<identifier_alone> <integer>'
                                    )
                        with self._option():
                            self._unicode_subscript_()
                        self._error(
                            'expecting one of: '
                            "'_' <unicode_subscript>"
                        )
                self._closure(block1)
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <INVERSEVEC>'
                '<KEYWORDS> <LN> <LOG> <MATRIX> <MAX>'
                '<MIN> <NABLA> <NOT_PREFIX_KEYWORD> <OR>'
                '<OTHERWISE> <PI> <POUND>'
                '<PREFIX_KEYWORD> <PRIME> <SCALAR>'
                '<SEQUENCE> <SIMPLICIALSET> <SOLVE>'
                '<SPARSE> <SQRT> <SUBJECT_TO> <SUBSET>'
                '<TETS> <TETSET> <TUPLE> <VECTOR>'
                '<VERTEXSET> <VERTICES> <WHERE> <WITH>'
                '<identifier_alone> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int'
                'inversevec ln log matrix max min or'
                'otherwise s.t. scalar sequence solve'
                'sparse sqrt subject to sum tuple vector'
                'vec‚Åª¬π vertices where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu('IdentifierAlone')
    def _identifier_alone_(self):  # noqa
        with self._choice():
            with self._option():
                with self._ifnot():
                    self._KEYWORDS_()
                with self._group():
                    with self._choice():
                        with self._option():
                            with self._group():
                                self._pattern('[A-Za-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:[A-Z0-9a-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*')
                            self.name_last_node('value')
                        with self._option():
                            self._token('`')
                            self._pattern('[^`]*')
                            self.name_last_node('id')
                            self._token('`')

                            self._define(
                                ['id'],
                                []
                            )
                        self._error(
                            'expecting one of: '
                            "'`' [A-Za-"
                            'z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:[A-Z0-9a-'
                            'z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*'
                        )

                self._define(
                    ['id', 'value'],
                    []
                )
            with self._option():
                with self._group():
                    self._PREFIX_KEYWORD_()
                    with self._group():
                        self._pattern('[A-Za-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*(?:[A-Z0-9a-z\\p{Ll}\\p{Lu}\\p{Lo}]\\p{M}*)*')
                self.name_last_node('value')
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> SOLVE Solve [Cc]ell[Mm]esh'
                '[Cc]ell[Ss]et [Cc]ellular[Ss]et'
                '[Ee]dge[Mm]esh [Ee]dge[Ss]et'
                '[Ff]ace[Mm]esh [Ff]ace[Ss]et'
                '[Vv]ertex[Ss]et [Œî] and argmax argmin as'
                'cells edges exp faces for from given if'
                'index initial int ln log matrix max min'
                'or otherwise s.t. scalar sequence solve'
                'sparse sqrt subject to sum tuple vector'
                'vertices where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu()
    def _identifier_(self):  # noqa
        with self._choice():
            with self._option():
                self._identifier_with_multi_subscript_()
            with self._option():
                self._identifier_with_subscript_()
            with self._option():
                self._identifier_alone_()
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <KEYWORDS> <LN>'
                '<LOG> <MATRIX> <MAX> <MIN> <NABLA>'
                '<NOT_PREFIX_KEYWORD> <OR> <OTHERWISE>'
                '<PI> <POUND> <PREFIX_KEYWORD> <PRIME>'
                '<SCALAR> <SEQUENCE> <SIMPLICIALSET>'
                '<SOLVE> <SPARSE> <SQRT> <SUBJECT_TO>'
                '<SUBSET> <TETS> <TETSET> <TUPLE>'
                '<VECTOR> <VERTEXSET> <VERTICES> <WHERE>'
                '<WITH> <identifier_alone>'
                '<identifier_with_multi_subscript>'
                '<identifier_with_subscript> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int ln'
                'log matrix max min or otherwise s.t.'
                'scalar sequence solve sparse sqrt'
                'subject to sum tuple vector vertices'
                'where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu('IdentifierSubscript')
    def _identifier_with_multi_subscript_(self):  # noqa
        self._identifier_alone_()
        self.name_last_node('left')

        def block1():
            self._token('_')
            with self._group():
                with self._choice():
                    with self._option():
                        self._identifier_alone_()
                    with self._option():
                        self._integer_()
                    with self._option():
                        self._BUILTIN_KEYWORDS_()
                    self._error(
                        'expecting one of: '
                        '<BUILTIN_KEYWORDS> <identifier_alone>'
                        '<integer>'
                    )
            self.add_last_node_to_name('right')

            self._define(
                [],
                ['right']
            )
        self._positive_closure(block1)
        with self._group():
            with self._choice():
                with self._option():

                    def block5():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            with self._option():
                                with self._group():

                                    def block8():
                                        self._token(',')
                                    self._closure(block8)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._integer_()
                                            with self._option():
                                                self._identifier_alone_()
                                            self._error(
                                                'expecting one of: '
                                                '<identifier_alone> <integer>'
                                            )
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <identifier_alone> <integer>"
                            )
                    self._closure(block5)
                with self._option():

                    def block11():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token(',')
                                    self._token('*')
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            with self._option():
                                with self._group():

                                    def block14():
                                        self._token(',')
                                    self._closure(block14)
                                    with self._group():
                                        with self._choice():
                                            with self._option():
                                                self._sub_integer_()
                                            with self._option():
                                                self._unicode_subscript_()
                                            self._error(
                                                'expecting one of: '
                                                '<sub_integer> <unicode_subscript>'
                                            )
                                    self.add_last_node_to_name('right')

                                    self._define(
                                        [],
                                        ['right']
                                    )
                            self._error(
                                'expecting one of: '
                                "',' <sub_integer> <unicode_subscript>"
                            )
                    self._closure(block11)
                self._error(
                    'expecting one of: '
                    "',' <identifier_alone> <integer>"
                    '<sub_integer> <unicode_subscript>'
                )

        self._define(
            ['left'],
            ['right']
        )

    @tatsumasu('Function')
    def _function_operator_(self):  # noqa
        with self._choice():
            with self._option():
                self._func_id_()
                self.name_last_node('name')
                self._token('_')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._integer_()
                        with self._option():
                            self._identifier_alone_()
                        self._error(
                            'expecting one of: '
                            '<identifier_alone> <integer>'
                        )
                self.add_last_node_to_name('subs')

                def block4():

                    def block5():
                        self._token(',')
                    self._closure(block5)
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._integer_()
                            with self._option():
                                self._identifier_alone_()
                            self._error(
                                'expecting one of: '
                                '<identifier_alone> <integer>'
                            )
                    self.add_last_node_to_name('subs')

                    self._define(
                        [],
                        ['subs']
                    )
                self._closure(block4)

                def block8():
                    self._token('(')
                    self.name_last_node('p')

                    def block10():

                        def block11():
                            self._hspace_()
                        self._closure(block11)
                        self._expression_()
                        self.add_last_node_to_name('params')

                        def block13():

                            def block14():
                                self._hspace_()
                            self._closure(block14)
                            self._params_separator_()
                            self.add_last_node_to_name('separators')

                            def block16():
                                self._hspace_()
                            self._closure(block16)
                            self._expression_()
                            self.add_last_node_to_name('params')

                            self._define(
                                [],
                                ['params', 'separators']
                            )
                        self._closure(block13)

                        self._define(
                            [],
                            ['params', 'separators']
                        )
                    self._closure(block10)

                    def block18():
                        self._hspace_()
                    self._closure(block18)
                    self._token(')')

                    self._define(
                        ['p'],
                        ['params', 'separators']
                    )
                self._closure(block8)

                self._define(
                    ['name', 'p'],
                    ['params', 'separators', 'subs']
                )
            with self._option():
                self._func_id_()
                self.name_last_node('name')
                self._token('(')
                self.name_last_node('p')

                def block21():

                    def block22():
                        self._hspace_()
                    self._closure(block22)
                    self._expression_()
                    self.add_last_node_to_name('params')

                    def block24():

                        def block25():
                            self._hspace_()
                        self._closure(block25)
                        self._params_separator_()
                        self.add_last_node_to_name('separators')

                        def block27():
                            self._hspace_()
                        self._closure(block27)
                        self._expression_()
                        self.add_last_node_to_name('params')

                        self._define(
                            [],
                            ['params', 'separators']
                        )
                    self._closure(block24)

                    self._define(
                        [],
                        ['params', 'separators']
                    )
                self._closure(block21)

                def block29():
                    self._hspace_()
                self._closure(block29)
                self._token(')')

                self._define(
                    ['name', 'p'],
                    ['params', 'separators']
                )
            with self._option():
                self._func_id_()
                self.name_last_node('name')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._sub_integer_()
                        with self._option():
                            self._unicode_subscript_()
                        self._error(
                            'expecting one of: '
                            '<sub_integer> <unicode_subscript>'
                        )
                self.add_last_node_to_name('subs')

                def block33():

                    def block34():
                        self._token(',')
                    self._closure(block34)
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._sub_integer_()
                            with self._option():
                                self._unicode_subscript_()
                            self._error(
                                'expecting one of: '
                                '<sub_integer> <unicode_subscript>'
                            )
                    self.add_last_node_to_name('subs')

                    self._define(
                        [],
                        ['subs']
                    )
                self._closure(block33)

                def block37():
                    self._token('(')
                    self.name_last_node('p')

                    def block39():

                        def block40():
                            self._hspace_()
                        self._closure(block40)
                        self._expression_()
                        self.add_last_node_to_name('params')

                        def block42():

                            def block43():
                                self._hspace_()
                            self._closure(block43)
                            self._params_separator_()
                            self.add_last_node_to_name('separators')

                            def block45():
                                self._hspace_()
                            self._closure(block45)
                            self._expression_()
                            self.add_last_node_to_name('params')

                            self._define(
                                [],
                                ['params', 'separators']
                            )
                        self._closure(block42)

                        self._define(
                            [],
                            ['params', 'separators']
                        )
                    self._closure(block39)

                    def block47():
                        self._hspace_()
                    self._closure(block47)
                    self._token(')')

                    self._define(
                        ['p'],
                        ['params', 'separators']
                    )
                self._closure(block37)

                self._define(
                    ['name', 'p'],
                    ['params', 'separators', 'subs']
                )
            self._error(
                'expecting one of: '
                "# ' <AND> <ARGMAX> <ARGMIN> <AS>"
                '<BUILTIN_KEYWORDS> <CELLMESH> <DELTA>'
                '<DERIVATIVE> <EDGEMESH> <EDGES>'
                '<EDGESET> <EXP> <FACEMESH> <FACES>'
                '<FACESET> <FOR> <FROM> <GIVEN> <IF> <IN>'
                '<INDEX> <INITIAL> <INT> <INVERSEVEC>'
                '<KEYWORDS> <LN> <LOG> <MATRIX> <MAX>'
                '<MIN> <NABLA> <NOT_PREFIX_KEYWORD> <OR>'
                '<OTHERWISE> <PI> <POUND>'
                '<PREFIX_KEYWORD> <PRIME> <SCALAR>'
                '<SEQUENCE> <SIMPLICIALSET> <SOLVE>'
                '<SPARSE> <SQRT> <SUBJECT_TO> <SUBSET>'
                '<TETS> <TETSET> <TUPLE> <VECTOR>'
                '<VERTEXSET> <VERTICES> <WHERE> <WITH>'
                '<func_id> <identifier_alone> SOLVE Solve'
                '[Cc]ell[Mm]esh [Cc]ell[Ss]et'
                '[Cc]ellular[Ss]et [Ee]dge[Mm]esh'
                '[Ee]dge[Ss]et [Ff]ace[Mm]esh'
                '[Ff]ace[Ss]et [Vv]ertex[Ss]et [Œî] and'
                'argmax argmin as cells edges exp faces'
                'for from given if index initial int'
                'inversevec ln log matrix max min or'
                'otherwise s.t. scalar sequence solve'
                'sparse sqrt subject to sum tuple vector'
                'vec‚Åª¬π vertices where with œÄ ‚Ñù ‚Ñ§ ‚àá ‚àà ‚äÇ ùïï'
            )

    @tatsumasu('LocalFunc')
    def _local_func_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._identifier_()
                    self.name_last_node('name')

                    def block2():
                        self._pattern('\\(')
                        self.name_last_node('def_p')

                        def block4():

                            def block5():
                                self._hspace_()
                            self._closure(block5)
                            self._identifier_alone_()
                            self.add_last_node_to_name('params')

                            def block7():

                                def block8():
                                    self._hspace_()
                                self._closure(block8)
                                self._params_separator_()
                                self.add_last_node_to_name('separators')

                                def block10():
                                    self._hspace_()
                                self._closure(block10)
                                self._identifier_alone_()
                                self.add_last_node_to_name('params')

                                self._define(
                                    [],
                                    ['params', 'separators']
                                )
                            self._closure(block7)

                            self._define(
                                [],
                                ['params', 'separators']
                            )
                        self._closure(block4)

                        def block12():
                            self._hspace_()
                        self._closure(block12)
                        self._token(')')

                        self._define(
                            ['def_p'],
                            ['params', 'separators']
                        )
                    self._closure(block2)

                    self._define(
                        ['def_p', 'name'],
                        ['params', 'separators']
                    )
                with self._option():
                    self._identifier_()
                    self.name_last_node('name')

                    def block14():
                        self._pattern('\\[')
                        self.name_last_node('def_s')

                        def block16():

                            def block17():
                                self._hspace_()
                            self._closure(block17)
                            self._identifier_alone_()
                            self.add_last_node_to_name('params')

                            def block19():

                                def block20():
                                    self._hspace_()
                                self._closure(block20)
                                self._params_separator_()
                                self.add_last_node_to_name('separators')

                                def block22():
                                    self._hspace_()
                                self._closure(block22)
                                self._identifier_alone_()
                                self.add_last_node_to_name('params')

                                self._define(
                                    [],
                                    ['params', 'separators']
                                )
                            self._closure(block19)

                            self._define(
                                [],
                                ['params', 'separators']
                            )
                        self._closure(block16)

                        def block24():
                            self._hspace_()
                        self._closure(block24)
                        self._token(']')

                        self._define(
                            ['def_s'],
                            ['params', 'separators']
                        )
                    self._closure(block14)

                    self._define(
                        ['def_s', 'name'],
                        ['params', 'separators']
                    )
                self._error(
                    'expecting one of: '
                    '<identifier>'
                )

        def block25():
            self._hspace_()
        self._closure(block25)
        self._token('=')
        self.name_last_node('op')

        def block27():
            self._hspace_()
        self._closure(block27)
        self._right_hand_side_()
        self.add_last_node_to_name('expr')
        with self._optional():

            def block29():
                self._hspace_()
            self._closure(block29)
            self._line_()

        def block30():
            self._hspace_()
        self._closure(block30)
        with self._group():
            with self._choice():
                with self._option():
                    self._WHERE_()
                with self._option():
                    self._GIVEN_()
                self._error(
                    'expecting one of: '
                    '<GIVEN> <WHERE>'
                )

        def block32():
            self._hspace_()
        self._closure(block32)
        self._where_condition_()
        self.add_last_node_to_name('defs')

        def block34():

            def block35():
                self._hspace_()
            self._closure(block35)
            self._token(',')

            def block36():
                self._hspace_()
            self._closure(block36)
            self._where_condition_()
            self.add_last_node_to_name('defs')

            self._define(
                [],
                ['defs']
            )
        self._closure(block34)

        def block38():

            def block39():
                self._hspace_()
            self._closure(block39)
            self._token(',')

            def block40():
                self._hspace_()
            self._closure(block40)
            with self._optional():
                self._line_()

            def block41():
                self._hspace_()
            self._closure(block41)
            self._general_assign_()
            self.add_last_node_to_name('extra')

            self._define(
                [],
                ['extra']
            )
        self._closure(block38)

        self._define(
            ['def_p', 'def_s', 'name', 'op'],
            ['defs', 'expr', 'extra', 'params', 'separators']
        )


class grammarinitSemantics:
    def start(self, ast):  # noqa
        return ast

    def TRACE(self, ast):  # noqa
        return ast

    def TR(self, ast):  # noqa
        return ast

    def VEC(self, ast):  # noqa
        return ast

    def INVERSEVEC(self, ast):  # noqa
        return ast

    def DIAG(self, ast):  # noqa
        return ast

    def INV(self, ast):  # noqa
        return ast

    def DET(self, ast):  # noqa
        return ast

    def RANK(self, ast):  # noqa
        return ast

    def NULL(self, ast):  # noqa
        return ast

    def ORTH(self, ast):  # noqa
        return ast

    def QR(self, ast):  # noqa
        return ast

    def DERIVATIVE(self, ast):  # noqa
        return ast

    def PARTIAL(self, ast):  # noqa
        return ast

    def WHERE(self, ast):  # noqa
        return ast

    def GIVEN(self, ast):  # noqa
        return ast

    def SUM(self, ast):  # noqa
        return ast

    def MIN(self, ast):  # noqa
        return ast

    def MAX(self, ast):  # noqa
        return ast

    def ARGMIN(self, ast):  # noqa
        return ast

    def ARGMAX(self, ast):  # noqa
        return ast

    def INT(self, ast):  # noqa
        return ast

    def SPARSE(self, ast):  # noqa
        return ast

    def IF(self, ast):  # noqa
        return ast

    def OTHERWISE(self, ast):  # noqa
        return ast

    def IN(self, ast):  # noqa
        return ast

    def SIN(self, ast):  # noqa
        return ast

    def ASIN(self, ast):  # noqa
        return ast

    def ARCSIN(self, ast):  # noqa
        return ast

    def COS(self, ast):  # noqa
        return ast

    def ACOS(self, ast):  # noqa
        return ast

    def ARCCOS(self, ast):  # noqa
        return ast

    def TAN(self, ast):  # noqa
        return ast

    def ATAN(self, ast):  # noqa
        return ast

    def ARCTAN(self, ast):  # noqa
        return ast

    def SINH(self, ast):  # noqa
        return ast

    def ASINH(self, ast):  # noqa
        return ast

    def ARSINH(self, ast):  # noqa
        return ast

    def COSH(self, ast):  # noqa
        return ast

    def ACOSH(self, ast):  # noqa
        return ast

    def ARCOSH(self, ast):  # noqa
        return ast

    def TANH(self, ast):  # noqa
        return ast

    def ATANH(self, ast):  # noqa
        return ast

    def ARTANH(self, ast):  # noqa
        return ast

    def COT(self, ast):  # noqa
        return ast

    def SEC(self, ast):  # noqa
        return ast

    def CSC(self, ast):  # noqa
        return ast

    def ATAN2(self, ast):  # noqa
        return ast

    def EXP(self, ast):  # noqa
        return ast

    def LOG(self, ast):  # noqa
        return ast

    def LN(self, ast):  # noqa
        return ast

    def SQRT(self, ast):  # noqa
        return ast

    def SUBJECT_TO(self, ast):  # noqa
        return ast

    def FROM(self, ast):  # noqa
        return ast

    def PI(self, ast):  # noqa
        return ast

    def WITH(self, ast):  # noqa
        return ast

    def INITIAL(self, ast):  # noqa
        return ast

    def AND(self, ast):  # noqa
        return ast

    def OR(self, ast):  # noqa
        return ast

    def DELTA(self, ast):  # noqa
        return ast

    def NABLA(self, ast):  # noqa
        return ast

    def PRIME(self, ast):  # noqa
        return ast

    def UDOT(self, ast):  # noqa
        return ast

    def UDDOT(self, ast):  # noqa
        return ast

    def SOLVE(self, ast):  # noqa
        return ast

    def SUBSET(self, ast):  # noqa
        return ast

    def AS(self, ast):  # noqa
        return ast

    def POUND(self, ast):  # noqa
        return ast

    def FOR(self, ast):  # noqa
        return ast

    def SCALAR(self, ast):  # noqa
        return ast

    def VECTOR(self, ast):  # noqa
        return ast

    def MATRIX(self, ast):  # noqa
        return ast

    def VERTEXSET(self, ast):  # noqa
        return ast

    def EDGESET(self, ast):  # noqa
        return ast

    def FACESET(self, ast):  # noqa
        return ast

    def TETSET(self, ast):  # noqa
        return ast

    def SIMPLICIALSET(self, ast):  # noqa
        return ast

    def EDGEMESH(self, ast):  # noqa
        return ast

    def FACEMESH(self, ast):  # noqa
        return ast

    def CELLMESH(self, ast):  # noqa
        return ast

    def INDEX(self, ast):  # noqa
        return ast

    def VERTICES(self, ast):  # noqa
        return ast

    def EDGES(self, ast):  # noqa
        return ast

    def FACES(self, ast):  # noqa
        return ast

    def TETS(self, ast):  # noqa
        return ast

    def TUPLE(self, ast):  # noqa
        return ast

    def SEQUENCE(self, ast):  # noqa
        return ast

    def SVD(self, ast):  # noqa
        return ast

    def BUILTIN_KEYWORDS(self, ast):  # noqa
        return ast

    def NOT_PREFIX_KEYWORD(self, ast):  # noqa
        return ast

    def PREFIX_KEYWORD(self, ast):  # noqa
        return ast

    def exponent(self, ast):  # noqa
        return ast

    def mantissa(self, ast):  # noqa
        return ast

    def floating_point(self, ast):  # noqa
        return ast

    def double(self, ast):  # noqa
        return ast

    def fraction(self, ast):  # noqa
        return ast

    def number(self, ast):  # noqa
        return ast

    def operations(self, ast):  # noqa
        return ast

    def addition(self, ast):  # noqa
        return ast

    def subtraction(self, ast):  # noqa
        return ast

    def add_sub_operator(self, ast):  # noqa
        return ast

    def multiplication(self, ast):  # noqa
        return ast

    def division(self, ast):  # noqa
        return ast

    def derivative(self, ast):  # noqa
        return ast

    def partial(self, ast):  # noqa
        return ast

    def divergence(self, ast):  # noqa
        return ast

    def gradient(self, ast):  # noqa
        return ast

    def laplacian(self, ast):  # noqa
        return ast

    def power_operator(self, ast):  # noqa
        return ast

    def solver_operator(self, ast):  # noqa
        return ast

    def sum_operator(self, ast):  # noqa
        return ast

    def optimize_operator(self, ast):  # noqa
        return ast

    def multi_cond(self, ast):  # noqa
        return ast

    def integral_operator(self, ast):  # noqa
        return ast

    def domain(self, ast):  # noqa
        return ast

    def norm_operator(self, ast):  # noqa
        return ast

    def inner_product_operator(self, ast):  # noqa
        return ast

    def frobenius_product_operator(self, ast):  # noqa
        return ast

    def hadamard_product_operator(self, ast):  # noqa
        return ast

    def cross_product_operator(self, ast):  # noqa
        return ast

    def kronecker_product_operator(self, ast):  # noqa
        return ast

    def trans_operator(self, ast):  # noqa
        return ast

    def pseudoinverse_operator(self, ast):  # noqa
        return ast

    def sqrt_operator(self, ast):  # noqa
        return ast

    def predefined_built_operators(self, ast):  # noqa
        return ast

    def element_convert_func(self, ast):  # noqa
        return ast

    def exp_func(self, ast):  # noqa
        return ast

    def minmax_func(self, ast):  # noqa
        return ast

    def log_func(self, ast):  # noqa
        return ast

    def ln_func(self, ast):  # noqa
        return ast

    def sqrt_func(self, ast):  # noqa
        return ast

    def matrix(self, ast):  # noqa
        return ast

    def vector(self, ast):  # noqa
        return ast

    def set(self, ast):  # noqa
        return ast

    def multi_cond_expr(self, ast):  # noqa
        return ast

    def multi_if_conditions(self, ast):  # noqa
        return ast

    def single_if_condition(self, ast):  # noqa
        return ast

    def rows(self, ast):  # noqa
        return ast

    def row(self, ast):  # noqa
        return ast

    def row_with_commas(self, ast):  # noqa
        return ast

    def expr_in_matrix(self, ast):  # noqa
        return ast

    def addition_in_matrix(self, ast):  # noqa
        return ast

    def subtraction_in_matrix(self, ast):  # noqa
        return ast

    def term_in_matrix(self, ast):  # noqa
        return ast

    def multiplication_in_matrix(self, ast):  # noqa
        return ast

    def division_in_matrix(self, ast):  # noqa
        return ast

    def number_matrix(self, ast):  # noqa
        return ast

    def factor_in_matrix(self, ast):  # noqa
        return ast

    def operations_in_matrix(self, ast):  # noqa
        return ast

    def power_in_matrix_operator(self, ast):  # noqa
        return ast

    def frobenius_product_in_matrix_operator(self, ast):  # noqa
        return ast

    def hadamard_product_in_matrix_operator(self, ast):  # noqa
        return ast

    def cross_product_in_matrix_operator(self, ast):  # noqa
        return ast

    def kronecker_product_in_matrix_operator(self, ast):  # noqa
        return ast

    def trans_in_matrix_operator(self, ast):  # noqa
        return ast

    def pseudoinverse_in_matrix_operator(self, ast):  # noqa
        return ast

    def sqrt_in_matrix_operator(self, ast):  # noqa
        return ast

    def solver_in_matrix_operator(self, ast):  # noqa
        return ast

    def sum_in_matrix_operator(self, ast):  # noqa
        return ast

    def hspace(self, ast):  # noqa
        return ast

    def line(self, ast):  # noqa
        return ast

    def lines(self, ast):  # noqa
        return ast

    def identifier_with_subscript(self, ast):  # noqa
        return ast

    def identifier_with_unicode_subscript(self, ast):  # noqa
        return ast

    def unicode_subscript(self, ast):  # noqa
        return ast

    def unicode_superscript(self, ast):  # noqa
        return ast

    def size_op(self, ast):  # noqa
        return ast

    def keyword_str(self, ast):  # noqa
        return ast

    def multi_str(self, ast):  # noqa
        return ast

    def description(self, ast):  # noqa
        return ast

    def desc_identifier(self, ast):  # noqa
        return ast

    def separator(self, ast):  # noqa
        return ast

    def separator_with_space(self, ast):  # noqa
        return ast

    def blank(self, ast):  # noqa
        return ast

    def params_separator(self, ast):  # noqa
        return ast

    def pi(self, ast):  # noqa
        return ast

    def infinity(self, ast):  # noqa
        return ast

    def e(self, ast):  # noqa
        return ast

    def sin_func(self, ast):  # noqa
        return ast

    def asin_func(self, ast):  # noqa
        return ast

    def arcsin_func(self, ast):  # noqa
        return ast

    def cos_func(self, ast):  # noqa
        return ast

    def acos_func(self, ast):  # noqa
        return ast

    def arccos_func(self, ast):  # noqa
        return ast

    def tan_func(self, ast):  # noqa
        return ast

    def atan_func(self, ast):  # noqa
        return ast

    def arctan_func(self, ast):  # noqa
        return ast

    def sinh_func(self, ast):  # noqa
        return ast

    def asinh_func(self, ast):  # noqa
        return ast

    def arsinh_func(self, ast):  # noqa
        return ast

    def cosh_func(self, ast):  # noqa
        return ast

    def acosh_func(self, ast):  # noqa
        return ast

    def arcosh_func(self, ast):  # noqa
        return ast

    def tanh_func(self, ast):  # noqa
        return ast

    def atanh_func(self, ast):  # noqa
        return ast

    def artanh_func(self, ast):  # noqa
        return ast

    def cot_func(self, ast):  # noqa
        return ast

    def sec_func(self, ast):  # noqa
        return ast

    def csc_func(self, ast):  # noqa
        return ast

    def atan2_func(self, ast):  # noqa
        return ast

    def trace_func(self, ast):  # noqa
        return ast

    def tr_func(self, ast):  # noqa
        return ast

    def diag_func(self, ast):  # noqa
        return ast

    def vec_func(self, ast):  # noqa
        return ast

    def inversevec_func(self, ast):  # noqa
        return ast

    def det_func(self, ast):  # noqa
        return ast

    def rank_func(self, ast):  # noqa
        return ast

    def null_func(self, ast):  # noqa
        return ast

    def orth_func(self, ast):  # noqa
        return ast

    def inv_func(self, ast):  # noqa
        return ast

    def svd_func(self, ast):  # noqa
        return ast

    def Directive(self, ast):  # noqa
        return ast

    def import_(self, ast):  # noqa
        return ast

    def import_var(self, ast):  # noqa
        return ast

    def where_conditions(self, ast):  # noqa
        return ast

    def where_condition(self, ast):  # noqa
        return ast

    def attribute(self, ast):  # noqa
        return ast

    def la_where_condition(self, ast):  # noqa
        return ast

    def de_where_condition(self, ast):  # noqa
        return ast

    def where_condition_terse(self, ast):  # noqa
        return ast

    def valid_block(self, ast):  # noqa
        return ast

    def params_block(self, ast):  # noqa
        return ast

    def builtin_operators(self, ast):  # noqa
        return ast

    def statements(self, ast):  # noqa
        return ast

    def statement(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def destructure(self, ast):  # noqa
        return ast

    def assignment(self, ast):  # noqa
        return ast

    def general_assign(self, ast):  # noqa
        return ast

    def general_assignment(self, ast):  # noqa
        return ast

    def simplified_right_hand_side(self, ast):  # noqa
        return ast

    def right_hand_side(self, ast):  # noqa
        return ast

    def left_hand_side(self, ast):  # noqa
        return ast

    def term(self, ast):  # noqa
        return ast

    def factor(self, ast):  # noqa
        return ast

    def sub_factor(self, ast):  # noqa
        return ast

    def constant(self, ast):  # noqa
        return ast

    def KEYWORDS(self, ast):  # noqa
        return ast

    def subexpression(self, ast):  # noqa
        return ast

    def if_condition(self, ast):  # noqa
        return ast

    def and_condition(self, ast):  # noqa
        return ast

    def atom_condition(self, ast):  # noqa
        return ast

    def in_(self, ast):  # noqa
        return ast

    def not_in(self, ast):  # noqa
        return ast

    def not_equal(self, ast):  # noqa
        return ast

    def equal(self, ast):  # noqa
        return ast

    def greater(self, ast):  # noqa
        return ast

    def greater_equal(self, ast):  # noqa
        return ast

    def less(self, ast):  # noqa
        return ast

    def less_equal(self, ast):  # noqa
        return ast

    def arithmetic_expression(self, ast):  # noqa
        return ast

    def arithmetic_addition(self, ast):  # noqa
        return ast

    def arithmetic_subtraction(self, ast):  # noqa
        return ast

    def arithmetic_term(self, ast):  # noqa
        return ast

    def arithmetic_multiplication(self, ast):  # noqa
        return ast

    def arithmetic_division(self, ast):  # noqa
        return ast

    def arithmetic_factor(self, ast):  # noqa
        return ast

    def arithmetic_subexpression(self, ast):  # noqa
        return ast

    def matrix_type(self, ast):  # noqa
        return ast

    def matrix_attribute(self, ast):  # noqa
        return ast

    def vector_type(self, ast):  # noqa
        return ast

    def scalar_type(self, ast):  # noqa
        return ast

    def set_type(self, ast):  # noqa
        return ast

    def tuple_type(self, ast):  # noqa
        return ast

    def dimension(self, ast):  # noqa
        return ast

    def named_type(self, ast):  # noqa
        return ast

    def mesh_type(self, ast):  # noqa
        return ast

    def la_type(self, ast):  # noqa
        return ast

    def params_type(self, ast):  # noqa
        return ast

    def function_type(self, ast):  # noqa
        return ast

    def mapping_type(self, ast):  # noqa
        return ast

    def integer(self, ast):  # noqa
        return ast

    def sup_integer(self, ast):  # noqa
        return ast

    def sub_integer(self, ast):  # noqa
        return ast

    def digit(self, ast):  # noqa
        return ast

    def set_operators(self, ast):  # noqa
        return ast

    def union_operator(self, ast):  # noqa
        return ast

    def intersect_operator(self, ast):  # noqa
        return ast

    def func_id(self, ast):  # noqa
        return ast

    def identifier_alone(self, ast):  # noqa
        return ast

    def identifier(self, ast):  # noqa
        return ast

    def identifier_with_multi_subscript(self, ast):  # noqa
        return ast

    def function_operator(self, ast):  # noqa
        return ast

    def local_func(self, ast):  # noqa
        return ast


def main(filename, **kwargs):
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = grammarinitParser()
    return parser.parse(
        text,
        filename=filename,
        **kwargs
    )


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, grammarinitParser, name='grammarinit')
    data = asjson(ast)
    print(json.dumps(data, indent=2))
#!/usr/bin/env python

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.



from typing import Any
from dataclasses import dataclass

from tatsu.objectmodel import Node
from tatsu.semantics import ModelBuilderSemantics


@dataclass(eq=False)
class ModelBase(Node):
    pass


class grammarinitModelBuilderSemantics(ModelBuilderSemantics):
    def __init__(self, context=None, types=None):
        types = [
            t for t in globals().values()
            if type(t) is type and issubclass(t, ModelBase)
        ] + (types or [])
        super().__init__(context=context, types=types)


@dataclass(eq=False)
class Start(ModelBase):
    vblock: Any = None


@dataclass(eq=False)
class Exponent(ModelBase):
    exp: Any = None
    pow: Any = None


@dataclass(eq=False)
class Mantissa(ModelBase):
    d: Any = None
    f: Any = None


@dataclass(eq=False)
class Float(ModelBase):
    e: Any = None
    m: Any = None


@dataclass(eq=False)
class Double(ModelBase):
    exp: Any = None
    f: Any = None
    i: Any = None


@dataclass(eq=False)
class Fraction(ModelBase):
    value: Any = None


@dataclass(eq=False)
class Add(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class Subtract(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class AddSub(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class Multiply(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class Divide(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class Derivative(ModelBase):
    f: Any = None
    lorder: Any = None
    lower: Any = None
    s: Any = None
    uorder: Any = None
    upper: Any = None


@dataclass(eq=False)
class Partial(ModelBase):
    f: Any = None
    l: Any = None
    lorder: Any = None
    lower: Any = None
    s: Any = None
    uorder: Any = None
    upper: Any = None


@dataclass(eq=False)
class Divergence(ModelBase):
    name: Any = None
    value: Any = None


@dataclass(eq=False)
class Gradient(ModelBase):
    name: Any = None
    sub: Any = None
    value: Any = None


@dataclass(eq=False)
class Laplace(ModelBase):
    name: Any = None
    value: Any = None


@dataclass(eq=False)
class Power(ModelBase):
    base: Any = None
    power: Any = None
    r: Any = None
    t: Any = None


@dataclass(eq=False)
class Solver(ModelBase):
    left: Any = None
    p: Any = None
    right: Any = None


@dataclass(eq=False)
class Summation(ModelBase):
    cond: Any = None
    enum: Any = None
    exp: Any = None
    extra: Any = None
    id: Any = None
    lower: Any = None
    range: Any = None
    sign: Any = None
    sub: Any = None
    u: Any = None
    upper: Any = None


@dataclass(eq=False)
class Optimize(ModelBase):
    amax: Any = None
    amin: Any = None
    cond: Any = None
    defs: Any = None
    exp: Any = None
    init: Any = None
    max: Any = None
    min: Any = None


@dataclass(eq=False)
class MultiCond(ModelBase):
    cond: Any = None
    m_cond: Any = None


@dataclass(eq=False)
class Integral(ModelBase):
    d: Any = None
    exp: Any = None
    id: Any = None
    lower: Any = None
    upper: Any = None


@dataclass(eq=False)
class Domain(ModelBase):
    lower: Any = None
    upper: Any = None


@dataclass(eq=False)
class Norm(ModelBase):
    double: Any = None
    power: Any = None
    single: Any = None
    sub: Any = None
    value: Any = None


@dataclass(eq=False)
class InnerProduct(ModelBase):
    left: Any = None
    right: Any = None
    sub: Any = None


@dataclass(eq=False)
class FroProduct(ModelBase):
    left: Any = None
    right: Any = None


@dataclass(eq=False)
class HadamardProduct(ModelBase):
    left: Any = None
    right: Any = None


@dataclass(eq=False)
class CrossProduct(ModelBase):
    left: Any = None
    right: Any = None


@dataclass(eq=False)
class KroneckerProduct(ModelBase):
    left: Any = None
    right: Any = None


@dataclass(eq=False)
class Transpose(ModelBase):
    f: Any = None


@dataclass(eq=False)
class PseudoInverse(ModelBase):
    f: Any = None


@dataclass(eq=False)
class Squareroot(ModelBase):
    f: Any = None


@dataclass(eq=False)
class ElementConvertFunc(ModelBase):
    e: Any = None
    es: Any = None
    f: Any = None
    fs: Any = None
    params: Any = None
    s: Any = None
    se: Any = None
    separators: Any = None
    t: Any = None
    ts: Any = None
    tu: Any = None
    v: Any = None
    vs: Any = None


@dataclass(eq=False)
class ExpFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class MinmaxFunc(ModelBase):
    max: Any = None
    min: Any = None
    params: Any = None
    separators: Any = None


@dataclass(eq=False)
class LogFunc(ModelBase):
    f: Any = None
    param: Any = None
    s: Any = None


@dataclass(eq=False)
class LnFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class SqrtFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class Matrix(ModelBase):
    value: Any = None


@dataclass(eq=False)
class Vector(ModelBase):
    exp: Any = None


@dataclass(eq=False)
class Set(ModelBase):
    cond: Any = None
    enum: Any = None
    exp: Any = None
    f: Any = None
    o: Any = None
    range: Any = None


@dataclass(eq=False)
class MultiCondExpr(ModelBase):
    ifs: Any = None
    other: Any = None


@dataclass(eq=False)
class MultiIfs(ModelBase):
    ifs: Any = None
    value: Any = None


@dataclass(eq=False)
class SingleIf(ModelBase):
    cond: Any = None
    stat: Any = None


@dataclass(eq=False)
class MatrixRows(ModelBase):
    r: Any = None
    rs: Any = None


@dataclass(eq=False)
class MatrixRow(ModelBase):
    exp: Any = None
    rc: Any = None
    value: Any = None


@dataclass(eq=False)
class MatrixRowCommas(ModelBase):
    exp: Any = None
    value: Any = None


@dataclass(eq=False)
class ExpInMatrix(ModelBase):
    sign: Any = None
    value: Any = None


@dataclass(eq=False)
class NumMatrix(ModelBase):
    id1: Any = None
    id2: Any = None
    left: Any = None


@dataclass(eq=False)
class Factor(ModelBase):
    c: Any = None
    id0: Any = None
    m: Any = None
    nm: Any = None
    num: Any = None
    op: Any = None
    s: Any = None
    sub: Any = None
    v: Any = None


@dataclass(eq=False)
class IdentifierSubscript(ModelBase):
    exp: Any = None
    left: Any = None
    p: Any = None
    right: Any = None


@dataclass(eq=False)
class IdentifierAlone(ModelBase):
    value: Any = None


@dataclass(eq=False)
class SizeOp(ModelBase):
    i: Any = None


@dataclass(eq=False)
class Pi(ModelBase):
    pass


@dataclass(eq=False)
class Infinity(ModelBase):
    pass


@dataclass(eq=False)
class E(ModelBase):
    pass


@dataclass(eq=False)
class SinFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class AsinFunc(ModelBase):
    name: Any = None
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class CosFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class AcosFunc(ModelBase):
    name: Any = None
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class TanFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class AtanFunc(ModelBase):
    name: Any = None
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class SinhFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class AsinhFunc(ModelBase):
    name: Any = None
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class CoshFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class AcoshFunc(ModelBase):
    name: Any = None
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class TanhFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class AtanhFunc(ModelBase):
    name: Any = None
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class CotFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class SecFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class CscFunc(ModelBase):
    param: Any = None
    power: Any = None


@dataclass(eq=False)
class Atan2Func(ModelBase):
    param: Any = None
    second: Any = None
    separator: Any = None


@dataclass(eq=False)
class TraceFunc(ModelBase):
    name: Any = None
    param: Any = None


@dataclass(eq=False)
class DiagFunc(ModelBase):
    extra: Any = None
    param: Any = None
    separator: Any = None


@dataclass(eq=False)
class VecFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class InverseVecFunc(ModelBase):
    name: Any = None
    origin: Any = None
    param: Any = None
    s: Any = None
    separator: Any = None


@dataclass(eq=False)
class DetFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class RankFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class NullFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class OrthFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class InvFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class SvdFunc(ModelBase):
    param: Any = None


@dataclass(eq=False)
class Import(ModelBase):
    names: Any = None
    package: Any = None
    params: Any = None
    separators: Any = None
    star: Any = None


@dataclass(eq=False)
class ImportVar(ModelBase):
    name: Any = None
    r: Any = None


@dataclass(eq=False)
class WhereConditions(ModelBase):
    value: Any = None


@dataclass(eq=False)
class WhereCondition(ModelBase):
    attrib: Any = None
    belong: Any = None
    desc: Any = None
    id: Any = None
    subset: Any = None
    type: Any = None


@dataclass(eq=False)
class DeWhereCondition(ModelBase):
    attrib: Any = None
    desc: Any = None
    id: Any = None
    subset: Any = None
    type: Any = None


@dataclass(eq=False)
class ParamsBlock(ModelBase):
    annotation: Any = None
    conds: Any = None


@dataclass(eq=False)
class Statements(ModelBase):
    stat: Any = None


@dataclass(eq=False)
class Expression(ModelBase):
    sign: Any = None
    value: Any = None


@dataclass(eq=False)
class Destructure(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class Assignment(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class GeneralAssignment(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class Subexpression(ModelBase):
    value: Any = None


@dataclass(eq=False)
class IfCondition(ModelBase):
    other: Any = None
    se: Any = None
    single: Any = None


@dataclass(eq=False)
class AndCondition(ModelBase):
    atom: Any = None
    other: Any = None
    se: Any = None


@dataclass(eq=False)
class AtomCondition(ModelBase):
    cond: Any = None
    p: Any = None


@dataclass(eq=False)
class InCondition(ModelBase):
    left: Any = None
    right: Any = None


@dataclass(eq=False)
class NotInCondition(ModelBase):
    left: Any = None
    right: Any = None


@dataclass(eq=False)
class NeCondition(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class EqCondition(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class GreaterCondition(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class GreaterEqualCondition(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class LessCondition(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class LessEqualCondition(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithExpression(ModelBase):
    sign: Any = None
    value: Any = None


@dataclass(eq=False)
class ArithAdd(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithSubtract(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithMultiply(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithDivide(ModelBase):
    left: Any = None
    op: Any = None
    right: Any = None


@dataclass(eq=False)
class ArithFactor(ModelBase):
    id0: Any = None
    num: Any = None
    size: Any = None
    sub: Any = None


@dataclass(eq=False)
class ArithSubexpression(ModelBase):
    value: Any = None


@dataclass(eq=False)
class MatrixType(ModelBase):
    attr: Any = None
    id1: Any = None
    id2: Any = None
    type: Any = None


@dataclass(eq=False)
class VectorType(ModelBase):
    attr: Any = None
    id1: Any = None
    type: Any = None


@dataclass(eq=False)
class ScalarType(ModelBase):
    z: Any = None


@dataclass(eq=False)
class SetType(ModelBase):
    cnt: Any = None
    homogeneous_types: Any = None
    sub_types: Any = None
    type: Any = None
    type1: Any = None
    type2: Any = None


@dataclass(eq=False)
class TupleType(ModelBase):
    sub_types: Any = None


@dataclass(eq=False)
class NamedType(ModelBase):
    e: Any = None
    f: Any = None
    m: Any = None
    s: Any = None
    t: Any = None
    v: Any = None


@dataclass(eq=False)
class FunctionType(ModelBase):
    empty: Any = None
    params: Any = None
    ret: Any = None
    ret_separators: Any = None
    separators: Any = None


@dataclass(eq=False)
class MappingType(ModelBase):
    dst: Any = None
    s: Any = None
    src: Any = None


@dataclass(eq=False)
class Integer(ModelBase):
    value: Any = None


@dataclass(eq=False)
class SupInteger(ModelBase):
    value: Any = None


@dataclass(eq=False)
class SubInteger(ModelBase):
    value: Any = None


@dataclass(eq=False)
class Union(ModelBase):
    left: Any = None
    right: Any = None


@dataclass(eq=False)
class Intersection(ModelBase):
    left: Any = None
    right: Any = None


@dataclass(eq=False)
class Function(ModelBase):
    name: Any = None
    p: Any = None
    params: Any = None
    separators: Any = None
    subs: Any = None


@dataclass(eq=False)
class LocalFunc(ModelBase):
    def_p: Any = None
    def_s: Any = None
    defs: Any = None
    expr: Any = None
    extra: Any = None
    name: Any = None
    op: Any = None
    params: Any = None
    separators: Any = None
